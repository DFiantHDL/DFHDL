\section{A Dataflow Hardware Description Abstraction}
\label{sec:motivation}
In this section we detail how dataflow abstraction, when applied to an HDL, helps to decouple the function from its constraints. We also describe generally what dataflow HDL constructs are required to achieve maximum portable code, and in the next section we specifically demonstrate these constructs take effect in DFiant.

\fig{fig:motivation} summarizes the basic elements that make up HDLs at different abstraction layers, from the lowest layer, a netlist, to the dataflow HDL layer presented in this paper. Each layer includes the expressive capabilities of the lowest layer (e.g., structural instance composition is possible in all HDLs). The layers are tagged with the relevant HDL names. Note that HLS languages and simulation constructs are not included in this summary. 

The basic notion of a dataflow abstraction is that instead of wires and registers we have dataflow token streams. This key difference between RTL and dataflow abstractions reveal why one is coupled to the device and timing constraints while the other is agnostic to them. Firstly, the RTL abstraction utilizes combinational operations that must complete (their propagation delay) within a given cycle if fed to a register, while the dataflow abstraction only assumes order and not exactly when the operations are to complete. This decoupling from fixed clock cycles leaves the option to pipeline the operations at will. Secondly, the RTL abstraction directly uses registers for variety of other reasons, thus binds the design to specific timing conditions, while the dataflow abstraction provides higher constructs to avoid specific clock binding where possible. We classify the various register use-cases, and present their dataflow abstracted counterpart. The classifications are divided into three main categories: \textit{synchronous technology backend}, \textit{synchronous technology interface}, and \textit{state}.

\subsection{Synchronous Technology Backend}
Registers are often forced upon the design due to a synchronous technology choice. Since they are unrelated to the functional requirement, a dataflow HDL requires no constructs to express them and relies on its compiler to implement them properly based on the functional requirements and design constraints. 
We differentiate between the following backend register uses:
\subsubsection{Pipelining and Path-Balancing}
Pipeline registers are inserted to split long combinational paths and their placement is determined by designer-specified constraints, such as the maximum path cycle latency, or the maximum propagation delay between registers. Pipelining increases the path cycle latency, and if the path converges with another path that requires no pipelining, then additional path-balancing registers are added to maintain correctness of the design. Because a balanced pipelining does not affect the design functionality, it can be automatically applied in dataflow HDL compilers.   
\subsubsection{Synchronizers}
Sampling clock domain crossing (CDC) or asynchronous signals is exposed to metastability. Synchronizers, often composed of registers, are used to mitigate its effect and bring the design to the proper reliability. Since we aspire for a clockless design frontend, we want the synchronizers to be implicit. A dataflow HDL compiler needs to infer synchronizers according to the design constraints. This work covers the trivial case of a single clock backend, and does not require synchronizers.

\subsection{Synchronous Technology Interface}
Functional design requirements are often accompanied by synchronous input/output (IO) timing constraints such as clocked protocol interfaces or real-time restrictions. However, these constraints only affect the interface, and are unrelated to the design core. To maximize design portability, we apply timed or legacy constructs \emph{solely in the periphery}, while coding the design core with only timeless dataflow constructs. We differentiate between the following synchronous signaling:
\subsubsection{External IO and Blackbox Interfaces}
External IOs that are exposed to the top design hierarchy or blackboxes that are exposed to the internal design core may impose synchronous protocols (e.g., data is valid one clock cycle after address is set). A dataflow HDL supports legacy RTL constructs to synchronously interface external IOs and instantiate blackboxes. 
\subsubsection{Timers}
Timers are design constructs for outputting real-time signals or creating derivations of timed signal inputs. For example, a target device is fed by a 100MHz clock and we want to output a UART stream at 10Mbps or toggle a led at 1Hz. Instead of directly diving the clock via registers or clock generation components (e.g., PLLs), we can create functional representation of their timed use-cases. A dataflow HDL has timer constructs that generate tokens at a given or derived rate. The compiler can take all clocks into consideration and generate the proper clock tree based on the available device resources and other design constraints. 

\subsection{State}
State occurs when we require access to (previous) values which are no longer available on a function's inputs (e.g., cumulative sum or a state-machine's state). RTL designs invoke registers (behaviorally) to save the state. Unfortunately, registers not only save the state, but also enforce specific cycle latencies. Furthermore, typical RTL languages declare additional variables and place extra assignments just to save the state. A dataflow HDL overcomes all these issues and in a less cumbersome way by including a construct to summon a token from the stream history. Additionally, a related construct should set the initial token history that is fetched when the stream history is first summoned.
We differentiate between two kinds of state: \textit{derived state}, and \textit{regular state}. 


\subsubsection{Derived State} 
A derived state is a state whose current output value is \textit{independent} of its previous value. For example, checking if a dataflow stream value has changed requires summoning the previous token and comparing to the current token. 

\subsubsection{Regular State} 
A regular state is a state whose current output value is \textit{dependent} of its previous state value. For example, the current cumulative sum value is dependent on the previous sum value. Therefore, a dataflow HDL requires not only to fetch previous token values, but also set the future state value. Addressable memory pools also hold regular state (e.g., a processor register-file, memory blocks), and can be expressed as a large selectable state array or available dedicated memory components.

The two kinds of state differ heavily in performance improvement when the design is pipelined. A derived state path can produce a token for every clock tick, and if we pipeline a combinational operation to increase the maximum frequency, the maximum throughput will increase as well. Contrarily, a regular state path is circular and cannot be pipelined as-is. Alternatively, we can increase the clock frequency by constructing a multi-cycle path, but not necessarily increasing the throughput.

Regular state causes bottlenecks in many systems. For instance, a RISC-V processor program counter (PC) register manifests as a regular state. The processor pipeline can only be improved thanks to a speculative mechanism that predicts the next PC value to prefetch instructions (e.g., PC+4 for a branch-not-taken prediction). In case of a miss-prediction, other mechanisms take place. Further research may expand on dataflow abstractions, and solve such problems functionally.


%The DFiant state abstraction is achievable via the \code{.prev} construct, to summon the previous dataflow variable value, and also the construct \code{.init(value)}, to create an initialized dataflow variable. The \code{:=} assignment operation is available for a mutable dataflow variable such as \code{c} (see Section~\ref{sec:mutability}). The creation of \code{c} carries within it an implicit assignment \code{c := c.init(0).prev}, which makes the next assignment of \code{c}, \code{c := i + c}, equivalent to \code{c := i + c.init(0).prev}. This is possible due to the following semantics: \textit{previous values change at the end of the DFiant code} (similarly to signal update semantics in VHDL processes). One advantage is that the code resembles its RTL counterparts, but less verbose. Another advantage is that any type of state component, like the Muller C-element\cite{muller1957theory}, can be applied with DFiant as a frontend (note that the functional drawing in Table~\ref{tbl:StateExDefImpl} has no register drawn).

%\subsubsection{Speculated State} 
%A speculated state is a regular state that can generate a new speculative value when the actual next value is unavailable.

%In some cases a regular state limits the throughput too much. For example, a program counter (PC) register for a microprocessor pipeline. If we state dependent on the PC as a regular state, it won't be possible for the pipeline to handle more than one instruction at a time. A known solution for this is to speculate on the next value of PC (good guess is branch not taken). If we guessed wrong the pipeline should ignore the prefetched instructions and restart from where the branch occurred. This allows us to generate new speculative tokens of PC, without waiting for the pipeline to supply the vi

%There is no actual dataflow feedback. 
