\section{Related Work}
\label{sec:related_work}
%Raising hardware design abstractions has well known benefits \cite{coussy2009guest}, \cite{coussy2009introduction}. Nonetheless, HLS  still do not win vs VHDL. Martin, et al.~\cite{Cong2011} explain why past generations of HLS tools were not successful and what is required of new languages and tools. Gajski, et al. \cite{gajski2010input} and Hofstra and Matthijs \cite{hofstra2012comparing} compare HDL characteristics.

Recent studies~\cite{Kapre2016, Nane2016, Windh2015} surveyed a variety of HDLs and HLS tools. Neither survey had explicit conclusion which tool or language should be used for hardware design. Earlier, we focused on comparing DFiant to VHDL and C++-based HLS. We rely on the surveys conclusions, and contrast DFiant to a few key hardware design languages and tools.

%Why unlike chisel. Chisel is advanced RTL. Compiled to Chisel.
%To be completed. Main focus: Recent HLS and DSL surveys, Maxeler, Chisel/SpinalHDL, Vivado HLS, Bluespec, Synflow(Cx), OpenCL, SystemVerilog SystemC. MyHDL.

%We have classified the related HDL and HSL tools into five categories, examined them against the limitations we described in \ref{chap:motivation}, and summarized the results into \ref{tbl:HDLs comparison}. The categories are: Native HDLs, Advanced HDLs, Functional HDLs, HLS Tools and Asynchronous HDLs. The following sections give more details for each category and language.



%\subsection*{System C} 
%This category of HDLs refers to modern HDLs which were not developed to provide a high level of synthesis, but to have less verbose and more easily generated RTL code, with higher level device-agnostic language constructs (FIFOs, BRAMs, etc.).
%Our work does recognize the importance of high-level functional constructs. However, we believe that burdening the designer with low level coding, such as the need to explicitly use registers to pipeline the design (which is a target specific element), is inefficient.
\paragraph*{\bf \em Chisel, SpinalHDL, and VeriScala}
Chisel~\cite{Bachrach2012}, SpinalHDL~\cite{Charles2016}, and VeriScala~\cite{Liu2017} are Scala-based libraries that provide advanced HDL constructs. SpinalHDL focuses on a more accurate hardware description (e.g., multiple clock domains), while Chisel focuses on providing cycle accurate simulation alongside its HDL constructs (via C++ test code generation), and VeriScala focuses on IDE-interactive FPGA application testing. When compared to DFiant, all three HDL libraries utilize RTL constructs by implicitly or explicitly invoking clocked registers, and do not auto-pipeline designs. Moreover, DFiant is an early-adopter of new Scala features such as literal types~\cite{TypeLevelScala} and operations~\cite{singleton-ops}, which further improve type safety (e.g., a \code{DFBits[5].bits(Hi,Lo)} bit selection is compile-time-constrained within the 5-bits vector width confines).

%\paragraph*{\bf \em Chisel and SpinalHDL}
%Both Chisel and SpinalHDL~\cite{Charles2016} are Scala-based libraries that provide advanced HDL constructs.  Both libraries resemble RTL semantics and do not auto-pipeline designs.
%DFiant also imposes a tighter type safety, and raises most compilation errors to be asserted at the Scala compile-time.
%DFiant simulation can be executed within the Scala IDE, including breakpoints, watches, and console printouts. 

\paragraph*{\bf \em Synflow Cx} 
Synflow developed Cx~\cite{CxLang2014} as a designer-oriented RTL with new language semantics that better fit hardware design than the classic C syntax.
However, the concurrency in Cx limits dataflow description flexibility. A \code{fence} statement is required to force a new cycle. This statement affects all variables within a \code{task}. To avoid this, separate tasks are required, which limits functional clustering in a single task.
Moreover, Cx is not object-oriented and has a limited type-system.

\paragraph*{\bf \em MyHDL and PyRTL}
MyHDL~\cite{decaluwe2004myhdl} and PyRTL~\cite{Clow2017} are Python-based RTLs. MyHDL favors verification capabilities over purely synthesizable hardware constructs, in contrary to our approach in DFiant. PyRTL provides a large primitives library and a complete tool-chain. Both MyHDL and PyRTL carry RTL constructs and therefore do not support automatic pipelining. Moreover, as Python-based libraries, they also lack type-safety.

\paragraph*{\bf \em Bluespec} 
Bluespec uses concurrent guarded atomic actions to create rules that derive hardware construction. Bluespec's rules are atomic and execute within a single clock cycle. Consequently, the rule semantics bound the design to the clock, and if the design does not meet timing constraints, the rules system must be modified.
%Furthermore, Bluespec's rules are not very intuitive to hardware designers, who are usually dataflow oriented. Making a mistake in the rules system may lead to guess work locating the missing or interrupting rule.
%While it may give a high productivity in some domains, it is not as easy for all general purpose hardware designs.
%In fact, Bluespec was the first source of inspiration for this work.

\paragraph*{\bf \em Vivado HLS} 
Vivado HLS~\cite{Vivado2012} is a mature tool that helps achieve high productivity in some domains. Nevertheless, it is not accepted as a general purpose HDL, since its C/C++ semantics are unfitting~\cite{Zhao2017} and its SystemC synthesizable constructs provide roughly identical capabilities of traditional RTLs~\cite{gajski2010input}.

\paragraph*{\bf \em Maxeler} 
The Maxeler framework~\cite{Pell2011} and its MaxJ Java-based programming language take part in acceleration systems. MaxJ is dataflow-centric, same as DFiant, and provides constructs to fetch previous values from a token stream. However, MaxJ is tailored for its target hardware framework and does not fit as a general purpose HDL. Furthermore, while MaxJ possesses a limited set of counters for general loop control, DFiant has no such limitations thanks to its \code{prev} semantics which enable expressing any required control state.

\paragraph*{\bf \em OpenDF} 
The OpenDF framework~\cite{bhattacharyya2008opendf} which is based on the CAL actor language~\cite{eker2003cal} is a dataflow hardware description framework. Its paper provides similar motivation to use the dataflow programming model for hardware description instead of sequential languages such as C. However, using actors and networks is completely different than conventional hardware and software programming languages. We already demonstrated that DFiant can achieve the same dataflow description capability, and in a more intuitive and familiar fashion.
