

\chapter{Related work}
\label{chap:relwork}

\paragraph{}Recent studies \cite{Kapre2016}, \cite{Nane2016}, \cite{Windh2015} surveyed a considerable variety of HDLs and HLS tools. Neither survey had explicit conclusion which tool or language should be used for hardware design. In this chapter, we contrast DFiant to a few key hardware design languages and tools, and later in Chapter~\ref{chap:DFiant}, we thoroughly compare DFiant to VHDL and C++-based HLS.


%Earlier, we focused on comparing DFiant to VHDL and C++-based HLS. In this chapter, we further contrast DFiant to a few key hardware design languages and tools.


\paragraph*{\bf \em Chisel, SpinalHDL, and VeriScala}
Chisel~\cite{Bachrach2012}, SpinalHDL~\cite{Charles2016}, and VeriScala~\cite{Liu2017} are Scala-based libraries that provide advanced HDL constructs. SpinalHDL focuses on a more accurate hardware description (e.g., multiple clock domains), while Chisel focuses on providing cycle accurate simulation alongside its HDL constructs (via C++ test code generation), and VeriScala focuses on FPGA co-simulation. All three DSL libraries resemble RTL semantics and do not auto-pipeline designs. 

\paragraph*{\bf \em Synflow Cx} 
Synflow developed Cx~\cite{CxLang2014} as a designer-oriented HDL with new language semantics that better fit hardware design than the classic C syntax.
However, the concurrency in Cx limits dataflow description flexibility. A \code{fence} statement is required to force a new cycle. This statement effects all variables within a \code{task}. To avoid this, separate tasks are required, which limits functional clustering in a single task.
Moreover, Cx is not object-oriented and has a limited type-system.

\paragraph*{\bf \em MyHDL}
MyHDL~\cite{decaluwe2004myhdl} is a Python-based HDL. MyHDL favors verification capabilities over purely synthesizable hardware constructs, in contrary to our approach in DFiant. Since MyHDL is based on Python, it also lacks type-safety. MyHDL does not handle pipelining automatically.

\paragraph*{\bf \em Bluespec} 
Bluespec~\cite{nikhil2004bluespec} uses a concurrent guarded atomic actions to create rules that derive hardware construction. Bluespec's rules are atomic and execute within a single clock cycle. Consequently, the rule semantics bound the design to the clock, and if the design does not meet timing, the rules system must be modified. 
%Furthermore, Bluespec's rules are not very intuitive to hardware designers, who are usually dataflow oriented. Making a mistake in the rules system may lead to guess work locating the missing or interrupting rule.
%While it may give a high productivity in some domains, it is not as easy for all general purpose hardware designs.
%In fact, Bluespec was the first source of inspiration for this work.

\paragraph*{\bf \em Vivado HLS} 
Vivado HLS~\cite{Vivado2012} is a mature tool that helps achieve high productivity in some domains. Nevertheless, it is not accepted as a general purpose HDL, since its C/C++ semantics are unfitting~\cite{Zhao2017}, and its SystemC synthesizable constructs provide roughly identical capabilities of traditional HDLs~\cite{gajski2010input}. 

\paragraph*{\bf \em MaxJ} 
The Maxeler framework~\cite{Pell2011} and its MaxJ Java-based programming language take part in acceleration systems. MaxJ is dataflow-centric, same as DFiant, but is tailored for its target use-case and does not fit as a general purpose HDL.

\paragraph*{\bf \em SystemVerilogCSP and Tiempo} 
Both SystemVerilogCSP \cite{saifhashemi2011systemverilogcsp} and Tiempo \cite{renaudin2012tiempo} HDLs provide an RTL-equivalent description for asynchronous logic building blocks. Although they provide high-level abstraction in terms of the asynchronous handshake, using these HDLs forces the designer to code explicitly for asynchronous design.

\paragraph*{\bf \em Dataflow Languages} 
Dataflow languages such as LUSTRE~\cite{Caspi1987}, Lucid~\cite{wadge1985lucid}, and Signal~\cite{le1986signal}, were developed for general-purpose dataflow signal processing and not hardware description (e.g., no IO annotation, bit-accuracy).


