\chapter{Research Trajectory: Design Space Exploration}
\label{chap:tarjectory_dsexplore}

DFiant is target-agnostic and can potentially compile any functional design to fit any viable target device. Nonetheless, meeting functional requirements is not enough and designers should be able to constrain the design to meet explicit performance and utilization requirements. Furthermore, operation and data scheduling, as coded by the designer, have considerable effect on the design's potential performance and utilization. In this trajectory, we propose constructs that enable designers to constrain the design, suggest scheduling alternatives, and even request an overall cost-minimized solution.
  
\section{Designer Constraints}
Constraints add non-functional information to the design. We differentiate between two types of constraints: \textit{target-specific} (e.g., IO pins), and \textit{target-agnostic} (e.g., throughput, latency, power, utilization, reliability). Design space exploration techniques typically revolve around target-agnostic constraints, but the compiler may be too limited if target-specific constraints are applied ineffectively.
Since we aim for target-agnostic designs, we propose separating and annotating constraints that bind the design to a specific target device or technology. For example, if a target device has a 200MHz input clock with a data-bus supporting up to 200 million data payloads per second, we would separate the IO constraint from the throughput requirement. The throughput requirement can be accomplished in various ways, unrelated to the target device, while the IO interface is given and fixed to specific pins. 
  

\section{Design Option Construct}
Earlier, in \fig{fig:Reusable}, we encountered three different implementations for the same functionality: $out_i=a_i+b_i+c_i$.~ The definition \code{sumA} uses two adders, while \code{sumB} and \code{sumC} only use a single adder, at the expense of throughput. Choosing either implementation affects the design's utilization and performance. \fig{fig:naiveSumOf3} provides an encapsulating definition with the boolean parameter \code{rateOpt} to select better token rate instead of better adder utilization. We can easily select the proper implementation if the design has a few \code{sumOf3} instances, but a design can have hundreds of such instances. Furthermore, if an IP component internally has \code{sumOf3} instances, it is unreasonable to propagate all the IP's \code{rateOpt} parameters to the IP's interface, first for brevity, and second to prevent implementation leaks from a functional blackbox.

  \begin{figure}[h]
	\centering
	\begin{minipage}{\linewidth}
		\begin{minted}[autogobble,tabsize=2,framesep=1pt, frame=single,fontsize=\scriptsize]{scala}
		def naiveSumOf3(rateOpt:Boolean)(a : DFUInt[32], b : DFUInt[32], c : DFUInt[32]) : DFUInt[32]= {
			if (rateOpt) sumA(a, b, c) else sumC(a, b, c)
		}
		\end{minted}
	\end{minipage}
	\captionof{figure}{Naive sum-of-three example}
	\label{fig:naiveSumOf3}
\end{figure}

To resolve this issue, we require the designer's dilemma (e.g, what to set for \code{rateOpt}) to be solved by the DFiant compiler. For this purpose, we propose new constructs: \code{designOption} and \code{designSelect}. In \fig{fig:smartSumOf3} we declare two design-options and select between them as output.
  \begin{figure}[h]
	\centering
	\begin{minipage}{\linewidth}
		\begin{minted}[autogobble,tabsize=2,framesep=1pt, frame=single,fontsize=\scriptsize]{scala}
		def smartSumOf3(a : DFUInt[32], b : DFUInt[32], c : DFUInt[32]) : DFUInt[32]= {
		  val do1 = designOption {sumA(a, b, c)}
		  val do2 = designOption {sumC(a, b, c)}
			designSelect(do1, do2) //This is an exclusive selection
		}
		\end{minted}
	\end{minipage}
	\captionof{figure}{Sum-of-three example using design option constructs}
	\label{fig:smartSumOf3}
\end{figure}

The DFiant compiler can estimate the utilization and performance from the implementation and choose the appropriate instance based on the design's global constraints. These constructs give designers similar abilities to pragma statements in Vivado HLS, but with much greater programming control (these are not pragmas, but classes within the DFiant library that can be expanded and fully-interacted with).

We are faced with a challenging algorithmic problem. A design in DFiant can have canonized design options, which may explode compilation time if we do not apply a good algorithm to select the appropriate instances. 

%We can see the the advantage to traditional HLS. The scheduling in DFiant is explicit, but DFiant also can implement mechanisms to choose a good implementation as hinted by the developer.

\section{Design to Cost}
For developers using FPGAs, a typical project starts with a specific target device in mind, which was selected based on the target application utilization estimation. The printed circuit board and logic design are then both tailored for the chosen device. An underestimation of the target application's utilization may prevent the project from completing. To counter this, an overestimation may occur, rendering a more costly product. Additionally, since different vendor devices carry a variance in production cost and power consumption, it may be crucial to select a more costly device that can save money in power requirements. 

DFiant can provide an interesting solution to these issues. Since designs can truly be device-agnostic, we can use the constraints solver to find the least costly solution from a range of potential devices for the given functional requirement. The solver can take into consideration power consumption estimation, device production cost, and other constraints.