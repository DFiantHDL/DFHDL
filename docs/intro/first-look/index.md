# DFiant: First Look

Your first encounter with the DFiant syntax, semantics and language features

---

In this section we provide simple examples to demonstrate various DFiant syntax, semantics and languages features. If you wish to understand how to run these examples yourself, please refer to the <u>Getting Started</u> chapter of this documentation. 

## Main Feature Overview

* Target and timing agnostic dataflow hardware description
* Strong bit-accurate type-safety
* Simplified port connections
* Automatic latency path balancing
* Automatic/manual pipelining
* Meta hardware description via rich Scala language constructs


## Basic Example: An Identity Function

Let's begin with a basic example. The dataflow design `ID` has a signed 16-bit input port `x` and a signed 16-bit output port `y`. We implemented an identity function between the input and output, meaning that for an input series $x_k$ the output series shall be $y_k=x_k$. Fig. 1a depicts a functional drawing of the design and Fig. 1b contains three tabs: the `ID.scala` DFiant compilation program code which implements `ID` and compiles it to VHDL (2008) and the generated VHDL files.

<p align="center">
  <img src="../first-look/id.png"><br>
  <b>Fig. 1a: Functional drawing of the dataflow design 'ID' with an input port 'x' and an output port 'y'</b><br>
</p>


=== "ID.scala"

    ``` scala
    --8<-- "examples/first-look/src/main/scala/ID.scala"
    ```

=== "ID.vhdl"

    ``` vhdl
    --8<-- "examples/first-look/src/test/resources/id/vhdl2008/ID.vhdl"
    ```

=== "ID_pkg.vhdl"

    ``` vhdl
    --8<-- "examples/first-look/src/test/resources/id/vhdl2008/ID_pkg.vhdl"
    ```

=== "ID.v"

    ``` verilog
    --8<-- "examples/first-look/src/test/resources/id/verilog2001/ID.v"
    ```

=== "ID_defs.v"

    ``` verilog
    --8<-- "examples/first-look/src/test/resources/id/verilog2001/ID_defs.v"
    ```

<p align="center">
  <b>Fig. 1b: A DFiant implementation of the identity function as a toplevel design and the generated VHDL/Verilog files</b><br>
</p>


The Scala code in Fig. 1b describes a program that runs the DFiant compiler on an identity function dataflow design, `ID`. Since DFiant is a Scala library some if its compilation process is done statically via the Scala compiler and the rest during the Scala runtime execution. 

!!! summary "Writing a DFiant compilation program â€“ easy as 1-2-3!"

	1. `#!scala import DFiant._` to import all the required namespace fields
	2. `#!scala trait _design_name_ extends DFDesign {}` to define your dataflow design. Populate your design with the required dataflow functionality.
	3. `#!scala object _program_name_ extends DFApp.VHDLCompiler[_design_name_]` to create your compilation program entry point.

??? info "ID.scala line-by-line breakdown"
	* **Line 1**: This `#!scala import` statement summons all the DFiant classes, types and objects into the current scope. This is a must in every DFiant codebase.

	* **Lines 3-7**: This `ID` Scala `#!scala trait` is extended from the `DFDesign` (abstract) class and therefore declares it as a dataflow design. The reason why this is a `#!scala trait` and not a `#!scala class` is discussed [later]() in this documentation. Currently, the *rule of thumb* to describe dataflow designs is to use traits that extend `DFDesign`.
	
		* **Lines 4-5**: Here we construct the input port `x` and output port `y`.Both were set as a 16-bit signed integer dataflow variable via the `DFSInt[W]` constructor, where `W` is a width **type** argument that can accept any positive integer literal. It is also possible to use a width **term** argument via`DFSInt(width)`. DFiant also support various types such as `DFBits`, `DFUInt`, and `DFBool`. All these dataflow variable construction options and more are discussed [later](/getting-started/) in this documentation. <br />The syntax `#!scala val _name_ = _dataflow_variable_constructor_ <> _direction_` is used to construct a port and give it a named Scala reference. The Scala reference name will affect the name of this port when compiled to the required backend representation. 
	
		* **Line 6**: The assignment operator `:=` set the dataflow output port to receive input port values as they are.
	
	* **Line 9**: This object is an extension of a [Scala `App` trait](https://www.scala-lang.org/api/current/scala/App.html) that creates a `main` entry point for the DFiant compilation program. By inheriting `DFApp.VHDLCompiler[_top_]` we also generate the top design and execute the compilation and commitment to VHDL files. 

??? info "Generated VHDL files observations"
	* The id.vhdl file is readable and maintains the names set in the DFiant design. The generated files follow various writing conventions such as capitalized port names and proper code alignment.
	* The id_pkg.vhdl is a package file that is shared between all VHDL files generated by DFiant and  contains common conversion functions that may be required. Additionally it may contain other definitions like enumeration types.

---

## Hierarchy and Connection Example

![idtop](idtop.png)

=== "IDTop.scala"

    ``` scala
    --8<-- "examples/first-look/src/main/scala/IDTop.scala"
    ```

=== "IDTop.vhdl"

    ``` vhdl
    --8<-- "examples/first-look/src/test/resources/idTop/vhdl2008/IDTop.vhdl"
    ```

=== "IDTop.v"

    ``` verilog
    --8<-- "examples/first-look/src/test/resources/idTop/verilog2001/IDTop.v"
    ```

---

## Finite Step (State) Machine (FSM) Example

=== "SeqDet.scala"

    ``` scala
    --8<-- "examples/first-look/src/main/scala/SeqDet.scala"
    ```

=== "SeqDet.vhdl"

    ``` vhdl
    --8<-- "examples/first-look/src/test/resources/seqDet/vhdl2008/SeqDet.vhdl"
    ```

=== "SeqDet.v"

    ``` verilog
    --8<-- "examples/first-look/src/test/resources/seqDet/verilog2001/SeqDet.v"
    ```

---

## Simple Moving Average

In this [simple moving average](https://en.wikipedia.org/wiki/Moving_average) (SMA) example, the signed 16-bit input, $x$ 

### No feedback implementation
$$
y_k=\left(x_k+x_{k-1}+x_{k-2}+x_{k-3}\right)/4
$$

=== "SMA.scala"

    ``` scala
    --8<-- "examples/first-look/src/main/scala/SMA.scala"
    ```

=== "SMA.vhdl"

    ``` vhdl
    --8<-- "examples/first-look/src/test/resources/sma/vhdl2008/SMA.vhdl"
    ```

=== "SMA.v"

    ``` verilog
    --8<-- "examples/first-look/src/test/resources/sma/verilog2001/SMA.v"
    ```

### Feedback implementation

$$\begin{eqnarray} 
a_0 &=& 0 \\
a_k &=& a_{k-1} - x_{k-4}+x_k \\
y_k &=& a_k/4
\end{eqnarray}$$

=== "SMA_FB.scala"

    ``` scala
    --8<-- "examples/first-look/src/main/scala/SMA_FB.scala"
    ```

=== "SMA_FB.vhdl"

    ``` vhdl
    --8<-- "examples/first-look/src/test/resources/sma_fb/vhdl2008/SMA_FB.vhdl"
    ```

=== "SMA_FB.v"

    ``` verilog
    --8<-- "examples/first-look/src/test/resources/sma_fb/verilog2001/SMA_FB.v"
    ```


---


## Looks cool! I wish to know more

