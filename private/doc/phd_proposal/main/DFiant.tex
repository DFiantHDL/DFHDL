
\chapter{HDL Semantics Comparison: DFiant vs. VHDL vs. C++}
\label{chap:DFiant}
\begin{table*}[t]
  \centering
	\captionof{table}{Scheduling Semantics Example Function, $f$: Definition and Implementations}
  \label{tbl:DataSchedDefImpl}
	\begin{threeparttable}
		\setlength\tabcolsep{2pt}
    \scriptsize
		\begin{tabular}{|c|c|c|c|c|}
			\hline 
			\textbf{Formal Definition} & \textbf{Functional Drawing} & \textbf{C++ Impl.}\tnote{†} & \textbf{VHDL Impl.\tnote{‡}} & \textbf{DFiant Impl.} \\ 
			\hline
			\begin{minipage}[b]{0.23\textwidth}
				{\fontsize{7}{8}\selectfont
					\begin{equation}    
					\nonumber
					\begin{aligned}
					&f:(i_{n})_{n\in \mathbb{N}}\rightarrow \\
          &\quad(a_n,b_n,c_n,d_n)_{n\in \mathbb{N}}\\ 
					&\triangleq\left\{
					\begin{split}
					a_k & = i_k + 5 \\
					b_k & = a_k * 3 \\
					c_k & = a_k + b_k \\
					d_k & = i_k - 1 \\
					\end{split}\right.k\geq 0 \\
					\end{aligned}
					\end{equation}
				}
			\end{minipage}
			&
			\begin{minipage}[b][3.1cm][c]{0.19\textwidth}
				\includegraphics[width=\textwidth]{graphics/fFuncDraw.pdf}
			\end{minipage}%
			&
			\begin{minipage}[b]{0.14\linewidth}
        \begin{minted}[autogobble,tabsize=2,fontsize=\fontsize{7}{8}\selectfont]{c}
          void f(int i,
            &a,&b,&c,&d){ 
            
            
            a = i + 5;
            b = a * 3;
            
            c = a + b;
            d = i - 1;
            
          }
				\end{minted}
			\end{minipage}
			&
			\begin{minipage}[b]{0.19\textwidth}
        \begin{minted}[autogobble,tabsize=2,fontsize=\fontsize{7}{8}\selectfont]{vhdl}
        f : process(clk)
        begin 
          if rising_edge(clk)
          begin
            a <= i + 5;
            b <= a * 3;
            â <= a;--cyc dly
            c <= â + b;
            d <= i - 1;
          end; 
        end process;
				\end{minted}
			\end{minipage}
			&
			\begin{minipage}[b]{0.20\textwidth}
        \begin{minted}[autogobble,tabsize=2,fontsize=\fontsize{7}{8}\selectfont]{scala}
        def f(i : DFSInt[32])= 
        {
        
          
          val a = i + 5
          val b = a * 3
          
          val c = a + b
          val d = i - 1
          (a,b,c,d) //tuple of
        }           //four
        \end{minted}
			\end{minipage}
			\\
			\hline
		\end{tabular}
		\begin{tablenotes}
			\item [†] Some type annotations were removed for brevity.
			\item [‡] \code{â} represents a clock cycle delay of \code{a}.
		\end{tablenotes}
	\end{threeparttable}
\end{table*}%

\section{Concurrency and Data Scheduling Abstractions}
\label{sec:concurrency_abstractions}

Concurrency and data scheduling abstractions rely heavily on language semantics. In this section, we explore semantics of three distinctively different languages: C++, VHDL, and DFiant. 

Consider the function $f$ and its implementations, as detailed in Table \ref{tbl:DataSchedDefImpl}. Despite similar code appearance, the semantics are very different, as depicted in Fig. \ref{fig:DataSchedGraph}. The following subsections qualify these semantics.


\subsection{C++ Semantics}
Sequential programming models, such as C++, do not have concurrent semantics. Data scheduling order is set by \textit{code statement order}, and cannot be pipelined\footnote{We only observe language semantics. Out-of-order or multi-processor executions may still apply.}. HLS utilities extends these languages with $pragma$ directives that change semantics. We observe the C++ $f$ implementation as follows:

\begin{figure}[t]
	\centering
	\includegraphics[width=0.6\textwidth]{graphics/DataScheduling.pdf}
	\captionof{figure}{$f$ data scheduling semantics in C++, VHDL, and DFiant}
	\label{fig:DataSchedGraph}
\end{figure}

\begin{enumerate}
	\item All statements are variable assignments.
	\item $d$ is independent of $a$, $b$, and $c$, but cannot be scheduled concurrently. Additionally, $a$ cannot be safely read until $f$ ends. Proper pragmas allow dataflow analysis and function inlining to overcome these limitations.
	\item Time between/of the data operations is unconstrained. The code does not restrict the functional requirement and will maintain correctness for every hardware synthesis fitting its semantics. 
\end{enumerate}  

\subsection{VHDL Semantics}
The RTL programming model is concurrent. Data scheduling is manual and clock-bound, while the order is set by the \textit{assignment cycle-time}. VHDL process semantics are different for \textit{signals} and \textit{variables}: signals are updated when the process ends, while variables are updated instantly. When embedded in a signal edge-detection conditional construct, both signals and variables can be interpreted as registers, depending on the context. We observe the VHDL $f$ implementation as follows:

\begin{enumerate}
	\item All statements are synchronous signal assignments with an explicit single-clock dependency. Clocked $f$ imposes time restrictions to $f$. Although this implementation does not contradict the formal definition of $f$, its correctness is guaranteed solely under these restrictions.
	\item A latency balancing register added to maintain correctness of the $c$ assignment pipeline\footnote{We can use VHDL variable to avoid latency balancing, by forming a combinational circuit.}. 
	\item Data is scheduled for every clock cycle, thus creating a pipeline. Each output signal is valid at a different time. Invalid outputs may be accessed, since VHDL has no implicit $guard$ semantics. More hardware is required to match the output cycle-latencies, and implement explicit guards.
	\item The implementation is very fragile and has limited reusability. Foremost, VHDL process construct alone is not reusable, and requires an \textit{entity-architecture} encapsulation for structural instantiation. Additionally, $f$ is tightly-coupled to $clk$ timing and logic propagation delay. The slightest change in requirements or target device can lead to a painful redesign. 
\end{enumerate}

\subsection{DFiant Semantics}
DFiant has a dataflow programming model. Data scheduling order, or \textit{token-flow}, is set by the \textit{data dependency}. Essentially, the DFiant semantics schedules all independent dataflow expressions concurrently, while dependent operations are synthesized into a guarded FIFO-styled pipeline. Dataflow branches are implicitly forked and joined. Unused nodes, semantically, always consume tokens, and are discarded during compilation. We observe the DFiant $f$ implementation as follows:

\begin{enumerate}
	\item All expressions are dataflow variable declarations.
	\item Concurrency is implicit, and $f$ is coded intuitively, in a sequential manner, since dataflow dependency is oblivious to statement order. 
	\item All scheduling is implicitly guarded by its dependencies. For example, $a$ is forked into both $b$ and $c$ operations, while $c$ joins branches from $a$ and $b$.
	It is impossible to read an invalid result or an old result (without extending semantics further).
	\item DFiant semantics are intuitive: data is consumed only when it is ready and can be accepted by all receiving nodes, while back-pressure prevents data loss. 
\end{enumerate} 


\subsection{Semantics Comparison}
Comparing DFiant and VHDL, it is evident that DFiant is less verbose and has better semantics for code reuse. The given VHDL implementation is a private case for DFiant, since it is only one of many possible solutions, while DFiant relies on its compiler to generate hardware in respect to design constraints. DFiant prevents $f$ users from reading invalid values, while in VHDL it must be programmed explicitly. Bluespec and Chisel have similar semantics to VHDL, thus suffer from related limitations (e.g., explicit pipelining). Fortunately, they both can provide guarded types that prevent invalid data use.

Comparing DFiant and C++, we observe that C++ HLS tools rely on code analysis and pragma directives to change the semantics of their sequential code, while DFiant has its own dataflow type system that guarantees its seamless concurrent semantics. Consequently, C++ HLS tools limit language constructs and hierarchies which are not supported by the analysis algorithms (e.g., recursion), in contrary to DFiant which supports all finite Scala constructs (e.g., finite generation loops and recursions). 
%We believe that constraint directives should not change semantics but refine them.

Contrarily, tandem operations are described more naturally in C++, and loops are utilized to describe repetitive dependent tasks. With proper pragmas, C++ loop iterations can run concurrently, but since they can also run sequentially, loops, and nested loops especially, may be semantically confusing. For this reason, DFiant does not support loops, same as VHDL (hardware generation loops are supported), and opts for state machine semantics to describe sequential operations. %We cover state in the next section. 
%We further compare DFiant against other HLS tools and languages in Section \ref{sec:related_work}. 

