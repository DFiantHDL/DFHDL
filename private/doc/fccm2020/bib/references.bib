@misc{samsoniuk2019riscv,
	author = {Samsoniuk, Marcelo},
	publisher = {GitHub},
	title = {{DarkRISCV: Opensource RISC-V implemented from scratch in one night!}},
	url = {https://github.com/darklife/darkriscv},
	year = {2019}
}

@misc{fibgenvhdl,
  publisher = {Example Problems},
  title = {{VHSIC hardware description language}},
  url = {http://www.exampleproblems.com/wiki/index.php/VHSIC_hardware_description_language},
  year = {2019}
}

@misc{seqdetvhdl,
  publisher = {FPGA4Student},
  title = {{Full VHDL code for Moore FSM Sequence Detector}},
  url = {https://www.fpga4student.com/2017/09/vhdl-code-for-moore-fsm-sequence-detector.html},
  year = {2017},
  month = {September}
}


@book{pedroni2008digital,
	title={Generic Priority Encoder from Digital electronics and design with VHDL},
	author={Pedroni, Volnei A},
	year={2008},
	publisher={Morgan Kaufmann}
}

@misc{drange2016crc,
	author = {Drange, Geir},
	publisher = {OpenCores},
	title = {{Ultimate CRC}},
	url = {https://opencores.org/projects/ultimate_crc},
	year = {2016},
	month = {January}
}


@misc{bitsortvhdl,
	publisher = {VLSICoding},
	title = {{VHDL Code for Bitonic Sorter}},
	url = {https://vlsicoding.blogspot.com/2016/01/vhdl-code-for-bitonic-sorter.html},
	year = {2016}
	month = {January}
}

@article{Lahti2019,
	author = {Lahti, Sakari and Sjovall, Panu and Vanne, Jarno and Hamalainen, Timo D.},
	doi = {10.1109/TCAD.2018.2834439},
	issn = {02780070},
	journal = TCADICS,
	month = {may},
	number = {5},
	pages = {898--911},
	title = {{Are We There Yet? A Study on the State of High-Level Synthesis}},
	volume = {38},
	year = {2019}
}


@article{gurd1985manchester,
	title={The Manchester prototype dataflow computer},
	author={Gurd, John R. and Kirkham, Chris C. and Watson, Ian},
	journal={Communications of the ACM},
	volume={28},
	number={1},
	pages={34--52},
	year={1985},
	publisher={Citeseer}
}

@incollection{arvind1992id,
	title={Id: A language with implicit parallelism},
	author={Arvind, Rishiyur S Nikhil},
	booktitle={A Comparative Study of Parallel Programming Languages},
	pages={169--215},
	year={1992},
	publisher={Elsevier}
}

@inproceedings{serot2011implementing,
	title={Implementing stream-processing applications on fpgas: A dsl-based approach},
	author={Serot, Jocelyn and Berry, Francois and Ahmed, Sameer},
	booktitle=FPGA,
	year={2011},
	organization={IEEE}
}

@article{synphony2015,
	author = {Microsemi},
	title = {{Synphony Model Compiler ME}},
	year = {2015}
}


@inproceedings{jiang2018mamba,
	author={Jiang, Shunning and Ilbeyi, Berkin and Batten, Christopher},
	booktitle = DAC,
	title={Mamba: closing the performance gap in productive hardware development frameworks},
	year = {2018}
}

@article{bhattacharyya2008opendf,
  title={OpenDF: a dataflow toolset for reconfigurable hardware and multicore systems},
  author={Bhattacharyya, Shuvra S and Brebner, Gordon and Janneck, J{\"o}rn W and Eker, Johan and Von Platen, Carl and Mattavelli, Marco and Raulet, Micka{\"e}l},
  journal=CAN,
  volume={36},
  number={5},
  pages={29--35},
  year={2008},
  publisher={ACM}
}

@techreport{eker2003cal,
  title={CAL language report},
  author={Eker, Johan and Janneck, Jorn},
  year={2003},
  institution={Tech. Rep. ERL Technical Memo UCB/ERL}
}

@book{muller2009handbook,
  title={Handbook of floating-point arithmetic},
  author={Muller, Jean-Michel and Brisebarre, Nicolas and De Dinechin, Florent and Jeannerod, Claude-Pierre and Lefevre, Vincent and Melquiond, Guillaume and Revol, Nathalie and Stehl{\'e}, Damien and Torres, Serge},
  year={2009},
  publisher={Springer Science \& Business Media}
}


@MastersThesis{Port2015,
author = {Port, Oron},
title = {{CAFEO: A Dataflow, Device-agnostic, Synthesizable Hardware Description Language}},
url = {http://library.technion.ac.il/thesis/ele/2619627.pdf},
year = {2015}
}
@inproceedings{Saifhashemi2003a,
address = {New York, New York, USA},
author = {Saifhashemi, Arash and Pedram, Hossein},
booktitle = {Proceedings of the 40th conference on Design automation  - DAC '03},
doi = {10.1145/775832.775917},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Saifhashemi, Pedram - 2003 - Verilog HDL, powered by PLI.pdf:pdf},
isbn = {1581136889},
keywords = {CHP,CSP,PLI,asynchronous circuits,channel,verilog},
pages = {330},
publisher = {ACM Press},
title = {{Verilog HDL, powered by PLI}},
url = {http://portal.acm.org/citation.cfm?doid=775832.775917},
year = {2003}
}
@inproceedings{Liu2017,
author = {Liu, Yanqiang and Li, Yao and Xiong, Weilun and Lai, Meng and Chen, Cheng and Qi, Zhengwei and Guan, Haibing},
booktitle = FPGA,
isbn = {9781450343541},
keywords = {DSL,FPGA,veriscala},
title = {{Scala Based FPGA Design Flow (Abstract Only)}},
year = {2017}
}
@inproceedings{Zhao2017,
author = {Zhao, Zhipeng},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Zhao, Hoe - 2017 - Using Vivado-HLS for Structural Design a NoC Case Study.pdf:pdf;:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Zhao - 2017 - Using Vivado-HLS for Structural Design a NoC Case Study.pdf:pdf},
booktitle = FPGA,
title = {{Using Vivado-HLS for Structural Design : a NoC Case Study}},
year = {2017}
}
@misc{Charles2016,
author = {Charles, Papon},
publisher = {GitHub},
title = {{SpinalHDL}},
url = {http://spinalhdl.github.io/SpinalDoc},
year = {2016}
}
@article{Vivado2012,
abstract = {How to use constraints with Vivado},
author = {Xilinx},
title = {{Vivado High Level Synthesis User Guide}},
year = {2015}
}
@misc{TypeLevelScala,
author = {Osheim, Erik and Leontiev, George and Pretty, Jon and Hupel,Lars and O'Connor,Mike and Sabin,Miles and Switzer,Tom},
publisher = {GitHub},
title = {{Typelevel Scala}},
url = {https://github.com/typelevel/scala},
year = {2017}
}
@misc{singleton-ops,
author = {
S. Thomas, Frank and
Pocock, Matthew and
Aoyama, Naoki and
Port, Oron
},
publisher = {GitHub},
title = {{singleton-ops library}},
url = {https://github.com/fthomas/singleton-ops},
year = {2017}
}

@inproceedings{Venkataramani2015a,
abstract = {—Recent years have witnessed significant interest in the area of approximate computing. Much of this interest stems from the quest for new sources of computing efficiency in the face of diminishing benefits from technology scaling. We argue that trends in computing workloads will greatly increase the opportunities for approximate computing, describe the vision and key principles that have guided our work in this area, and outline a range of approximate computing techniques that we have developed at all layers of the computing stack, spanning circuits, architecture, and software.},
author = {Venkataramani, Swagath and Chakradhar, Srimat T and Roy, Kaushik and Raghunathan, Anand},
booktitle = {Design, Automation Test in Europe Conference Exhibition (DATE), 2015},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Venkataramani et al. - 2015 - Computing approximately, and efficiently.pdf:pdf},
isbn = {9783981537048},
issn = {15301591},
keywords = {Algorithm design and analysis,Approximation algorithms,Approximation methods,Computer architecture,Hardware,Resilience,Software,approximate computing techniques,computing efficiency,computing stack,computing workloads,inference mechanisms,power aware computing,spanning circuits,technology scaling},
pages = {748--751},
title = {{Computing approximately, and efficiently}},
url = {http://ieeexplore.ieee.org/xpl/freeabs%7B_%7Dall.jsp?arnumber=7092486},
year = {2015}
}
@inproceedings{Yazdanbakhsh2015,
abstract = {Relaxing the traditional abstraction of “near- perfect” accuracy in hardware design can lead to significant gains in energy efficiency, area, and performance. To exploit this opportunity, there is a need for design abstractions that can systematically incorporate approximation in hardware design.We introduce Axilog, a set of language annotations, that provides the necessary syntax and semantics for approximate hardware design and reuse in Verilog. Axilog enables the designer to relax the accu- racy requirements in certain parts of the design, while keeping the critical parts strictly precise. Axilog is coupled with a Relaxability Inference Analysis that automatically infers the relaxable gates and connections from the designer's annotations. The analysis provides formal safety guarantees that approximation will only affect the parts that the designer intended to approximate, referred to as relaxable elements. Finally, the paper describes a synthesis flow that approximates only the relaxable elements. Axilog enables applying approximation in the synthesis process while abstracting away the details of approximate synthesis from the designer. We evaluate Axilog, its analysis, and the synthesis flow using a diverse set of benchmark designs. The results show that the intuitive nature of the language extensions coupled with the automated analysis enables safe approximation of designs even with thousands of lines of code. Applying our approximate synthesis flow to these designs yields, on average, 54% energy savings and 1.9× area reduction with 10% output quality loss.},
author = {Yazdanbakhsh, Amir and Mahajan, Divya and Thwaites, Bradley and Park, Jongse and Nagendrakumar, Anandhavel and Sethuraman, Sindhuja and Ramkrishnan, Kartik and Ravindran, Nishanthi and Jariwala, Rudra and Rahimi, Abbas and Esmaeilzadeh, Hadi and Bazargan, Kia},
booktitle = {Design, Automation & Test in Europe Conference & Exhibition (DATE), 2015},
doi = {10.7873/DATE.2015.0513},
isbn = {9783981537048},
issn = {15301591},
number = {2},
title = {{Axilog: Language Support for Approximate Hardware Design}},
year = {2015}
}
@article{muller1957theory,
  title={A theory of asynchronous circuits II},
  author={Muller, DE and Bartky, WS},
  journal={Digital Computer Laboratory},
  volume={78},
  year={1957}
}
@book{Shyamasundar2009,
author = {Shyamasundar, R K and Ramesh, S},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Shyamasundar, Ramesh - 2009 - Real Time Programming Languages, Specification and Verification.pdf:pdf},
isbn = {9789812814029},
keywords = {Real-time programming.},
title = {{Real Time Programming : Languages, Specification and Verification}},
url = {https://www.google.com/books?hl=en&lr=&id=yTpqDQAAQBAJ&oi=fnd&pg=PR5&dq=real+time+programming+languages+specification+verification&ots=g4URG53QLc&sig=G-4n2khxt9VBkFXobkq9v6SNBIM http://site.ebrary.com/lib/staffordshire/docDetail.action?docID=10422187},
year = {2009}
}
@inproceedings{Chippa2013,
abstract = {Computing today is largely not about calculating a precise numerical end result. Instead, computing platforms are increasingly used to execute applications (such as search, analytics, sensor data processing, recognition, mining, and synthesis) for which &#x201C;correctness&#x201D; is defined as producing results that are good enough, or of sufficient quality. These applications are often intrinsically resilient to a large fraction of their computations being executed in an imprecise or approximate manner. However, the design of computing platforms continues to be guided by the principle that every computation must be executed with the same strict notion of correctness. Approximate computing departs from this long-held dogma, and exploits intrinsic application resilience to improve the efficiency (energy or speed) of computing platforms. We describe an integrated approach to approximate computing in hardware that consists of three key components. First, we present an automatic resilience characterization framework that allows the designer to quantitatively evaluate the intrinsic resilience of an application, and to quickly assess the potential of various approximate computing techniques. We then describe scalable effort hardware, an approach to approximate computing wherein hardware is designed with various scaling mechanisms, or knobs that modulate the effort expended towards correctly performing an application's computations. Scaling mechanisms are identified at the algorithm, architecture, and circuit levels, and embodied in the hardware to provide a rich trade-off between computational accuracy and energy. Finally, dynamic effort scaling is proposed as a feedback control approach to modulate the scaling mechanisms at runtime in response to varying application requirements and data characteristics. To demonstrate the proposed concepts, we have designed and fabricated an energy-efficient Recognition and Mining (RM) processor in the TSMC 65nm process technology.- Our measurement results demonstrate that approximate computing leads to 2-20X energy savings with minimal impact on output quality across a range of applications.},
author = {Chippa, Vinay K. and Venkataramani, Swagath and Chakradhar, Srimat T. and Roy, Kaushik and Raghunathan, Anand},
booktitle = {Conference Record - Asilomar Conference on Signals, Systems and Computers},
doi = {10.1109/ACSSC.2013.6810241},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Chippa et al. - 2013 - Approximate computing An integrated hardware approach.pdf:pdf},
isbn = {9781479923908},
issn = {10586393},
pages = {111--117},
title = {{Approximate computing: An integrated hardware approach}},
year = {2013}
}
@article{Trimberger2015,
abstract = {Since their introduction, field programmable gate arrays (FPGAs) have grown in capacity by more than a factor of 10 thinspace000 and in performance by a factor of 100. Cost and energy per operation have both decreased by more than a factor of 1000. These advances have been fueled by process technology scaling, but the FPGA story is much more complex than simple technology scaling. Quantitative effects of Moore's Law have driven qualitative changes in FPGA architecture, applications and tools. As a consequence, FPGAs have passed through several distinct phases of development. These phases, termed “Ages” in this paper, are The Age of Invention, The Age of Expansion and The Age of Accumulation. This paper summarizes each and discusses their driving pressures and fundamental characteristics. The paper concludes with a vision of the upcoming Age of FPGAs.},
author = {Trimberger, Stephen M.},
doi = {10.1109/JPROC.2015.2392104},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Trimberger - 2015 - Three ages of FPGAs A retrospective on the first thirty years of FPGA technology.pdf:pdf},
isbn = {0018-9219 VO - 103},
issn = {00189219},
journal = {Proceedings of the IEEE},
keywords = {Application-specific integrated circuit (ASIC),Moore's Law,commercialization,economies of scale,field-programmable gate array (FPGA),industrial economics,programmable logic},
number = {3},
pages = {318--331},
title = {{Three ages of FPGAs: A retrospective on the first thirty years of FPGA technology}},
volume = {103},
year = {2015}
}
@article{pub2001197,
author = {NIST},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/NIST - 2001 - Advanced Encryption Standard (Aes).pdf:pdf},
journal = {Federal Information Processing Standards Publication},
number = {441},
title = {{Advanced Encryption Standard (AES)}},
volume = {197},
year = {2001}
}
@article{Feist2012,
abstract = {UG940},
author = {Feist, T},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Feist - 2012 - Vivado design suite.pdf:pdf},
journal = {White Paper},
keywords = {"WP416,IP,design,flow,integration,synthesis},
pages = {1--14},
title = {{Vivado Design Suite}},
url = {https://pdfs.semanticscholar.org/8c29/a2d5f9b64922a875a38f0d4705fb9f7a7b64.pdf},
volume = {416},
year = {2012}
}
@inproceedings{Meurer2014,
abstract = {The Advanced Encryption Standard (AES) is the main algorithm used to ensure security and privacy in several different applications ranging from massive data servers to small low-power embedded systems. Such embedded systems often rely on dedicated hardware implementations of AES in order to meet tight power budgets. In this scenario, C/C++ High-Level Synthesis (HLS) solutions are gaining acceptance as traditional hardware design methodologies can no longer match the strict time-to-market requirements of current applications. In this paper, we describe a C++ implementation of the AES algorithms and explore different hardware micro-architectures by using HLS solutions. We focus on describing the process of obtaining an efficient synthesizable C++ description form plain software code. {\textcopyright} 2013 IEEE.},
author = {Meurer, Rodrigo Schmitt and Muck, Tiago Rogerio and Frohlich, Antonio Augusto},
booktitle = {Brazilian Symposium on Computing System Engineering, SBESC},
doi = {10.1109/SBESC.2013.36},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Meurer, Muck, Frohlich - 2013 - An Implementation of the AES cipher using HLS.pdf:pdf},
isbn = {9781479938902},
issn = {23247894},
keywords = {AES,Decryption,Encryption,FPGA,HLS,tools},
pages = {113--118},
title = {{An implementation of the AES cipher using HLS}},
url = {http://ieeexplore.ieee.org/abstract/document/6825352/},
year = {2014}
}
@article{Pilaszy2013,
author = {Pil{\'{a}}szy, G and R{\'{a}}cz, G and Arat{\'{o}}, P},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Pil{\'{a}}szy, R{\'{a}}cz, Arat{\'{o}} - 2013 - Communication Time Estimation in High Level Synthesis.pdf:pdf},
journal = {Periodica Polytechnica. Electrical},
title = {{Communication Time Estimation in High Level Synthesis}},
url = {http://search.proquest.com/openview/c220ef04e9a65e22c43911c2fe902618/1?pq-origsite=gscholar&cbl=2034351},
year = {2013}
}
@inproceedings{Goossens1995,
author = {Goossens, Kees G. W.},
booktitle = {CHARME '95: Proceedings of the IFIP WG 10.5 Advanced Research Working Conference on Correct Hardware Design and Verification Methods},
doi = {10.1007/3-540-60385-9_19},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Goossens - 1995 - Reasoning about VHDL using operational and observational semantics.pdf:pdf},
isbn = {3-540-60385-9},
issn = {16113349},
pages = {311--327},
title = {{Reasoning about VHDL using operational and observational semantics}},
url = {http://link.springer.com/10.1007/3-540-60385-9_19},
year = {1995}
}
@inproceedings{Bailey2015,
abstract = {High level synthesis (HLS) tools can provide significant benefits for implementing image processing algorithms on FPGAs. The higher level (usually C based) representation enables algorithms to be expressed more easily, significantly reducing development times. The higher level also makes design space exploration easier, making it easier to optimise the trade-off between resources and processing speed. However, one danger of using HLS is simply porting existing image processing algorithms onto an FPGA platform. Often, better parallel or pipelined algorithms may be may be designed which are better suited to the FPGA architecture. Examples will be given from image filtering, to connected components analysis, to efficient memory management for 2-D frequency domain based filtering.},
address = {New York, New York, USA},
author = {Bailey, Donald G.},
booktitle = {Proceedings of the 9th International Conference on Distributed Smart Camera - ICDSC '15},
doi = {10.1145/2789116.2789145},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Bailey - 2015 - The advantages and limitations of high level synthesis for FPGA based image processing.pdf:pdf},
isbn = {9781450336819},
keywords = {architecture exploration,design space exploration,rapid development,smart camera},
pages = {134--139},
publisher = {ACM Press},
title = {{The advantages and limitations of high level synthesis for FPGA based image processing}},
url = {http://dl.acm.org/citation.cfm?doid=2789116.2789145},
year = {2015}
}
@article{Zhai2015,
author = {Zhai, Kuangya},
doi = {10.1109/CODESISSS.2015.7331371},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Zhai - 2015 - Hardware Synthesis from a Stream-Processing Functional Language.pdf:pdf},
isbn = {9781467383219},
issn = {1476-2986},
journal = {Codes + Isss},
keywords = {functional hardware,high-level synthesis,recursion},
month = {oct},
number = {October},
pages = {83--93},
publisher = {IEEE},
title = {{Hardware Synthesis from a Stream-Processing Functional Language}},
url = {http://ieeexplore.ieee.org/document/7331371/ http://arbitrary.name/papers/},
year = {2015}
}
@article{Cunningham2011,
abstract = {GPU architectures have emerged as a viable way of considerably improving performance for appropriate applications. Programfrag- ments (kernels) appropriate forGPUexecution can be implemented in CUDA or OpenCL and glued into an application via an API. While there is plenty of evidence of performance improvements using this approach, there are many issues with productivity. Pro- grammers must understand an additional programming model and API to program the accelerator; concurrency and synchronization in this programming model is typically expressed differently from the programming model for the host. On top of this, the languages used to write kernels are very low level and thus prone to the kinds of errors that one does not encounter in higher level languages. Pro- grammers must explicitly deal with moving data back-and-forth between the host and the accelerator. These problems are com- pounded when the user code must be run across a cluster of ac- celerated nodes. Now the host programming model must further be extended with constructs to deal with scale-out and remote ac- celerators. We believe there is a critical need for a single source programming model that can be used to write clean, efficient code for heterogeneous, multi-core and scale-out architectures. The APGAS programming model has been developed for such architectures over the past six years. APGAS is based on four fundamental (and architecture-independent) notions: locality, asyn- chrony, conditional atomicity and order. X10 is an instantiation of the APGAS programming model on top of a base sequential lan- guage with Java-style productivity. Earlier work has shown that X10 can be used to write clean and efficient code for homoge- neous multi-cores, SMPs, Cell-accelerated nodes, and clusters of such nodes. In this paperwe show howX10 programmers canwrite code that can be compiled and run on GPUs. GPU programming idioms such as threads, blocks, barriers, constant memory, local registers, shared memory variables, etc. can be directly expressed in X10, and do not require new language extensions. We present the design of an extension of the X10-to-C++ compiler which rec- ognizes such idioms and produces CUDA kernel code. We show several benchmarks written in this style. The performance of these kernels is within 80% of hand-written CUDA kernels We believe these results establish X10 as a single-source pro- gramming language in which clean, efficient programs can be writ- ten for GPU-accelerated clusters.},
author = {Cunningham, Dave and Bordawekar, Rajesh and Saraswat, Vijay},
doi = {10.1145/2212736.2212744},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Cunningham, Bordawekar, Saraswat - 2011 - GPU programming in a high level language.pdf:pdf},
isbn = {9781450307703},
journal = {Proceedings of the 2011 ACM SIGPLAN X10 Workshop on - X10 '11},
keywords = {cuda,distributed,gpu,heterogeneous,high-level,java,mul-,parallel,ticore,x10},
pages = {1--10},
title = {{GPU programming in a high level language}},
url = {http://dl.acm.org/citation.cfm?doid=2212736.2212744},
year = {2011}
}
@inproceedings{George2014,
abstract = {Field Programmable Gate Arrays (FPGAs) are very versatile devices, but their complicated programming model has stymied their widespread usage. While modern High-Level Synthesis (HLS) tools provide better programming models, the interface they offer is still too low-level. In order to produce good quality hardware designs with these tools, the users are forced to manually perform optimizations that demand detailed knowl- edge of both the application and the implementation platform. Additionally, many HLS tools only generate isolated hardware modules that the user still needs to integrate into a system design before generating the FPGA bitstream. These problems make HLS tools difficult to use for application developers who have little hardware design knowledge. To address these problems, we propose an automated methodology to generate FPGA bitstreams from high-level programs written in Domain-Specific Languages (DSLs). We leverage the domain-knowledge conveyed by the DSL and its domain-specific semantics to extract application parallelism, perform optimizations and also identify a suitable system-architecture for the implementation, thereby, relieving the user from most of the hardware-level details. We demonstrate the high productivity and high design quality this approach offers by automatically generating hardware systems from applications written in OptiML, a machine-learning DSL. To evaluate our methodology, we use four OptiML applications and show that we can easily generate different solutions which achieve different trade-offs between performance and area. More importantly, the results reveal that our generated hardware achieves much better performance compared to the one obtained from using the HLS tool without platform-specific optimizations.},
author = {George, Nithin and Lee, Hyoukjoong and Novo, David and Rompf, Tiark and Brown, Kevin J. and Sujeeth, Arvind K. and Odersky, Martin and Olukotun, Kunle and Ienne, Paolo},
booktitle = {Conference Digest - 24th International Conference on Field Programmable Logic and Applications, FPL 2014},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/George et al. - 2014 - Hardware system synthesis from Domain-Specific Languages.pdf:pdf},
publisher = {Institute of Electrical and Electronics Engineers Inc.},
title = {{Hardware system synthesis from Domain-Specific Languages}},
year = {2014}
}
@article{Moreau2015,
author = {Moreau, Thierry and Wyse, Mark},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Moreau, Wyse - 2015 - SNNAP Approximate Computing on Programmable SoCs via Neural Acceleration.pdf:pdf},
isbn = {9781479989300},
journal = {2015 IEEE 21st},
title = {{SNNAP : Approximate Computing on Programmable SoCs via Neural Acceleration}},
url = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=7056066},
year = {2015}
}
@phdthesis{Sampson2015,
author = {Sampson, Adrian},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Ceze - 2015 - HARDWARE AND SOFTWARE FOR APPROXIMATE COMPUTING adrian sampson.pdf:pdf},
title = {{Hardware and Software for Approximate Computing}},
url = {http://homes.cs.washington.edu/$\sim$djg/theses/sampson_thesis.pdf},
year = {2015}
}
@article{Shacham2010,
abstract = {Because of technology scaling, power dissipation is today's major performance limiter. Moreover, the traditional way to achieve power efficiency, application-specific designs, is prohibitively expensive. These power and cost issues necessitate rethinking digital design. To reduce design costs, we need to stop building chip instances, and start making chip generators instead. Domain-specific chip generators are templates that codify designer knowledge and design trade-offs to create different application-optimized chips.},
author = {Shacham, Ofer and Azizi, Omid and Wachs, Megan and Qadeer, Wajahat and Asgar, Zain and Kelley, Kyle and Stevenson, John P. and Richardson, Stephen and Horowitz, Mark and Lee, Benjamin and Solomatnikov, Alex and Firoozshahian, Amin},
doi = {10.1109/MM.2010.81},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Shacham et al. - 2010 - Rethinking digital design Why design must change.pdf:pdf},
isbn = {978-1-4244-7054-9},
issn = {02721732},
journal = {IEEE Micro},
keywords = {ASIC,CMOS,Dennard scaling,H.264,Moore's Law,RTL verification,chip generator,chip multiprocessor,design methodology,hardware generation,hardware optimization,power efficiency,system on chip},
month = {nov},
number = {6},
pages = {9--24},
title = {{Rethinking digital design: Why design must change}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=5567087},
volume = {30},
year = {2010}
}
@misc{Milner1986,
abstract = {An abstract is not available.},
author = {Milner, Robin},
booktitle = {LFCS Report Series},
doi = {10.1007/3-540-15670-4_10},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Milner - 1986 - A calculus of communicating systems.pdf:pdf},
isbn = {978-3-540-15670-3},
issn = {0302-9743},
number = {7},
pages = {1--171},
pmid = {186},
title = {{A calculus of communicating systems}},
url = {https://dialnet.unirioja.es/servlet/libro?codigo=369600},
volume = {86},
year = {1986}
}
@article{Whiting1994,
abstract = {Data-flow refers both to a language-level paradigm of computation and to a family of processor architectures based on this paradigm. This article elaborates data-flow language issues and the evolution of data-flow languages. In considering limits to the expressive power of these languages, underlying architectural issues are of necessity discussed. Although the article attempts to present a complete history of data-flow languages, it concentrates on those languages that specifically belong to this class and have been implemented for a data-flow machine. In many cases, the distinctions between issues of language semantics and machine architecture are unclear. Usually we have found that this reflects the evolution of data-flow, and the close association between language and architecture development. In some sections of the article, it may appear that there is an imbalance in the amount of detail presented when compared with other sections. This imbalance is proportional to the publications and the amount of information readily available for the topics.},
author = {Whiting, Paul G. and Pascoe, Robert S V},
doi = {10.1109/85.329757},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Whiting, Pascoe - 1994 - A History of Data-Flow Languages.pdf:pdf},
issn = {10586180},
journal = {IEEE Annals of the History of Computing},
number = {4},
pages = {38--59},
title = {{A History of Data-Flow Languages}},
volume = {16},
year = {1994}
}
@phdthesis{Thies2009,
abstract = {Streamprograms represent an important class of high-performance computations. Defined by their regular processing of sequences of data, stream programs appear most commonly in the context of audio, video, and digital signal processing, though also in networking, encryption, and other areas. Stream programs can be naturally represented as a graph of independent actors that communicate explicitly over data channels. In this work we focus on programs where the input and output rates of actors are known at compile time, enabling aggressive transformations by the compiler; this model is known as synchronous dataflow. We develop a new programming language, StreamIt, that empowers both programmers and compilerwriters to leverage the unique properties of the streaming domain. StreamIt offers several new abstractions, including hierarchical single-input single-output streams, composable primitives for data reordering, and a mechanism called teleport messaging that enables precise event han- dling in a distributed environment. We demonstrate the feasibility of developing applications in StreamIt via a detailed characterization of our 34,000-line benchmark suite, which spans from MPEG-2 encoding/decoding to GMTI radar processing. We also present a novel dynamic analysis for migrating legacy C programs into a streaming representation. The central premise of stream programming is that it enables the compiler to perform powerful optimizations. We support this premise by presenting a suite of new transformations. We describe the first translation of streamprograms into the compressed domain, enabling programswritten for uncompressed data formats to automatically operate directly on compressed data formats (based on LZ77). This technique offers a median speedup of 15x on common video editing operations. We also review other optimizations developed in the StreamIt group, including automatic paral- lelization (offering an 11x mean speedup on the 16-core Raw machine), optimization of linear computations (offering a 5.5x average speedup on a Pentium 4), and cache-aware scheduling (of- fering a 3.5x mean speedup on a StrongARM 1100). While these transformations are beyond the reach of compilers for traditional languages such as C, they become tractable given the abundant parallelism and regular communication patterns exposed by the stream programmingmodel.},
author = {Thies, William},
booktitle = {Ph.D. Thesis},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Thies - 2009 - StreamIt Language and Compiler Support for Stream Programs.pdf:pdf},
pages = {1--240},
title = {{[StreamIt] Language and Compiler Support for Stream Programs}},
url = {http://groups.csail.mit.edu/commit/papers/2009/thies-phd-thesis.pdf},
year = {2009}
}
@inproceedings{Caspi1996,
address = {New York, New York, USA},
author = {Caspi, Paul and Pouzet, Marc},
booktitle = {Functional Programming, Int'l Conf. on},
doi = {10.1145/232627.232651},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Caspi, Pouzet - 1996 - Synchronous kahn networks.pdf:pdf},
isbn = {0897917707},
issn = {03621340},
number = {6},
pages = {226--238},
publisher = {ACM Press},
title = {{Synchronous kahn networks}},
url = {http://portal.acm.org/citation.cfm?doid=232627.232651 http://dl.acm.org/citation.cfm?id=232651},
volume = {31},
year = {1996}
}
@incollection{Thuau1991,
author = {Thuau, Ghislaine and Pilaud, Daniel},
doi = {10.1007/978-1-4471-3544-9_17},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Thuau, Pilaud - 1991 - Using the Declarative Language LUSTRE for Circuit Verification.pdf:pdf},
pages = {313--331},
publisher = {Springer London},
title = {{Using the Declarative Language LUSTRE for Circuit Verification}},
url = {http://link.springer.com/10.1007/978-1-4471-3544-9_17},
year = {1991}
}
@article{pouzet2006lucid,
author = {Pouzet, Marc},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Pouzet - 2006 - Lucid synchrone, version 3.pdf:pdf},
journal = {Tutorial and reference manual. Universit{{\'{e}}} Paris-Sud, LRI},
title = {{Lucid synchrone, version 3}},
year = {2006}
}
@book{Kupferman1998,
address = {Berlin, Heidelberg},
author = {Kupferman, Orna and Vardi, Moshe Y.},
booktitle = {COMPOS},
doi = {10.1007/3-540-49213-5},
editor = {de Roever, Willem-Paul and Langmaack, Hans and Pnueli, Amir},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Kupferman, Vardi - 1998 - Compositionality The Significant Difference.pdf:pdf},
isbn = {978-3-540-65493-3},
pages = {381--401},
publisher = {Springer Berlin Heidelberg},
series = {Lecture Notes in Computer Science},
title = {{Compositionality: The Significant Difference}},
url = {http://link.springer.com/10.1007/3-540-49213-5 http://dblp.uni-trier.de/db/conf/compos/compos1997.html#KupfermanV97},
volume = {1536},
year = {1998}
}
@article{Johnston2004,
abstract = {Johnston, W. M., Hanna, J. R. P., & Millar, R. J. (2004). Advances in dataflow programming languages. ACM Computing Surveys, 36(1), 1–34. doi:10.1145/1013208.1013209},
author = {Johnston, Wesley M. and Hanna, J. R. Paul and Millar, Richard J.},
doi = {10.1145/1013208.1013209},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Johnston, Hanna, Millar - 2004 - Advances in dataflow programming languages.pdf:pdf},
isbn = {0360-0300},
issn = {03600300},
journal = {ACM Computing Surveys},
number = {1},
pages = {1--34},
pmid = {14605474},
title = {{Advances in dataflow programming languages}},
url = {http://dl.acm.org/citation.cfm?id=1013209 http://portal.acm.org/citation.cfm?doid=1013208.1013209},
volume = {36},
year = {2004}
}
@inproceedings{Sampson2015a,
abstract = {The age of the air-tight hardware abstraction is over. As the computing ecosystem moves beyond the predictable yearly advances of Moore's Law, appeals to familiarity and backwards compatibility will become less convincing: fundamental shifts in abstraction and design will look more enticing. It is time to embrace hardware–software co-design in earnest, to cooperate between programming languages and architecture to upend legacy constraints on computing. We describe our work on approximate computing, a new avenue spanning the system stack from applications and languages to microarchitectures. We reflect on the challenges and successes of approximation research and, with these lessons in mind, distill opportunities for future hardware–software co-design efforts.},
author = {Sampson, Adrian and Bornholt, James and Ceze, Luis},
booktitle = {Informatics, Leibniz International Proceedings in},
doi = {10.4230/LIPIcs.SNAPL.2015.262},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Sampson, Bornholt, Ceze - 2015 - Hardware-Software Co-Design Not Just a Clich{\'{e}}.pdf:pdf},
isbn = {978-3-939897-80-4},
issn = {1868-8969},
keywords = {approximation,architecture,co-design,verification},
pages = {262--273},
title = {{Hardware-Software Co-Design: Not Just a Clich{\'{e}}}},
url = {http://drops.dagstuhl.de/opus/volltexte/2015/5030/ http://adriansampson.net/media/papers/cliche-snapl2015.pdf},
year = {2015}
}
@inproceedings{Goodman2011a,
author = {Goodman, Daniel and Lujan, Mikel},
booktitle = {Multi-Core and Reconfigurable Super Computing Conference, Bristol},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Goodman, Lujan - 2011 - Scientific GPU Programming with Data-Flow Languages.pdf:pdf},
title = {{Scientific GPU Programming with Data-Flow Languages}},
url = {http://www.cs.man.ac.uk/$\sim$goodmand/papers/Goodman-MRSC.pdf},
year = {2011}
}
@article{Brookes2002,
abstract = {We provide a denotational trace semantics for processes with synchronous communication and a form of weakly fair parallelism.},
author = {Brookes, Stephen},
doi = {10.1007/3-540-45694-5_31},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Brookes - 2002 - Traces, Pomsets, Fairness and Full Abstraction for Processes.pdf:pdf},
isbn = {3540440437},
issn = {03029743},
journal = {Concur},
pages = {466--482},
publisher = {Springer Berlin Heidelberg},
title = {{Traces, Pomsets, Fairness and Full Abstraction for Communicating Processes}},
url = {http://link.springer.com/10.1007/3-540-45694-5_31 http://www.springerlink.com/index/8h1nbe4jenx0hpmy.pdf},
year = {2002}
}
@phdthesis{Schneider1990,
abstract = {Abstract: "This thesis builds upon the mathematical theory for real-time distributed computing developed by Reed and Roscoe. Time- critical process constructors for modelling timeouts, interrupts, and communication constructs, are defined in terms of the primitive operators of Timed Communicating Sequential Processes (TCSP). The work on communication involves the modelling of channels, inputs, outputs, chaining, and a characterisation and analysis of buffers. These tools are applied to the specification, construction, and verification of communication protocols. The methods are generalised to apply to networks. Real-time systems are inherently complex, and this is reflected in the complexity of the verification process. This thesis presents three useful verification methods. The first is a complete compositional proof system for behavioural specifications on TCSP. The second involves the definition of generic specifications on processes, capturing those properties of component processes which combine readily when constructing large networks. Methods of constructing and of identifying processes meeting such specifications are examined, and laws are formulated concerning their interaction. The third approach exploits the mappings between different models within Reed's hierarchy. A notion of timewise refinement is presented which allows simple processes to be refined by the introduction of timing considerations. Properties which are preserved by timewise refinement are important, since there already exist well-established techniques for proving that such properties hold of [sic] processes in models lower in the hierarchy."},
author = {Schneider, Steve and {Oxford University Computing Laboratory Programming Research Group}},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Schneider, Oxford University Computing Laboratory Programming Research Group - 1990 - Correctness and communication in real-time systems.pdf:pdf},
isbn = {0902928635},
keywords = {Electronic data processing Distributed processing.,Real-time data processing.},
pages = {211 p. :},
title = {{Correctness and communication in real-time systems}},
url = {http://ethos.bl.uk/OrderDetails.do?uin=uk.bl.ethos.258152},
year = {1990}
}
@article{Bernardeschi1995,
author = {Bernardeschi, Cinzia and {De Francesco}, Nicoletta and Vaglini, Gigliola},
doi = {10.1007/BF01178383},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Bernardeschi, De Francesco, Vaglini - 1995 - A Petri nets semantics for data flow networks.pdf:pdf},
issn = {00015903},
journal = {Acta Informatica},
month = {apr},
number = {4},
pages = {347--374},
publisher = {Springer-Verlag},
title = {{A Petri nets semantics for data flow networks}},
url = {http://link.springer.com/10.1007/BF01178383},
volume = {32},
year = {1995}
}
@article{Carmona2004,
abstract = {As semiconductor technology strides towards billions of transistors on a single die, problems concerned with deep sub-micron process features and design productivity call for new approaches in the area of behavioural models. This paper focuses on some of recent developments and new opportunities for Petri nets in designing asynchronous circuits such as synthesis of asynchronous control circuits from large Petri nets generated from front-end specifications in hardware description languages. These new methods avoid using full reachability state space for logic synthesis. They include direct mapping of Petri nets to circuits, structural methods with linear programming, and synthesis from unfolding prefixes using SAT solvers.},
author = {Carmona, Josep and Cortadella, Jordi and Khomenko, Victor and Yakovlev, Alex},
doi = {10.1007/3-540-36190-1},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Carmona et al. - 2004 - Synthesis of Asynchronous Hardware from Petri Nets.pdf:pdf},
isbn = {978-3-540-00199-7},
issn = {03029743},
journal = {Lectures on Concurrency and Petri Nets Advances in Petri Nets},
pages = {345--401},
title = {{Synthesis of Asynchronous Hardware from Petri Nets}},
url = {http://link.springer.com/chapter/10.1007/978-3-540-27755-2_9 http://www.springerlink.com/content/r599j3ltjaljt6f8},
year = {2004}
}
@article{Vinter2014,
author = {Vinter, B and Skovhede, K},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Vinter, Skovhede - 2014 - Synchronous message exchange for hardware designs.pdf:pdf},
journal = {Communicating Process Architectures (CPA)},
title = {{Synchronous message exchange for hardware designs}},
url = {https://www.researchgate.net/profile/Kenneth_Skovhede/publication/281279115_Synchronous_Message_Exchange_for_Hardware_Designs/links/55decd8108ae79830bb592be.pdf},
year = {2014}
}
@misc{danial2009cloc,
author = {Danial, Al},
publisher = {GitHub},
title = {{Cloc--count lines of code}},
url = {https://github.com/AlDanial/cloc},
year = {2009}
}
@incollection{Peleska1993,
address = {Boston, MA},
author = {Peleska, Jan},
booktitle = {Formal Techniques in Real-Time and Fault-Tolerant Systems},
doi = {10.1007/978-1-4615-3220-0_7},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Peleska - 1993 - CSP, Formal Software Engineering and the Development of Fault-Tolerant Systems.pdf:pdf},
pages = {167--206},
publisher = {Springer US},
title = {{CSP, Formal Software Engineering and the Development of Fault-Tolerant Systems}},
url = {http://link.springer.com/10.1007/978-1-4615-3220-0_7},
year = {1993}
}
@article{oflynn2014rapid,
author = {O'Flynn, Colin},
file = {:C\:/Users/soronpo/Downloads/article_CC_2_2014.pdf:pdf},
journal = {Circuit Cellar},
pages = {46--53},
title = {{Rapid FPGA Design in C Using High-Level Synthesis}},
number = {283},
year = {2014}
}
@article{Brookes2001,
author = {Brookes, Stephen},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Brookes - 2000 - Deconstructing ccs and csp asynchronous communication, fairness, and full abstraction.pdf:pdf;:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Brookes - 2000 - Deconstructing ccs and csp asynchronous communication, fairness, and full abstraction(2).pdf:pdf},
journal = {MFPS16, April},
pages = {1--34},
title = {{Deconstructing CCS and CSP}},
url = {http://www.cs.cmu.edu/afs/cs.cmu.edu/user/brookes/www/papers/mfps16paper.pdf},
year = {2001}
}
@article{Hidders2008,
abstract = {In this paper we propose DFL-a formal, graphical workflow language for dataflows, i.e., workflows where large amounts of complex data are manipulated, and the structure of the manipulated data is reflected in the structure of the workflow. It is a common extension of (1) Petri nets, which are responsible for the organization of the processing tasks, and (2) nested relational calculus, which is a database query language over complex objects, and is responsible for handling collections of data items (in particular, for iteration) and for the typing system. We demonstrate that dataflows constructed in a hierarchical manner, according to a set of refinement rules we propose, are semi-sound, i.e., initiated with a single token (which may represent a complex scientific data collection) in the input node, terminate with a single token in the output node (which represents the output data collection). In particular they never leave any "debris data" behind and an output is always eventually computed regardless of how the computation proceeds. ?? 2007 Elsevier B.V. All rights reserved.},
author = {Hidders, Jan and Kwasnikowska, Natalia and Sroka, Jacek and Tyszkiewicz, Jerzy and {Van den Bussche}, Jan},
doi = {10.1016/j.is.2007.09.002},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Hidders et al. - 2008 - DFL A dataflow language based on Petri nets and nested relational calculus.pdf:pdf},
issn = {03064379},
journal = {Information Systems},
keywords = {DFL,Dataflow,Nested relational calculus,Petri net,Scientific workflow,Workflow system},
number = {3},
pages = {261--284},
title = {{DFL: A dataflow language based on Petri nets and nested relational calculus}},
url = {http://www.sciencedirect.com/science/article/pii/S0306437907000634},
volume = {33},
year = {2008}
}
@article{Desel2005,
author = {Desel, J and Esparza, J},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Desel, Esparza - 2005 - Free choice Petri nets.pdf:pdf},
isbn = {0-521-46519-2},
journal = {Zhurnal Eksperimental'noi i Teoreticheskoi Fiziki},
title = {{Free choice Petri nets}},
url = {https://www.google.com/books?hl=en&lr=&id=29cclsSodxEC&oi=fnd&pg=PP1&dq=free+choice+petri+nets&ots=BBNf3eLoxQ&sig=29uSIOrozqA5fL2AyBCppm_Ml-M http://books.google.com/books?hl=en&lr=&id=29cclsSodxEC&oi=fnd&pg=PP1&dq=Free+Choice+Petri+nets&ots=BBHlWiPlvQ&si},
year = {2005}
}
@article{Tutorial1990,
author = {Tutorial, a Petri-net-oriented and Best, Eike and Koutny, Maciej},
doi = {10.1007/978-3-540-27755-2_5},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Tutorial, Best, Koutny - 1990 - Process Algebra.pdf:pdf},
isbn = {0-521-40043-0},
keywords = {petri nets,process algebras},
pages = {180--209},
publisher = {Springer Berlin Heidelberg},
title = {{Process Algebra}},
url = {http://link.springer.com/10.1007/978-3-540-27755-2_5},
volume = {18},
year = {1990}
}
@book{Reisig1985,
address = {Berlin, Heidelberg},
author = {Reisig, Wolfgang},
doi = {10.1007/978-3-642-69968-9},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Reisig - 1985 - Petri Nets.pdf:pdf},
isbn = {978-3-642-69970-2},
publisher = {Springer Berlin Heidelberg},
title = {{Petri Nets}},
url = {http://link.springer.com/10.1007/978-3-642-69968-9},
volume = {19},
year = {1985}
}
@book{Yakovlev2000,
author = {Yakovlev, Alex and Gomes, Luis and Lavagno, Luciano},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Yakovlev, Gomes, Lavagno - 2000 - Hardware design and Petri nets.pdf:pdf},
title = {{Hardware design and Petri nets}},
url = {http://link.springer.com/content/pdf/10.1007/978-1-4757-3143-9.pdf http://www.springer.com/gp/book/9780792377917},
volume = {344},
year = {2000}
}
@article{Yakovlev1998,
abstract = {Petri nets are a powerful language for describing processes in digital hardware, and particularly asynchronous or self-timed circuits. Self-timed circuits are designed to operate without the use of a global clock signal. Applications for such circuits are likely to increase during the next decade, due to problems with on-chip event coordination as VLSI technology approaches a density of one hundred million transistors per chip. Designing such circuits without help of formal tools does not seem to be possible. We present an overview of the methods for specification, verification and synthesis of asynchronous circuits with the aid of Petri nets. We present a number of design examples which are used to illustrate the authors' belief that Petri nets could become widely accepted by digital system designers as a design method.},
author = {Yakovlev, Alexandre and Koelmans, Albert},
doi = {10.1007/3-540-65307-4_49},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Yakovlev, Koelmans - 1998 - Petri nets and digital hardware design.pdf:pdf},
journal = {Lectures on Petri Nets II: Applications},
pages = {154--236},
publisher = {Springer Berlin Heidelberg},
title = {{Petri nets and digital hardware design}},
url = {http://link.springer.com/10.1007/3-540-65307-4_49 http://dx.doi.org/10.1007/3-540-65307-4_49},
year = {1998}
}
@article{Cortadella2000,
author = {Cortadella, J and Kishinevsky, M and Kondratyev, A and Lavagno, L and Yakovlev, A},
doi = {10.1007/3-540-44988-4_1},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Cortadella et al. - 2000 - Hardware and Petri Nets Application to Asynchronous Circuit Design.pdf:pdf},
isbn = {978-3-540-67693-5},
issn = {16113349},
journal = {Application and Theory of Petri Nets 2000},
pages = {1--15},
publisher = {Springer Berlin Heidelberg},
title = {{Hardware and Petri Nets Application to Asynchronous Circuit Design}},
url = {papers3://publication/uuid/9BC53BD1-26F6-495B-B621-180D81FBC78F},
year = {2000}
}
@article{Kavi1987,
abstract = {Dataflow graphs are a generalized model of computation. Uninterpreted dataflow graphs with nondeterminism resolved via probabilities are shown to be isomorphic to a class of Petri nets known as free choice nets. Petri net analysis methods are readily available in the literature and this result makes those methods accessible to dataflow research. Nevertheless, combinatorial explosion can render Petri net analysis inoperative. Using a previously known technique for decomposing free choice nets into smaller components, it is demonstrated that, in principle, it is possible to determine aspects of the overall behavior from the particular behavior of components.},
author = {Kavi, Krishna M. and Buckles, Billy P. and Bhat, U. Narayan},
doi = {10.1109/TSE.1987.232854},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Kavi, Buckles, Bhat - 1987 - Isomorphisms Between Petri Nets and Dataflow Graphs.pdf:pdf},
issn = {00985589},
journal = {IEEE Transactions on Software Engineering},
keywords = {Dataflow graphs,formance analysis,free choice nets,isomorphism,per,timed Petri nets},
number = {10},
pages = {1127--1134},
title = {{Isomorphisms Between Petri Nets and Dataflow Graphs}},
volume = {SE-13},
year = {1987}
}
@inproceedings{Zhao2015,
abstract = {Traditional techniques for pipeline scheduling in high-level synthesis for FPGAs assume an additive delay model where each operation incurs a pre-characterized delay. While a good approximation for some operation types, this fails to consider technology mapping, where a group of logic operations can be mapped to a single look-up table (LUT) and together incur one LUT worth of delay. We propose an exact formulation of the throughput-constrained, mapping-aware pipeline scheduling problem for FPGA-targeted high-level synthesis with area minimization being a primary objective. By taking this cross-layered approach, our technique is able to mitigate the pessimism inherent in static delay estimates and reduce the usage of LUTs and pipeline registers. Experimental results using our method demonstrate improved resource utilization for a number of logic-intensive, real-life benchmarks compared to a state-of-the-art commercial HLS tool for Xilinx FPGAs.},
author = {Zhao, Ritchie and Tan, Mingxing and Dai, Steve and Zhang, Zhiru},
booktitle = {Proc. ACM/EDAC/IEEE 52nd Design Automation Conference (DAC)},
doi = {10.1145/2744769.2744801},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Zhao et al. - 2015 - Area-efficient Pipelining for FPGA-targeted High-level Synthesis.pdf:pdf},
isbn = {978-1-4503-3520-1},
issn = {0738-100X},
pages = {157:1----157:6},
title = {{Area-efficient Pipelining for FPGA-targeted High-level Synthesis}},
year = {2015}
}
@article{Tang2014,
author = {Tang, W},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Tang - 2014 - Automatic Functional Datapath Optimization.pdf:pdf},
title = {{Automatic Functional Datapath Optimization}},
url = {http://nma.berkeley.edu/ark:/28722/bk001537d6r},
year = {2014}
}
@inproceedings{Sujeeth2013,
abstract = {Programmers who need high performance currently rely on low-level, architecture-specific programming models (e.g. OpenMP for CMPs, CUDA for GPUs, MPI for clusters). Performance optimization with these frameworks usually requires expertise in the specific programming model and a deep understanding of the target architecture. Domain-specific languages (DSLs) are a promising alternative, allowing compilers to map problem-specific abstractions directly to low-level architecture-specific programming models. However, developing DSLs is difficult, and using multiple DSLs together in a single application is even harder because existing compiled solutions do not compose together. In this paper, we present four new performance-oriented DSLs developed with Delite, an extensible DSL compilation framework. We demonstrate new techniques to compose compiled DSLs embedded in a common backend together in a single program and show that generic optimizations can be applied across the different DSL sections. Our new DSLs are implemented with a small number of reusable components (less than 9 parallel operators total) and still achieve performance up to 125x better than library implementations and at worst within 30% of optimized stand-alone DSLs. The DSLs retain good performance when composed together, and applying cross-DSL optimizations results in up to an additional 1.82x improvement. {\textcopyright} 2013 Springer-Verlag Berlin Heidelberg.},
author = {Sujeeth, Arvind K. and Rompf, Tiark and Brown, Kevin J. and Lee, Hyoukjoong and Chafi, Hassan and Popic, Victoria and Wu, Michael and Prokopec, Aleksandar and Jovanovic, Vojin and Odersky, Martin and Olukotun, Kunle},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
doi = {10.1007/978-3-642-39038-8-3},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Sujeeth et al. - 2013 - Composition and reuse with compiled domain-specific languages.pdf:pdf},
isbn = {9783642390371},
issn = {03029743},
pages = {52--78},
title = {{Composition and reuse with compiled domain-specific languages}},
volume = {7920 LNCS},
year = {2013}
}
@article{MITTAL2013,
abstract = {Approximate computing trades off computation quality with the effort expended and as rising performance demands confront with plateauing resource budgets, approximate computing has become, not merely attractive, but even imperative. In this paper, we present a survey of techniques for approximate computing (AC). We discuss strategies for finding approximable program portions and monitoring output quality, techniques for using AC in different processing units (e.g., CPU, GPU and FPGA), processor components, memory technologies etc., and programming frameworks for AC. We classify these techniques based on several key characteristics to emphasize their similarities and differences. The aim of this paper is to provide insights to researchers into working of AC techniques and inspire more efforts in this area to make AC the mainstream computing approach in future systems. A Survey Of Techniques for Approximate Computing (PDF Download Available). Available from: https://www.researchgate.net/publication/290194892_A_Survey_Of_Techniques_for_Approximate_Computing [accessed May 30, 2016].},
archivePrefix = {arXiv},
arxivId = {arXiv:1011.1669v3},
author = {MITTAL, SPARSH},
doi = {10.1017/CBO9781107415324.004},
eprint = {arXiv:1011.1669v3},
file = {:C\:/Users/soronpo/Downloads/A_Survey_Of_Techniques_for_Approximate_C.pdf:pdf},
isbn = {9788578110796},
issn = {1098-6596},
journal = {Journal of Chemical Information and Modeling},
number = {9},
pmid = {25246403},
title = {{A Survey of Techniques for Approximate Computing}},
volume = {53},
year = {2013}
}
@article{Nane2016,
abstract = {High-level synthesis (HLS) is increasingly popular for the design of high-performance and energy-efficient heteroge- neous systems, shortening time-to-market and addressing today's system complexity. HLS allows designers to work at a higher- level of abstraction by using a software program to specify the hardware functionality. Additionally,HLS is particularly interest- ing for designing field-programmable gate array circuits, where hardware implementations can be easily refined and replaced in the target device. Recent years have seen much activity in the HLS research community, with a plethora of HLS tool offer- ings, from both industry and academia. All these tools may have different input languages, perform different internal optimiza- tions, and produce results of different quality, even for the very same input description. Hence, it is challenging to compare their performance and understand which is the best for the hard- ware to be implemented. We present a comprehensive analysis of recent HLS tools, as well as overview the areas of active interest in the HLS research community. We also present a first- published methodology to evaluate different HLS tools. We use our methodology to compare one commercial and three academic tools on a common set of C benchmarks, aiming at perform- ing an in-depth evaluation in terms of performance and the use of resources. Index},
author = {Nane, Razvan and Sima, Vlad Mihai and Pilato, Christian and Choi, Jongsok and Fort, Blair and Canis, Andrew and Chen, Yu Ting and Hsiao, Hsuan and Brown, Stephen and Ferrandi, Fabrizio and Anderson, Jason and Bertels, Koen},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Nane et al. - 2016 - A Survey and Evaluation of FPGA High-Level Synthesis Tools.pdf:pdf},
isbn = {0278-0070 VO - PP},
issn = {02780070},
journal = TCADICS,
keywords = {Bambu,Dwarv,LegUp,Survey,comparison,evaluation,field-programmable gate array (FPGA),high-level synthesis (HLS)},
number = {10},
pages = {1591--1604},
title = {{A Survey and Evaluation of FPGA High-Level Synthesis Tools}},
volume = {35},
year = {2016}
}
@inproceedings{Vestias2014,
abstract = {Floating-point computing with more than one TFLOP of peak performance is already a reality in recent Field-Programmable Gate Arrays (FPGA). General-Purpose Graphics Processing Units (GPGPU) and recent many-core CPUs have also taken advantage of the recent technological innovations in integrated circuit (IC) design and had also dramatically improved their peak performances. In this paper, we compare the trends of these computing architectures for high-performance computing and survey these platforms in the execution of algorithms belonging to different scientific application domains. Trends in peak performance, power consumption and sustained performances, for particular applications, show that FPGAs are increasing the gap to GPUs and many-core CPUs moving them away from high-performance computing with intensive floating-point calculations. FPGAs become competitive for custom floating-point or fixed-point representations, for smaller input sizes of certain algorithms, for combinational logic problems and parallel map-reduce problems.},
author = {Vestias, Mario and Neto, Horacio},
booktitle = {Conference Digest - 24th International Conference on Field Programmable Logic and Applications, FPL 2014},
doi = {10.1109/FPL.2014.6927483},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Vestias, Neto - 2014 - Trends of CPU, GPU and FPGA for high-performance computing.pdf:pdf},
isbn = {9783000446450},
issn = {1946-147X},
title = {{Trends of CPU, GPU and FPGA for high-performance computing}},
year = {2014}
}
@inproceedings{Wozniak2014,
abstract = {Dataflow languages offer a natural means to express concurrency but are not a natural representation of the architectural features of high-performance, distributed-memory computers. When used as the outermost language in a hierarchical programming model, dataflow is very effective at expressing the overall flow of a computation. In this work, we present strategies and techniques used by the Swift dataflow language to obtain good performance on extremely large computing systems. We also present multiple unique language features that offer practical utility and performance enhancements. \n \n},
author = {Wozniak, Justin M. and Wilde, Michael and Foster, Ian T.},
booktitle = {Proceedings - 2014 4th Workshop on Data-Flow Execution Models for Extreme Scale Computing, DFM 2014},
doi = {10.1109/DFM.2014.17},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Wozniak, Wilde, Foster - 2014 - Language features for scalable distributed-memory dataflow computing.pdf:pdf},
isbn = {9781479980956},
pages = {50--53},
title = {{Language features for scalable distributed-memory dataflow computing}},
year = {2014}
}
@article{Venkataramani2015,
abstract = {Diminishing benefits from technology scaling have pushed de-signers to look for new sources of computing efficiency. Multi-cores and heterogeneous accelerator-based architectures are a by-product of this quest to obtain improvements in the per-formance of computing platforms at similar or lower power budgets. In light of the need for new innovations to sustain these improvements, we discuss approximate computing, a field that has attracted considerable interest over the last decade. While the core principles of approximate comput-ing — computing efficiently by producing results that are good enough or of sufficient quality — are not new and are shared by many fields from algorithm design to networks and distributed systems, recent efforts have seen a percolation of these principles to all layers of the computing stack, including circuits, architecture, and software. Approximate computing techniques have also evolved from ad hoc and application-specific to more broadly applicable, supported by systematic design methodologies. Finally, the emergence of workloads such as recognition, mining, search, data analytics, inference and vision are greatly increasing the opportunities for ap-proximate computing. We describe the vision and key prin-ciples that have guided our work in this area, and outline a holistic cross-layer framework for approximate computing.},
author = {Venkataramani, Swagath and Chakradhar, Srimat T. and Roy, Kaushik and Raghunathan, Anand},
doi = {10.1145/2744769.2751163},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Venkataramani et al. - 2015 - Approximate computing and the quest for computing efficiency.pdf:pdf},
isbn = {9781450335201},
issn = {0738100X},
journal = {Proceedings of the 52nd Annual Design Automation Conference on - DAC '15},
pages = {1--6},
title = {{Approximate computing and the quest for computing efficiency}},
url = {http://dl.acm.org/citation.cfm?id=2744769.2751163%5Cnhttp://dl.acm.org/citation.cfm?doid=2744769.2751163},
year = {2015}
}
@article{Pell2011,
author = {Pell, Oliver and Mencer, Oskar},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Pell, Mencer - 2011 - Surviving the end of frequency scaling with reconfigurable dataflow computing.pdf:pdf},
issn = {01635964},
journal = {ACM SIGARCH Computer Architecture News},
number = {4},
title = {{Surviving the end of frequency scaling with reconfigurable dataflow computing}},
volume = {39},
year = {2011}
}
@article{Takach2016,
author = {Takach, Andres},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Takach - 2016 - High-Level Synthesis Status , Trends , and Future Directions.pdf:pdf},
journal = {IEEE Design & Test},
number = {April},
pages = {116--124},
title = {{High-Level Synthesis : Status , Trends , and Future Directions}},
url = {http://ieeexplore.ieee.org/abstract/document/7445863/},
year = {2016}
}
@article{Fingeroff2010a,
author = {Fingeroff, M},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Fingeroff - 2010 - High-level synthesis blue book(2).pdf:pdf},
isbn = {13 (HB): 978-1-4500- 9724-6},
title = {{High-level synthesis blue book}},
url = {https://www.google.com/books?hl=en&lr=&id=k_ZCyNEK2hkC&oi=fnd&pg=PA2&dq=High-Level+Synthesis+Blue+Book+.&ots=aeIn5HP3La&sig=gsoyRoJMqQ-0_ednOTrr_w-aiuo http://link.springer.com/content/pdf/10.1007/978-1-4615-3636-9.pdf%5Cnhttp://scholar.google.com/scholar},
year = {2010}
}
@inproceedings{Thomas2016,
abstract = {C-based HLS tools continue to improve in analysis and optimisation, but are still restricted to a subset of C functionality. A C language feature missing from all common HLS tools is recursion, which makes it difficult and time consuming to write many types of programs in HLS. This paper presents a technique for implementing recursion as an Embedded Domain Specific Language (EDSL) in C++, utilising the C++ front-end of a HLS compiler to build the state machines and stacks, while ensuring the code presented to the back-end is completely synthesisable. While the EDSL is not pure C, it provides a user-friendly language that can be trivially translated from a recursive C program, and can contain calls to plain C for compute-intensive leaf functions. HLSRecurse is a platform independent library that allows the same program to be compiled using g++, clang, Legup, or Vivado HLS, and have the same execution semantics. The performance of HLSRecurse is evaluated in software and hardware using three micro-benchmarks of the underlying state-machine builder, and five practical examples of real recursive programs including a Sudoku solver, Strassen multiplication, and adaptive Monte-Carlo integration. We show that for Vivado HLS the DSL provides the same area-time product as manually converted programs, while in Legup the DSL increases the area-time product by 1.5×.},
author = {Thomas, David B.},
booktitle = {2016 IEEE 27th International Conference on Application-specific Systems, Architectures and Processors (ASAP)},
doi = {10.1109/ASAP.2016.7760777},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Thomas - 2016 - Synthesisable recursion for C HLS tools.pdf:pdf},
isbn = {978-1-5090-1503-0},
keywords = {C++ languages,Computer architecture,DSL,Hardware,Libraries,Optimization,Software},
month = {jul},
pages = {91--98},
publisher = {IEEE},
title = {{Synthesisable recursion for C++ HLS tools}},
url = {http://ieeexplore.ieee.org/document/7760777/},
year = {2016}
}
@article{Li2015,
abstract = {Approximate computing has been recognized as an effective low power technique for applications with intrinsic error tolerance, such as image processing and machine learning. Existing efforts on this front are mostly focused on approximate circuit design, approximate logic synthesis or processor architecture approximation techniques. This work aims at how to make good use of approximate circuits at system and block level. In particular, approximation aware scheduling, functional unit allocation and binding algorithms are developed for data intensive applications. Simple yet credible error models, which are essential for precision control in the optimizations, are investigated. The algorithms are further extended to include bitwidth optimization in fixed point computations. Experimental results, including those from Verilog simulations, indicate that the proposed techniques facilitate desired energy savings under latency and accuracy constraints.},
author = {Li, Chaofan and Luo, Wei and Sapatnekar, S S and Hu, Jiang},
doi = {10.1145/2744769.2744863},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Li et al. - 2015 - Joint precision optimization and high level synthesis for approximate computing.pdf:pdf},
isbn = {9781450335201},
issn = {0738100X},
journal = {Design Automation Conference (DAC), 2015 52nd ACM/EDAC/IEEE},
keywords = {Verilog simulation,high level synthesis,scheduling},
pages = {1--6},
title = {{Joint precision optimization and high level synthesis for approximate computing}},
year = {2015}
}
@inproceedings{Kapre2016,
abstract = {— Highperformance FPGA programming has typically been the exclusive domain of a small band of specialized hardware developers. They are capable of reasoning about implementation concerns at the registertransfer level (RTL) which is analogous to assemblylevel programming in software. Sometimes these developers are required to push further down to manage even lower levels of abstraction closer to physical aspects of the design such as detailed layout to meet critical design constraints. In contrast, software programmers have long since moved away from textual assemblylevel programming towards relying on graphical integrated development environments (IDEs), highlevel compilers, smart static analysis tools and runtime systems that optimize, manage and assist the program development tasks. Domainspecific languages (DSLs) can bridge this productivity gap by providing higher levels of abstraction in environments close to the domain of application expert. DSLs carefully limit the set of programming constructs to minimize programmer mistakes while also enabling a rich set of domainspecific optimizations and program transformations. With a large number of DSLs to choose from, an inexperienced FPGA user may be confused about how to select an appropriate one for the intended domain. In this paper, we review a combination of legacy and stateoftheart DSLs available for FPGA development and provide a taxonomy and classification to guide selection and correct use of the framework.},
author = {Kapre, Nachiket and Bayliss, Samuel},
booktitle = FPL,
isbn = {9782839918442},
title = {{Survey of domain-specific languages for FPGA computing}},
year = {2016}
}
@article{Canis2013,
abstract = {It is generally accepted that a custom hardware implementation of a set of computations will provide superior speed and energy efficiency relative to a software implementation. However, the cost and difficulty of hardware design is often prohibitive, and consequently, a software approach is used for most applications. In this article, we introduce a new high-level synthesis tool called LegUp that allows software techniques to be used for hardware design. LegUp accepts a standard C program as input and automatically compiles the program to a hybrid architecture containing an FPGA-based MIPS soft processor and custom hardware accelerators that communicate through a standard bus interface. In the hybrid processor/accelerator architecture, program segments that are unsuitable for hardware implementation can execute in software on the processor. LegUp can synthesize most of the C language to hardware, including fixed-sized multidimensional arrays, structs, global variables, and pointer arithmetic. Results show that the tool produces hardware solutions of comparable quality to a commercial high-level synthesis tool. We also give results demonstrating the ability of the tool to explore the hardware/software codesign space by varying the amount of a program that runs in software versus hardware. LegUp, along with a set of benchmark C programs, is open source and freely downloadable, providing a powerful platform that can be leveraged for new research on a wide range of high-level synthesis topics.},
archivePrefix = {arXiv},
arxivId = {arXiv:1502.07526v1},
author = {Canis, Andrew and Choi, Jongsok and Aldham, Mark and Zhang, Victor and Kammoona, Ahmed and Czajkowski, Tomasz and Brown, Stephen D. and Anderson, Jason H.},
doi = {10.1145/2514740},
eprint = {arXiv:1502.07526v1},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Canis et al. - 2013 - LegUp An Open-source High-level Synthesis Tool for FPGA-based ProcessorAccelerator Systems.pdf:pdf},
isbn = {1539-9087},
issn = {1539-9087},
journal = {ACM Trans. Embed. Comput. Syst.},
number = {2},
pages = {24:1--24:27},
pmid = {1000285845},
title = {{LegUp: An Open-source High-level Synthesis Tool for FPGA-based Processor/Accelerator Systems}},
url = {http://doi.acm.org/10.1145/2514740},
volume = {13},
year = {2013}
}
@book{zhang2008high,
author = {Zhang, Zhiru and Fan, Y and Jiang, W and Han, G and Yang, C and Cong, J},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Zhang et al. - 2008 - High-Level Synthesis From Algorithm to Digital Circuit.pdf:pdf},
publisher = {Springer Nettherlands},
title = {{High-Level Synthesis: From Algorithm to Digital Circuit}},
year = {2008}
}
@article{Sampson2011,
abstract = {Energy is increasingly a first-order concern in computer systems. Exploiting energy-accuracy trade-offs is an attractive choice in applications that can tolerate inaccuracies. Recent work has explored exposing this trade-off in programming models. A key challenge, though, is how to isolate parts of the program that must be precise from those that can be approximated so that a program functions correctly even as quality of service degrades. We propose using type qualifiers to declare data that may be subject to approximate computation. Using these types, the system automatically maps approximate variables to low-power storage, uses low-power operations, and even applies more energy-efficient algorithms provided by the programmer. In addition, the system can statically guarantee isolation of the precise program component from the approximate component. This allows a programmer to control explicitly how information flows from approximate data to precise data. Importantly, employing static analysis eliminates the need for dynamic checks, further improving energy savings. As a proof of concept, we develop {EnerJ}, an extension to Java that adds approximate data types. We also propose a hardware architecture that offers explicit approximate storage and computation. We port several applications to {EnerJ} and show that our extensions are expressive and effective; a small number of annotations lead to significant potential energy savings (10%-50%) at very little accuracy cost.},
address = {New York, New York, USA},
author = {Sampson, Adrian and Dietl, Werner and Fortuna, Emily and Gnanapragasam, Danushen and Ceze, Luis and Grossman, Dan},
doi = {10.1145/1993498.1993518},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Sampson et al. - 2011 - EnerJ.pdf:pdf},
isbn = {9781450306638},
issn = {03621340},
journal = {Proceedings of the 32nd ACM SIGPLAN conference on Programming language design and implementation - PLDI '11},
keywords = {accuracy-aware computing,critical data,energy,power-aware computing,soft errors},
number = {6},
pages = {164},
publisher = {ACM Press},
title = {{EnerJ}},
url = {http://portal.acm.org/citation.cfm?doid=1993498.1993518 http://doi.acm.org/10.1145/1993498.1993518%5Cnhttp://portal.acm.org/citation.cfm?doid=1993498.1993518},
volume = {46},
year = {2011}
}
@inproceedings{Stojanovic2012,
author = {Stojanovi{\'{c}}, Sa{\v{s}}a and Boji{\'{c}}, Dragan and Bojovi{\'{c}}, Miroslav and Valero, Mateo and Milutinovi{\'{c}}, Veljko},
booktitle = {2012 IEEE International Conference on Industrial Technology, ICIT 2012, Proceedings},
doi = {10.1109/ICIT.2012.6209978},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Stojanovi{\'{c}} et al. - 2012 - An overview of selected hybrid and reconfigurable architectures.pdf:pdf},
isbn = {9781467303422},
issn = {1467303402},
month = {mar},
pages = {444--449},
publisher = {IEEE},
title = {{An overview of selected hybrid and reconfigurable architectures}},
url = {http://ieeexplore.ieee.org/document/6209978/},
year = {2012}
}
@article{Gaster2012,
abstract = {With the growth in transistor counts in modern hardware, heterogeneous systems are becoming commonplace. Core counts are increasing such that GPU and CPU designs are reaching deep into the tens of cores. For performance reasons, different cores in a heterogeneous platform follow different design choices. Based on throughput computing goals, GPU cores tend to support wide vectors and substantial register files. Current designs optimize CPU cores for latency, dedicating logic to caches and out-of-order dependence control. Heterogeneous parallel primitives (HPP) addresses two major shortcomings in current GPGPU programming models: it supports full composability by defining abstractions and increases flexibility in execution by introducing braided parallelism. Heterogeneous parallel primitives is an object-oriented, C++11-based programming model that addresses these shortcomings on both CPUs and massively multithreaded GPUs: it supports full composability by defining abstractions using distributed arrays and barrier objects, and it increases flexibility in execution by introducing braided parallelism. This paper implemented a feature-complete version of HPP, including all syntactic constructs, that runs on top of a task-parallel runtime executing on the CPU. They continue to develop and improve the model, including reducing overhead due to channel management, and plan to make a public version available sometime in the future. View full abstract»},
author = {Gaster, Benedict R. and Howes, Lee},
doi = {10.1109/MC.2012.257},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Gaster, Howes - 2012 - Can GPGPU programming be liberated from the data-parallel bottleneck.pdf:pdf},
isbn = {00189162},
issn = {00189162},
journal = {Computer},
keywords = {GPGPU programming,braided parallelism,data-parallel execution,distributed arrays,hardware,heterogeneous parallel primitives,massively threaded computing systems,persistent threading},
month = {aug},
number = {8},
pages = {42--52},
title = {{Can GPGPU programming be liberated from the data-parallel bottleneck?}},
url = {http://ieeexplore.ieee.org/document/6272260/},
volume = {45},
year = {2012}
}
@book{Rushton2011,
abstract = {"Macrocycles: Construction, Chemistry and Nanotechnology Applications is an essential introduction this important class of molecules and describes how to synthesise them, their chemistry, how they can be used as nanotechnology building blocks, and their applications"--},
author = {Rushton, Andrew},
doi = {10.1002/9781119995852.ch2},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Rushton - 2011 - VHDL for logic synthesis.pdf:pdf},
isbn = {9780470688472 (hardback); 0470688475 (hardback); National Library: 015649127 LCCN: 2010-45678},
keywords = {COMPUTERS / Computer Engineering,Computer-aided design,Logic design -- Data processing,VHDL (Computer hardware description language)},
pages = {7--17},
title = {{VHDL for logic synthesis}},
url = {https://www.google.com/books?hl=en&lr=&id=lC8HKr0e2nwC&oi=fnd&pg=PT8&dq=VHDL+for+Logic+Synthesis&ots=aBQkTtQy-n&sig=P-qnEutiZWPWgsKtY4AIg6ECrY4 http://catalogimages.wiley.com/images/db/jimages/9780470688472.jpg%5Cn Materials specified: Cover image http://},
volume = {3rd ed. Pr},
year = {2011}
}
@article{Sutherland2012,
author = {Sutherland, I},
journal = CACM,
title = {{The tyranny of the clock}},
volume = {55},
number = {10},
pages = {35--36},
year = {2012}
}
@article{Mamaghani2015,
author = {Mamaghani, Mahdi Jelodari and Garside, Jim and Edwards, Doug},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Mamaghani, Garside, Edwards - 2015 - De-Elastisation From Asynchronous Dataflows to Synchronous Circuits.pdf:pdf},
isbn = {9783981537048},
issn = {15301591},
journal = {& Test in Europe Conference & {\ldots}},
pages = {273--276},
title = {{De-Elastisation : From Asynchronous Dataflows to Synchronous Circuits}},
url = {http://dl.acm.org/citation.cfm?id=2755813},
year = {2015}
}
@article{ieee2008std,
author = {Committee, IEEE Design Automation Standards and Others},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Committee, others - 2008 - Std 1076-2008, IEEE Standard VHDL Language Reference Manual.pdf:pdf},
journal = {IEEE, New York, NY, USA, ISBN},
pages = {970--978},
title = {{Std 1076-2008, IEEE Standard VHDL Language Reference Manual}},
year = {2008}
}
@inproceedings{Goodman2011,
author = {Goodman, Daniel and Lujan, Mikel},
booktitle = {Multi-Core and Reconfigurable Super Computing Conference, Bristol},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Goodman, Lujan - 2011 - Scientific GPU Programming with Data-Flow Languages.pdf:pdf},
title = {{Scientific GPU Programming with Data-Flow Languages}},
url = {http://www.cs.man.ac.uk/$\sim$goodmand/papers/Goodman-MRSC.pdf},
year = {2011}
}
@article{Windh2015,
abstract = {In the past decade or so we have witnessed a steadily increasing interest in FPGAs as hardware accelerators: they provide an excellent mid-point between the reprogrammability of software devices (CPUs, DSPs, and GPUs) and the performance and low energy consumption of ASICs. However, the programmability of FPGA-based accelerators remains one of the biggest obstacles to their wider adoption. Developing FPGA programs requires extensive familiarity with hardware design and experience with a tedious and complex tool chain. For half a century, layers of abstractions have been developed that simplify the software development process: languages, compilers, dynamically linked libraries, operating systems, APIs, etc. Very little, if any, such abstractions exist in the development of FPGA programs. In this paper, we review the history of using FPGAs as hardware accelerators and summarize the challenges facing the raising of the programming abstraction layers. We survey five High-Level Language tools for the development of FPGA programs: Xilinx Vivado, Altera OpenCL, BluespecBSV, ROCCC, and LegUp to provide an overview of their tool flow, the optimizations they provide, and a qualitative analysis of their hardware implementations of high level code.},
author = {Windh, Skyler and Ma, Xiaoyin and Halstead, Robert J. and Budhkar, Prerna and Luna, Zabdiel and Hussaini, Omar and Najjar, Walid A.},
file = {:C\:/Users/soronpo/Downloads/04969a4f163fa8e377cabf515520b6eb8b45.pdf:pdf},
issn = {00189219},
journal = PROCIEEE,
keywords = {Compiler optimization,high level synthesis,max filter,reconfigurable computing},
number = {3},
pages = {390--408},
title = {{High-level language tools for reconfigurable computing}},
volume = {103},
year = {2015}
}
@inproceedings{Choi2013,
abstract = {We describe the support within high-level hardware synthesis (HLS) for two standard software parallelization paradigms: Pthreads and OpenMP. Parallel code segments, as specified in the software, are automatically synthesized by our HLS tool into parallel-operating hardware sub-circuits. Both data parallelism and task-level parallelism are supported, as is the combined use of both Pthreads and OpenMP. Moreover, our work also provides automated synthesis for commonly occurring synchronization constructs within the Pthreads/OpenMP library: mutual exclusion (mutex) and barriers. Essentially, our framework allows a software engineer to specify parallelism to an HLS tool using methodologies they are likely to be familiar with. An experimental study considers a variety of parallelization scenarios, including demonstrated speedups of up to 12.9&#x00D7; in circuit wall-clock time for the 16-thread case and area-delay product as low as 12% ($\sim$8&#x00D7; improvement) when using 4 pipelined hardware threads.},
author = {Choi, Jongsok and Brown, Stephen and Anderson, Jason},
booktitle = {FPT 2013 - Proceedings of the 2013 International Conference on Field Programmable Technology},
doi = {10.1109/FPT.2013.6718365},
isbn = {9781479921990},
pages = {270--277},
title = {{From software threads to parallel hardware in high-level synthesis for FPGAs}},
year = {2013}
}
@inproceedings{Amin2016,
abstract = {Focusing on path-dependent types, the paper develops foundations for Scala from first principles. Starting from a simple calculus D-<: of dependent functions, it adds records, intersections and recursion to arrive at DOT, a calculus for dependent object types. The paper shows an encoding of System F with subtyping in D-<: and demonstrates the expressiveness of DOT by modeling a range of Scala constructs in it.},
author = {Amin, Nada and Gr{\"{u}}tter, Samuel and Odersky, Martin and Rompf, Tiark and Stucki, Sandro},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
doi = {10.1007/978-3-319-30936-1_14},
file = {:C\:/Users/soronpo/Downloads/amin-wf16.pdf:pdf},
isbn = {9783319309354},
issn = {16113349},
keywords = {Calculus,Dependent types,Scala},
pages = {249--272},
publisher = {Springer International Publishing},
title = {{The essence of dependent object types}},
url = {http://link.springer.com/10.1007/978-3-319-30936-1_14},
volume = {9600},
year = {2016}
}
@inproceedings{Flynn2012,
abstract = {Over the past decades parallel processor speedup has been an elusive quantity for a broad class of applications. Yet with the end of performance scaling for single processors the need for speedup has never been greater. The problem is not technology but programming models. One answer to this speedup problem is to create an idealized data flow machine that exactly corresponds to the application and stream data through the resulting machine. This approach can be emulated with FPGAs, providing more than an order of magnitude speedup even as executed as an emulation of the data flow machine.},
author = {Flynn, Michael J and Pell, Oliver and Mencer, Oskar},
booktitle = {Proceedings - 22nd International Conference on Field Programmable Logic and Applications, FPL 2012},
doi = {10.1109/FPL.2012.6339170},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Flynn, Pell, Mencer - 2012 - Dataflow supercomputing.pdf:pdf},
isbn = {9781467322560},
month = {aug},
pages = {1--3},
publisher = {IEEE},
title = {{Dataflow supercomputing}},
url = {http://ieeexplore.ieee.org/document/6339170/},
year = {2012}
}
@article{Li2015a,
abstract = {The last decade has witnessed the blooming emergence of many-core platforms, especially the graphic processing units (GPUs). With the exponential growth of cores in GPUs, utilizing them efficiently becomes a challenge. The data-parallel programming model assumes a single instruction stream for multiple concurrent threads (SIMT); therefore little support is offered to enforce thread ordering and fine-grained synchronizations. This becomes an obstacle when migrating algorithms which exploit fine-grained parallelism, to GPUs, such as the dataflow algorithms. In this paper, we propose a novel approach for fine-grained inter-thread synchronizations on the shared memory of modern GPUs. We demonstrate its performance and compare it with other fine-grained and medium-grained synchronization approaches. Our method achieves 1.5x speedup over the warp-barrier based approach and 4.0x speedup over the atomic spin-lock based approach on average. To further explore the possibility of realizing fine-grained dataflow algorithms on GPUs, we apply the proposed synchronization scheme to Needleman-Wunsch - a 2D wavefront application involving massive cross-loop data dependencies. Our implementation achieves 3.56x speedup over the atomic spin-lock implementation and 1.15x speedup over the conventional data-parallel implementation for a basic sub-grid, which implies that the fine-grained, lock-based programming pattern could be an alternative choice for designing general-purpose GPU applications (GPGPU).},
address = {New York, New York, USA},
author = {Li, Ang and Braak, Gert-jan Van Den and Corporaal, Henk},
doi = {10.1145/2751205.2751232},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Li, Braak, Corporaal - 2015 - Fine-Grained Synchronizations and Dataflow Programming on GPUs.pdf:pdf},
isbn = {9781450335591},
journal = {Proceedings of the 29th ACM on International Conference on Supercomputing - ICS '15},
keywords = {Data ow,Fine-grained synchronization,GPU,Spin-lock},
pages = {109--118},
publisher = {ACM Press},
title = {{Fine-Grained Synchronizations and Dataflow Programming on GPUs}},
url = {http://dl.acm.org/citation.cfm?doid=2751205.2751232},
year = {2015}
}
@article{SanMiguel2016,
abstract = {—Approximate computing is an emerging paradigm enabling tradeoffs between accuracy and efficiency. However, a fundamental challenge persists: state-of-the-art techniques lack the ability to enforce runtime guarantees on accuracy. The convention is to 1) employ offline or online accuracy models, or 2) present experimental results that demonstrate empirically low error. Unfortunately, these approaches are still unable to guarantee acceptability of all application outputs at runtime. We offer a solution that revisits concepts from anytime algorithms. Originally explored for real-time decision problems, anytime algorithms have the property of producing results with increasing accuracy over time. We propose the Anytime Automaton, a new computation model that executes applications as a parallel pipeline of anytime approximations. An automaton produces approximate versions of the applica-tion output with increasing accuracy, guaranteeing that the final precise version is eventually reached. The automaton can be stopped whenever the output is deemed acceptable; otherwise, it is a simple matter of letting it run longer. We present an in-depth analysis of the model and demonstrate attractive runtime-accuracy profiles on various applications. Our anytime automaton is the first step towards systems where the acceptability of an application's output directly governs the amount of time and energy expended.},
author = {{San Miguel}, Joshua and {Enright Jerger}, Natalie},
doi = {10.1109/ISCA.2016.54},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/San Miguel, Enright Jerger - 2016 - The Anytime Automaton.pdf:pdf},
isbn = {978-1-4673-8947-1},
journal = {ISCA},
month = {jun},
pages = {545--557},
publisher = {IEEE},
title = {{The Anytime Automaton}},
url = {http://ieeexplore.ieee.org/document/7551421/},
year = {2016}
}
@article{Pell2012,
author = {Pell, Oliver and Averbukh, Vitali},
doi = {10.1109/MCSE.2012.78},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Pell, Averbukh - 2012 - Maximum Performance Computing with Dataflow Engines.pdf:pdf},
issn = {1521-9615},
journal = {Computing in Science & Engineering},
month = {jul},
number = {4},
pages = {98--103},
title = {{Maximum Performance Computing with Dataflow Engines}},
url = {http://ieeexplore.ieee.org/document/6241370/},
volume = {14},
year = {2012}
}
@article{Marshall1994,
author = {Marshall, I},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Marshall - 1994 - Specification and synthesis in interval temporal logic.pdf:pdf},
journal = {Structured Methods for Hardware Systems Design, {\ldots}},
title = {{Specification and synthesis in interval temporal logic}},
url = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=369632},
year = {1994}
}
@article{Widemann2016,
author = {Widemann, BT y and Lepper, M},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Widemann, Lepper - 2016 - Higher-Order Causal Stream Functions in Sig from First Principles.pdf:pdf},
journal = {Proceedings Software Engineering  {\ldots}},
title = {{Higher-Order Causal Stream Functions in Sig from First Principles}},
url = {http://ceur-ws.org/Vol-1559/paper03.pdf},
year = {2016}
}
@article{Hendriks2012,
author = {Hendriks, Johan},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Hendriks - 2012 - High Level Synthesis Performance Analysis and Code Optimization Author.pdf:pdf},
title = {{High Level Synthesis : Performance Analysis and Code Optimization Author :}},
year = {2012}
}
@article{grover2014design,
author = {Grover, Naresh and Soni, M K},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Grover, Soni - 2014 - Design of FPGA based 32-bit Floating Point Arithmetic Unit and verification of its VHDL code using MATLAB.pdf:pdf},
journal = {International Journal of Information Engineering and Electronic Business (IJIEEB)},
number = {1},
pages = {1},
title = {{Design of FPGA based 32-bit Floating Point Arithmetic Unit and verification of its VHDL code using MATLAB}},
volume = {6},
year = {2014}
}
@article{Caspi1987,
author = {Caspi, P and Pilaud, D and Halbwachs, N and Plaice, JA},
journal = POPL,
title = {{LUSTRE: a declarative language for real-time programming}},
year = {1987}
}
@book{Muller2010,
author = {Muller, Jean-Michel and Brisebarre, Nicolas and de Dinechin, Florent and Jeannerod, Claude-Pierre and Lef{\`{e}}vre, Vincent and Melquiond, Guillaume and Revol, Nathalie and Stehl{\'{e}}, Damien and Torres, Serge},
doi = {10.1007/978-0-8176-4705-6},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Muller et al. - 2010 - Handbook of Floating-Point Arithmetic.pdf:pdf},
isbn = {978-0-8176-4704-9},
pages = {572},
title = {{Handbook of Floating-Point Arithmetic}},
year = {2010}
}
@article{graphics2008catapult,
author = {Graphics, Mentor},
journal = {Website: http://www. mentor. com},
title = {{Catapult C synthesis}},
year = {2008}
}
@inproceedings{bjesse1998lava,
author = {Bjesse, Per and Claessen, Koen and Sheeran, Mary and Singh, Satnam},
booktitle = {ACM SIGPLAN Notices},
number = {1},
organization = {ACM},
pages = {174--184},
title = {{Lava: hardware design in Haskell}},
volume = {34},
year = {1998}
}
@article{Sokolov2006,
author = {Sokolov, Danil},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Sokolov - 2006 - Automated synthesis of asynchronous circuits using direct mapping for control and data paths.pdf:pdf},
number = {January},
title = {{Automated synthesis of asynchronous circuits using direct mapping for control and data paths}},
year = {2006}
}
@article{Lockhart2014,
author = {Lockhart, D and Zibrat, G and Batten, C},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Lockhart, Zibrat, Batten - 2014 - Pymtl A unified framework for vertically integrated computer architecture research.pdf:pdf},
journal = {{\ldots}  (MICRO), 2014 47th Annual  {\ldots}},
title = {{Pymtl: A unified framework for vertically integrated computer architecture research}},
url = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=7011395},
year = {2014}
}
@article{Halbwachs1991,
author = {Halbwachs, N and Caspi, P},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Halbwachs, Caspi - 1991 - The synchronous data flow programming language LUSTRE.pdf:pdf},
journal = {Proceedings of the  {\ldots}},
title = {{The synchronous data flow programming language LUSTRE}},
url = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=97300},
year = {1991}
}
@book{Mcauley2011,
author = {Mcauley, Tynan},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Mcauley - 2011 - Half-Precision Floating Point Addition Unit.pdf:pdf;:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Mcauley - 2011 - Half-Precision Floating Point Addition Unit(2).pdf:pdf},
isbn = {1111111111},
title = {{Half-Precision Floating Point Addition Unit}},
year = {2011}
}
@article{Groote2012,
author = {Groote, R De and Kuper, J},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Groote, Kuper - 2012 - Max-plus algebraic throughput analysis of synchronous dataflow graphs.pdf:pdf},
journal = {{\ldots}  (SEAA), 2012 38th  {\ldots}},
title = {{Max-plus algebraic throughput analysis of synchronous dataflow graphs}},
url = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=6328124},
year = {2012}
}
@misc{hsing2013aes,
author = {Hsing, Homer},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Hsing - 2013 - AES Core Specification.pdf:pdf},
publisher = {OpenCores},
title = {{AES Core Specification}},
url = {http://opencores.org/usercontent,doc,1354351714},
year = {2013}
}
@article{Fujita1986,
author = {Fujita, M and Kono, S and Tanaka, H and Moto-Oka, T},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Fujita et al. - 1986 - Tokio Logic programming language based on temporal logic and its compilation to prolog.pdf:pdf},
journal = {Third International Conference  {\ldots}},
title = {{Tokio: Logic programming language based on temporal logic and its compilation to prolog}},
url = {http://link.springer.com/chapter/10.1007/3-540-16492-8_119},
year = {1986}
}
@inproceedings{nikhil2004bluespec,
author = {Nikhil, Rishiyur},
booktitle = MEMOCODE,
title = {{Bluespec System Verilog: efficient, correct RTL from high level specifications}},
year = {2004}
}
@article{Arithmetic1997,
author = {Arithmetic, Floating Point},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Arithmetic - 1997 - IEEE 754 Compliant Floating Point Routines.pdf:pdf},
pages = {1--150},
title = {{IEEE 754 Compliant Floating Point Routines}},
year = {1997}
}
@article{Moszkowski1996,
author = {Moszkowski, B},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Moszkowski - 1996 - The programming language Tempura.pdf:pdf},
journal = {Journal of Symbolic Computation},
title = {{The programming language Tempura}},
url = {http://www.antonio-cau.co.uk/ITL/publications/pubs/1996-3.pdf},
year = {1996}
}
@article{Parks1995,
abstract = {We compare synchronous dataflow (SDF) and cyclo-static dataflow (CSDF), which are each special cases of a model of computation we\ncall dataflow process networks. In SDF actors have static firing rules: they consume and produce a fixed number of data tokens in\neach firing. This model is well suited to multirate signal processing applications and lends itself to efficient static scheduling,\navoiding the run-time scheduling overhead incurred by general implementations of process networks. In CSDF which is a generalization\nof SDF actors have cyclically changing firing rules. In some situations, the added generality of CSDF can unnecessarily complicate\nthe scheduling. We show how higher-order functions can be used to transform a CSDF graph into a SDF graph, simplifying the\nscheduling problem. In other situations, CSDF has a genuine advantage over SDF: simpler precedence constraints. We show how this\nmakes it possible to eliminate unnecessary computations and expose additional parallelism. We use digital sample rate conversion as\nan example to illustrate these advantages of CSDF. },
author = {Parks, Tm and Pino, Jl and Lee, Edward a.},
doi = {10.1109/ACSSC.1995.540541},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Parks, Pino, Lee - 1995 - A comparison of synchronous and cycle-static dataflow.pdf:pdf},
isbn = {1-55937-533-7},
issn = {1058-6393},
journal = {Signals, Systems and Computers, {\ldots}},
number = {October},
pages = {1--7},
title = {{A comparison of synchronous and cycle-static dataflow}},
url = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=540541},
year = {1995}
}
@inproceedings{Bachrach2012,
author = {Bachrach, Jonathan and Vo, Huy and Richards, Brian and Lee, Yunsup and Waterman, Andrew and Avi{\v{z}}ienis, Rimas and Wawrzynek, John and Asanovi{\'{c}}, Krste},
booktitle = DAC,
title = {{Chisel: Constructing Hardware in a Scala Embedded Language}},
year = {2012}
}

@inproceedings{Port2017,
author = {Port, Oron and Etsion, Yoav},
booktitle = FPL,
title = {{DFiant: A Dataflow Hardware Description Language}},
year = {2017}
}

@inproceedings{Clow2017,
  author = {Clow, John and Tzimpragos, Georgios and Dangwal, Deeksha and Guo, Sammy and McMahan, Joseph and Sh, Timothy},
  booktitle = FPGA,
  title = {{A Pythonic Approach for Rapid Hardware Prototyping and Instrumentation}},
  year = {2017}
}
@article{zhang2000review,
author = {Zhang, Xuejie and Ng, Kam W},
journal = {Microprocessors and Microsystems},
number = {4},
pages = {199--211},
publisher = {Elsevier},
title = {{A review of high-level synthesis for dynamically reconfigurable FPGAs}},
volume = {24},
year = {2000}
}
@article{Budiu2002,
abstract = {We present Pegasus, a compact and expressive intermediate representation for imperative languages. The representation is suitable for target architectures supporting predicated execution and aggressive speculation. In Pegasus information about the global dataflow of the program is encoded in local structures, enabling compact and efficient algorithms for program optimizations. As a proof of the versatility of Pegasus, we have used it in a compiler translating C programs to hardware implementations.},
author = {Budiu, M and Goldstein, Sc},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Budiu, Goldstein - 2002 - Pegasus An efficient intermediate representation.pdf:pdf},
isbn = {0001401106},
keywords = {dataflow analysis,intermediate representation,optimizing compilers,predication,program optimization,static-single assignment},
number = {April},
title = {{Pegasus: An efficient intermediate representation}},
year = {2002}
}
@article{Fingeroff2010,
author = {Fingeroff, M},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Fingeroff - 2010 - High-level synthesis blue book(2).pdf:pdf},
isbn = {13 (HB): 978-1-4500- 9724-6},
title = {{High-level synthesis blue book}},
url = {http://link.springer.com/content/pdf/10.1007/978-1-4615-3636-9.pdf%5Cnhttp://scholar.google.com/scholar?hl=en&btnG=Search&q=intitle:High-Level+Synthesis+Blue+Book#0},
year = {2010}
}
@article{Buyukkurt2010,
author = {Buyukkurt, Betul and Cortes, John and Villarreal, Jason and Najjar, Walid a.},
doi = {10.1145/1880043.1880044},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Buyukkurt et al. - 2010 - Impact of high-level transformations within the ROCCC framework.pdf:pdf},
issn = {15443566},
journal = {ACM Transactions on Architecture and Code Optimization},
number = {4},
pages = {1--36},
title = {{Impact of high-level transformations within the ROCCC framework}},
volume = {7},
year = {2010}
}
@inproceedings{saifhashemi2011systemverilogcsp,
author = {Saifhashemi, Arash and Beerel, Peter A},
booktitle = {Communicating Process Architectures (CPA)},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Saifhashemi, Beerel - 2011 - SystemVerilogCSP Modeling Digital Asynchronous Circuits Using SystemVerilog Interfaces.pdf:pdf},
title = {{SystemVerilogCSP: Modeling Digital Asynchronous Circuits Using SystemVerilog Interfaces.}},
year = {2011}
}
@article{Oliveira2008,
author = {Oliveira, Duarte L. and Strum, Marius and Sato, Sandro S.},
doi = {10.1155/2008/926851},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Oliveira, Strum, Sato - 2008 - Burst-Mode Asynchronous Controllers on FPGA.pdf:pdf;:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Oliveira, Strum, Sato - 2008 - Burst-Mode Asynchronous Controllers on FPGA(2).pdf:pdf},
issn = {1687-7195},
journal = {International Journal of Reconfigurable Computing},
number = {1},
pages = {1--10},
title = {{Burst-Mode Asynchronous Controllers on FPGA}},
url = {http://www.hindawi.com/journals/ijrc/2008/926851/},
volume = {2008},
year = {2008}
}
@misc{salah2013aespipe,
author = {Salah, Amr},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Salah - 2013 - 128 bit AES Pipelined Cipher.pdf:pdf},
publisher = {OpenCores},
title = {{128 bit AES Pipelined Cipher}},
url = {http://opencores.org/usercontent,doc,1378852274},
year = {2013}
}
@article{Saifhashemi2003,
abstract = {In this paper, we show how to use Verilog HDL along with PLI (Programming Language Interface) to model asynchronous circuits at the behavioral level by implementing CSP (Communicating Sequential Processes) language constructs. Channels and communicating actions are modeled in Verilog HDL as abstract actions.},
author = {Saifhashemi, A and Pedram, H},
doi = {10.1109/DAC.2003.1219018},
isbn = {1581136889},
issn = {0738100X},
journal = {Proceedings 2003 Design Automation Conference IEEE Cat No03CH37451},
pages = {330--333},
title = {{Verilog HDL, powered by PLI: a suitable framework for describing and modeling asynchronous circuits at all levels of abstraction}},
year = {2003}
}
@article{coussy2009introduction,
author = {Coussy, Philippe and Gajski, Daniel D and Meredith, Michael and Takach, Andres},
journal = {IEEE Design & Test of Computers},
number = {4},
pages = {8--17},
publisher = {IEEE},
title = {{An introduction to high-level synthesis}},
year = {2009}
}
@article{Tabula2010,
author = {Tabula, Inc},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Tabula - 2010 - HIGHER DSP PERFORMANCE A Cost Effective Way to Design Next Generation Communications Infrastructure Equipment.pdf:pdf},
title = {{HIGHER DSP PERFORMANCE A Cost Effective Way to Design Next Generation Communications Infrastructure Equipment}},
year = {2010}
}
@article{Kavvadias2013,
abstract = {HercuLeS is an extensible high-level synthesis (HLS) environment. It removes significant human effort by automatically mapping algorithms to hardware, providing a valuable design assist to software-oriented developers. To enable accessibility and easiness of hardware design space exploration (DSE), HercuLeS overcomes limitations of known work: non-standard source languages, insufficient representations, maintenance difficulties, necessity of code templates, lack of usage paradigms and vendor-dependence. Specific aspects that are highlighted in this manuscript are: a) the innerworkings of the HercuLeS hardware compilation engine, b) manipulation of SSA (Static Single Assignment) form, c) automatic third-party IP integration, d) backend C code generation for compiled simulation, and e) an exemplary case of DSE. HercuLeS enables efficient hardware generation that can closely match the quality of results of a manually-developed implementation with much reduced human effort and time requirements.},
author = {Kavvadias, Nikolaos and Masselos, Kostas},
doi = {10.1145/2491845.2491865},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Kavvadias, Masselos - 2013 - Hardware design space exploration using HercuLeS HLS.pdf:pdf},
isbn = {9781450319690},
journal = {Proceedings of the 17th Panhellenic Conference on Informatics - PCI '13},
keywords = {application-specific inte-,asic,cofounder and ceo,fpga,grated circuit,high level synthesis,hls},
pages = {195},
title = {{Hardware design space exploration using HercuLeS HLS}},
url = {http://dl.acm.org/citation.cfm?doid=2491845.2491865},
year = {2013}
}
@article{Villarreal2010,
abstract = {While FPGA-based hardware accelerators have repeatedly been demonstrated as a viable option, their programmability remains a major barrier to their wider acceptance by application code developers. These platforms are typically programmed in a low level hardware description language, a skill not common among application developers and a process that is often tedious and error-prone. Programming FPGAs from high level languages would provide easier integration with software systems as well as open up hardware accelerators to a wider spectrum of application developers. In this paper, we present a major revision to the Riverside Optimizing Compiler for Configurable Circuits (ROCCC) designed to create hardware accelerators from C programs. Novel additions to ROCCC include (1) intuitive modular bottom-up design of circuits from C, and (2) separation of code generation from specific FPGA platforms. The additions we make do not introduce any new syntax to the C code and maintain the high level optimizations from the ROCCC system that generate efficient code. The modular code we support functions identically as software or hardware. Additionally, we enable user control of hardware optimizations such as systolic array generation and temporal common subexpression elimination. We evaluate the quality of the ROCCC 2.0 tool by comparing it to hand-written VHDL code. We show comparable clock frequencies and a 18% higher throughput. The productivity advantages of ROCCC 2.0 is evaluated using the metrics of lines of code and programming time showing an average of 15&#x00D7; improvement over hand-written VHDL.},
author = {Villarreal, Jason and Park, Adrian and Najjar, Walid and Halstead, Robert},
doi = {10.1109/FCCM.2010.28},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Villarreal et al. - 2010 - Designing modular hardware accelerators in C with ROCCC 2.0.pdf:pdf},
isbn = {9780769540566},
journal = {Proceedings - IEEE Symposium on Field-Programmable Custom Computing Machines, FCCM 2010},
keywords = {-High level synthesis,C-to-VHDL,Compilers,FPGAs},
number = {May},
pages = {127--134},
title = {{Designing modular hardware accelerators in C with ROCCC 2.0}},
year = {2010}
}
@article{Bauer1985,
author = {Bauer, FL and Dijkstra, EW and Hoare, CAR},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Bauer, Dijkstra, Hoare - 1985 - Control flow and data flow Concepts of distributed programming.pdf:pdf;:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Bauer, Dijkstra, Hoare - 1985 - Control flow and data flow Concepts of distributed programming(2).pdf:pdf},
title = {{Control flow and data flow: Concepts of distributed programming}},
url = {http://www.osti.gov/scitech/biblio/6399738},
year = {1985}
}
@article{Lee1987,
author = {Lee, EA and Messerschmitt, DG},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Lee, Messerschmitt - 1987 - Static scheduling of synchronous data flow programs for digital signal processing.pdf:pdf},
journal = {IEEE Transactions on computers},
title = {{Static scheduling of synchronous data flow programs for digital signal processing}},
url = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=5009446},
year = {1987}
}
@article{Hansen2001,
abstract = {The author selects classic papers written by the computer scientists who made the major breakthroughs in concurrent programming. These papers cover the pioneering era of the field from the semaphores of the mid 1960s to the remote procedure calls of the late 1970s. The author summarizes the classic papers and puts them in historical perspective.},
address = {New York, NY},
author = {Hansen, Per Brinch},
doi = {10.1007/978-1-4757-3472-0_1},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Hansen - 2001 - The Invention of Concurrent Programming.pdf:pdf},
isbn = {0387954015},
journal = {The Origin of Concurrent Programming: From Semaphores to Remote Procedure Calls},
pages = {3--61},
publisher = {Springer New York},
title = {{The invention of concurrent programming}},
url = {http://link.springer.com/10.1007/978-1-4757-3472-0_1},
year = {2001}
}
@techreport{Davies1991,
author = {Davies, Jim},
booktitle = {University Computing},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Davies - 1991 - Specification and proof in real-time systems.pdf:pdf},
isbn = {0902928716},
number = {0865},
title = {{Specification and Proof in real-time systems}},
url = {http://ethos.bl.uk/OrderDetails.do?uin=uk.bl.ethos.279830},
year = {1991}
}
@book{Ptolemaeus2014,
author = {Ptolemaeus, C},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Ptolemaeus - 2014 - System Design, Modeling, and Simulation Using Ptolemy II.pdf:pdf},
title = {{System Design, Modeling, and Simulation: Using Ptolemy II}},
url = {http://ptolemy.eecs.berkeley.edu/ptolemyII/ptII9.0/ptII/doc/expressions.pdf},
year = {2014}
}
@article{Hari2008,
author = {Hari, SKS and Konda, VVR},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Hari, Konda - 2008 - Automatic constraint based test generation for behavioral HDL Models.pdf:pdf},
journal = {Very Large Scale  {\ldots}},
title = {{Automatic constraint based test generation for behavioral HDL Models}},
url = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=4475227},
year = {2008}
}
@article{UNIVERSITYOFCALIFORNIAATBERKELEY1997,
author = {{UNIVERSITY OF CALIFORNIA AT BERKELEY}},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/UNIVERSITY OF CALIFORNIA AT BERKELEY - 1997 - Vol. 1 - Ptolemy 0.7 User's Manual.pdf:pdf},
title = {{Vol. 1 - Ptolemy 0.7 User's Manual}},
url = {http://scholar.google.com/scholar?hl=en&btnG=Search&q=intitle:the+almagest#2},
year = {1997}
}
@article{Wauters1996,
author = {Wauters, P and Engels, M and Lauwereins, R and Peperstraete, J.a.},
doi = {10.1109/EMPDP.1996.500603},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Wauters, Engels, Lauwereins - 1996 - Cyclo-dynamic dataflow.pdf:pdf},
isbn = {0-8186-7376-1},
journal = {Proceedings of 4th Euromicro Workshop on Parallel and Distributed Processing},
pages = {319--326},
title = {{Cyclo-dynamic dataflow}},
url = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=500603 http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=500603},
year = {1996}
}
@article{Bernardeschi1995a,
abstract = {Data flow is a paradigm for concurrent computations in which a collection of parallel processes communicate asynchronously. For nondeterministic data flow networks many semantic models have been defined, however, it is complex to reason about the semantics of a network. In this paper, we introduce a transformation between data flow networks and the LOTOS specification language to make available theories and tools developed for process algebras for the semantic analysis based on traces of the networks. The transformation does not establish a one-to-one mapping between the traces of a data flow network and the LOTOS specification, but maps each network in a specification which usually contains more traces. The obtained system specification has the same set of traces as the corresponding network if they are finite, otherwise also non fair traces are included. Formal analysis and verification methods can still be applied to prove properties of the original data flow network, allowing in case of networks with finite traces to prove also network equivalence.},
author = {Bernardeschi, Cinzia and Bondavalli, Andrea and Simoncini, Luca},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Bernardeschi, Bondavalli - 1995 - Using process algebras for the semantic analysis of data flow networks.pdf:pdf},
issn = {09168532},
journal = {IEICE Transactions on Information and Systems},
number = {8},
pages = {959--968},
title = {{Using process algebras for the semantic analysis of data flow networks}},
url = {http://search.ieice.org/bin/summary.php?id=e78-d_8_959},
volume = {E78-D},
year = {1995}
}
@article{Davies1993,
author = {Davies, J},
title = {{Specification and proof in real time CSP}},
url = {https://www.google.com/books?hl=en&lr=&id=e-JvemxJ6rsC&oi=fnd&pg=PR11&dq=Specification+and+Proof+in+Real+Time+CSP&ots=lICXjO2om-&sig=3G0gtu9TM__ugujLCTKQPySnSww http://www.google.com/books?hl=zh-CN&lr=&id=e-JvemxJ6rsC&oi=fnd&pg=PR11&dq=Specification+and+p},
year = {1993}
}
@book{Sharp1992,
author = {Sharp, JA},
title = {{Data flow computing: theory and practice}},
url = {https://www.google.com/books?hl=en&lr=&id=dS4b3i36qsEC&oi=fnd&pg=PR7&dq=Data+Flow+Computing:+Theory+and+Practice&ots=bMSKoDT1JP&sig=X_h1UAWE4SFOnRd_b1ByTflP6_E},
year = {1992}
}
@book{Hauck2010,
author = {Hauck, S and DeHon, A},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Hauck, DeHon - 2010 - Reconfigurable computing the theory and practice of FPGA-based computation.pdf:pdf},
title = {{Reconfigurable computing: the theory and practice of FPGA-based computation}},
url = {https://www.google.com/books?hl=en&lr=&id=dYKmZy0asrsC&oi=fnd&pg=PP2&dq=Data+Flow+Computing:+Theory+and+Practice&ots=sJxV9c3E9E&sig=VBBBayIaq4tcja9Qx3SusGcWuUY},
year = {2010}
}
@misc{Kahn1974,
abstract = {In this paper, we describe a simple language for parallel programming. Its semantics is studied thoroughly. The desirable properties of this language and its deficiencies are exhibited by this theoretical study. Basic results on parallel program schemata are given. We hope in this way to make a case for a more formal (i.e. mathematical) approach to the design of languages for systems programming and the design of operating systems.},
author = {Kahn, Gilles},
booktitle = {In Information Processing'74: Proceedings of the IFIP Congress},
doi = {10.1007/BF00288686},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Gilles - 1974 - The semantics of a simple language for parallel programming.pdf:pdf;:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Gilles - 1974 - The semantics of a simple language for parallel programming(2).pdf:pdf},
isbn = {978-0-7204-2803-2},
pages = {471--475},
title = {{The semantics of a simple language for parallel programming}},
url = {http://www.tik.ee.ethz.ch/tik/education/lectures/hswcd/papers/2_KahnProcessNetworks.pdf http://www.citeulike.org/group/872/article/349829},
volume = {74},
year = {1974}
}
@article{Derrick2000,
author = {Derrick, John},
doi = {10.1002/1099-1689(200009)10:3<195::AID-STVR207>3.0.CO;2-F},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Derrick - 2000 - Concurrent and Real‐time Systems The CSP Approach. By Steve Schneider. Published by John Wiley and Sons Ltd., Chicheste.pdf:pdf},
issn = {0960-0833},
journal = {Software Testing, Verification and Reliability},
number = {3},
pages = {195--195},
title = {{Concurrent and Real-time Systems: The CSP Approach. By Steve Schneider. Published by John Wiley and Sons Ltd., Chichester, U.K., 2000. ISBN: 0-471-62373-3, 510 pages. Price: U.K. �29.95, U.S.A. $59.99, Soft Cover.}},
url = {http://onlinelibrary.wiley.com/doi/10.1002/1099-1689(200009)10:3%3C195::AID-STVR207%3E3.0.CO;2-F/abstract http://doi.wiley.com/10.1002/1099-1689%28200009%2910%3A3%3C195%3A%3AAID-STVR207%3E3.0.CO%3B2-F},
volume = {10},
year = {2000}
}
@book{Hoare1985,
author = {Hoare, C A R},
booktitle = {The origin of concurrent programming},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Hoare - 1978 - Communicating sequential processes.pdf:pdf},
isbn = {0-13-153271-5},
issn = {0001-0782},
title = {{Communicating Sequential Processes}},
url = {http://link.springer.com/chapter/10.1007/978-1-4757-3472-0_16},
year = {1985}
}
@book{Hoare1985a,
author = {Hoare, C A R},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Hoare - 1985 - Communicating sequential processes.pdf:pdf},
isbn = {0-13-153271-5},
issn = {0001-0782},
title = {{Communicating Sequential Processes}},
url = {http://fi.ort.edu.uy/innovaportal/file/20124/1/55-hoare_csp_old_article.pdf},
year = {1985}
}
@article{Nikhil2011,
abstract = {The article discusses hardware system design, examining abstracting mechanisms in hardware description languages (HDLs), standards, and behavioral semantics. The author argues that a universal HDL is needed which can be used for developing models, testing systems, and implementing details and looks at Bluespec SystemVerilog (BSV), an HDL which uses features from SystemVerilog and was inspired by the programming languages. Other topics addressed include the testing of systems-on-a-chip (SoCs) using software simulation, computation models, and the growth of hardware chip capacity according to Moore's law.},
author = {Nikhil, Rishiyur S.},
doi = {10.1145/2001269.2001284},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Nikhil - 2011 - Abstraction in Hardware System Design.pdf:pdf},
issn = {0001-0782},
journal = {Communications of the ACM},
number = {10},
pages = {36--44},
title = {{Abstraction in Hardware System Design}},
url = {http://doi.acm.org/10.1145/2001269.2001284},
volume = {54},
year = {2011}
}
@article{Wang2004,
author = {Wang, Y and Nouta, R},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Wang, Nouta - 2004 - System design methodologies–High level synthesis and a VHDL implementation of a practical scheme for UWB communicat.pdf:pdf},
title = {{System design methodologies–High level synthesis and a VHDL implementation of a practical scheme for UWB communication}},
url = {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.103.2919&rep=rep1&type=pdf},
year = {2004}
}
@article{Ptolemy,
author = {Ptolemy, In Agilent},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Ptolemy - Unknown - Chapter 9 Theory of Operation.pdf:pdf},
pages = {1--10},
title = {{Chapter 9 : Theory of Operation}}
}
@book{Areno2007,
author = {Areno, MC},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Areno - 2007 - Automated Constraint-based Hardware Architecture Generation for Reconfigurable Computing Systems.pdf:pdf},
title = {{Automated Constraint-based Hardware Architecture Generation for Reconfigurable Computing Systems}},
url = {https://www.google.com/books?hl=en&lr=&id=MTwzHGdKRK4C&oi=fnd&pg=PR3&dq=automated+constraint-based+hardware+architecture+generation+for+reconfigurable+computing+systems&ots=xpdqfZseW7&sig=GaxsKPWSjHZrdxivTXT_Zw57FA0},
year = {2007}
}
@misc{team3258oscar,
author = {Team, OscaR},
title = {{Oscar: Scala in or (2012)}}
}
@article{Malek2000,
author = {Malek, Miroslaw},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Malek - 2000 - ARITHMETIC AND LOGICAL FUNCTIONS RESTORING DIVISION ALGORITHM FOR POSITIVE INTEGERS.pdf:pdf},
number = {12},
title = {{ARITHMETIC AND LOGICAL FUNCTIONS RESTORING DIVISION ALGORITHM FOR POSITIVE INTEGERS}},
url = {www.informatik.hu-berlin.de/$\sim$rok/ca},
year = {2000}
}
@article{Widemann2014,
author = {Widemann, BT y and Lepper, M},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Widemann, Lepper - 2014 - Towards Execution of the Synchronous Functional Data-Flow Language SIG.pdf:pdf},
journal = {ifl2014.github.io},
title = {{Towards Execution of the Synchronous Functional Data-Flow Language SIG}},
url = {https://ifl2014.github.io/submissions/ifl2014_submission_7.pdf},
year = {2014}
}
@article{Lee1995,
author = {Lee, EA and Parks, TM},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Lee, Parks - 1995 - Dataflow process networks.pdf:pdf},
journal = {Proceedings of the IEEE},
title = {{Dataflow process networks}},
url = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=381846},
year = {1995}
}
@article{Benveniste2003,
abstract = { Twelve years ago, Proceedings of the IEEE devoted a special section to the synchronous languages. This paper discusses the improvements, difficulties, and successes that have occured with the synchronous languages since then. Today, synchronous languages have been established as a technology of choice for modeling, specifying, validating, and implementing real-time embedded applications. The paradigm of synchrony has emerged as an engineer-friendly design method based on mathematically sound tools.},
author = {Benveniste, Albert and Caspi, Paul and Edwards, Stephen A. and Halbwachs, Nicolas and {Le Guernic}, Paul and {De Simone}, Robert},
doi = {10.1109/JPROC.2002.805826},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Benveniste, Caspi - 2003 - The synchronous languages 12 years later.pdf:pdf},
issn = {00189219},
journal = {Proceedings of the IEEE},
keywords = {Embedded systems,Esterel,Formal methods,Lustre,Real-time systems,Signal,Synchronous languages},
number = {1},
pages = {64--83},
title = {{The synchronous languages 12 years later}},
url = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1173191},
volume = {91},
year = {2003}
}
@article{Buck1994,
author = {Buck, JT and Ha, S and Lee, EA and Messerschmitt, DG},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Buck et al. - 1994 - Ptolemy A framework for simulating and prototyping heterogeneous systems.pdf:pdf},
title = {{Ptolemy: A framework for simulating and prototyping heterogeneous systems}},
url = {http://s-space.snu.ac.kr/handle/10371/7554},
year = {1994}
}
@misc{,
title = {{VisualHDL - About THDL++}},
url = {http://visualhdl.sysprogs.org/thdlpp/},
urldate = {2016-06-01}
}
@book{Edwards2012,
author = {Edwards, SA},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Edwards - 2012 - Languages for Digital Embedded Systems.pdf:pdf},
title = {{Languages for Digital Embedded Systems}},
url = {https://www.google.com/books?hl=en&lr=&id=x1HTBwAAQBAJ&oi=fnd&pg=PR15&dq=Languages+for+Digital+Embedded+Systems&ots=tB7qIzHCvc&sig=_mzQFP9MvSHtDIt6V2dQMVa2oLA},
year = {2012}
}
@article{Lee1987a,
author = {Lee, EA and Messerschmitt, DG},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Lee, Messerschmitt - 1987 - Synchronous data flow.pdf:pdf},
journal = {Proceedings of the IEEE},
title = {{Synchronous data flow}},
url = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1458143},
year = {1987}
}
@article{Schneider2009,
author = {Schneider, K},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Schneider - 2009 - The synchronous programming language Quartz.pdf:pdf},
title = {{The synchronous programming language Quartz}},
url = {http://es.cs.uni-kl.de/publications/datarsg/Schn09.pdf},
year = {2009}
}
@article{AndreaTriossi,
author = {{Andrea Triossi}, Salvatore Orl, Ra Raffaet{\`{a}}, Frank Raiser, Thom Fr{\"{u}}hwirth},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Andrea Triossi - Unknown - Constraint-Based Hardware Synthesis.pdf:pdf},
title = {{Constraint-Based Hardware Synthesis}},
url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.174.6795}
}
@article{coussy2009guest,
author = {Coussy, Philippe and Takach, Andres},
journal = {Design & Test of Computers, IEEE},
number = {4},
pages = {4--6},
publisher = {IEEE},
title = {{Guest editors' introduction: raising the abstraction level of hardware design}},
volume = {26},
year = {2009}
}
@book{Mermet2012,
author = {Mermet, J},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Mermet - 2012 - Fundamentals and Standards in Hardware Description Languages.pdf:pdf},
title = {{Fundamentals and Standards in Hardware Description Languages}},
url = {https://www.google.com/books?hl=en&lr=&id=DBrtCAAAQBAJ&oi=fnd&pg=PA2&dq=Fundamentals+and+Standards+in+Hardware+Description+Languages&ots=H7G9X8mVRA&sig=BrIBLuqyqpAn5Pdk9d74eByRj28},
year = {2012}
}
@misc{wipliez2013beyond,
author = {Wipliez, Matthieu},
title = {{Beyond RTL: High-Level Synthesis}},
url = {https://blog.synflow.com/beyond-rtl-part-1/},
year = {2013}
}
@article{Arithmetic2003,
author = {Arithmetic, Digital and Arithmetic, Floating-point},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Arithmetic, Arithmetic - 2003 - FLOATING-POINT ARITHMETIC • Floating-point representation and dynamic range • Normalized unnormalized f.pdf:pdf},
title = {{FLOATING-POINT ARITHMETIC • Floating-point representation and dynamic range • Normalized / unnormalized formats • Values represented and their distribution • Choice of base • Representation of significand and of exponent • Rounding modes and error analysi}},
year = {2003}
}
@incollection{Cau1997,
abstract = {Funded by EPSRC Research Grant GR/K25922: A compositional approach to the specification of systems using ITL and Tempura.},
author = {Cau, A and Zedan, Hussein},
booktitle = {Proceedings of the 4th International AMAST Workshop on RealTime Systems and Concurrent and Distributed Software LNCS 1231},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Cau, Zedan - 1997 - Refining interval temporal logic specifications.pdf:pdf},
keywords = {epsrc},
pages = {79--94},
title = {{Refining interval temporal logic specifications}},
url = {http://hdl.handle.net/2086/40},
year = {1997}
}
@article{Cau1996,
author = {Cau, A and Zedan, H and Coleman, N and Moszkowski, B},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Cau et al. - 1996 - Using ITL and Tempura for large-scale specification and simulation.pdf:pdf},
journal = {pdp},
title = {{Using ITL and Tempura for large-scale specification and simulation}},
url = {http://www.computer.org/csdl/proceedings/pdp/1996/7376/00/73760493.pdf},
year = {1996}
}
@article{Stuijk2007,
abstract = {Embedded multimedia systems often run multiple time-constrained applications simultaneously. These systems use multiprocessor systems-on-chip of which it must be guaranteed that enough resources are available for each application to meet its throughput constraints. This requires a task binding and scheduling mechanism that provides timing guarantees for each application independent of other applications while taking into account the available processor space, memory and communication bandwidth. Synchronous dataflow graphs (SDFGs) are used to model time-constrained multimedia applications. They allow modeling of cyclic, multi- rate dependencies between tasks. However, existing resource allocation techniques can only deal with acyclic and/or single-rate dependencies. Dependencies in an SDFG can be expressed in single-rate form, but then the problem size may increase exponentially making resource allocation infeasible. This paper presents a new resource allocation strategy which works directly on SDFGs, building on an efficient technique to calculate throughput of a bound and scheduled SDFG. Experimental results show that the strategy is effective in terms of run-time and allocated resources.},
author = {Stuijk, S. and Basten, T. and Geilen, M. C W and Corporaal, H.},
doi = {10.1109/DAC.2007.375269},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Stuijk et al. - 2007 - Multiprocessor resource allocation for throughput-constrained synchronous dataflow graphs.pdf:pdf},
isbn = {1595936270},
issn = {0738100X},
journal = {Proceedings - Design Automation Conference},
keywords = {Mapping,Multi-processor,Synchronous dataflow,Throughput},
pages = {777--782},
title = {{Multiprocessor resource allocation for throughput-constrained synchronous dataflow graphs}},
year = {2007}
}
@article{Venkataramani2004,
author = {Venkataramani, Girish and Budiu, Mihai and Chelcea, Tiberiu},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Venkataramani, Budiu, Chelcea - 2004 - C to asynchronous dataflow circuits An end-to-end toolflow.pdf:pdf},
journal = {International Workshop on Logic Syntheiss},
title = {{C to asynchronous dataflow circuits: An end-to-end toolflow}},
url = {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.58.42&rep=rep1&type=pdf},
year = {2004}
}
@article{Colaco2004,
author = {Cola{\c{c}}o, JL and Girault, A and Hamon, G and Pouzet, M},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Cola{\c{c}}o et al. - 2004 - Towards a higher-order synchronous data-flow language.pdf:pdf},
journal = {Proceedings of the 4th ACM  {\ldots}},
title = {{Towards a higher-order synchronous data-flow language}},
url = {http://dl.acm.org/citation.cfm?id=1017792},
year = {2004}
}
@article{Lee1987b,
abstract = {Data flow is a natural paradigm for describing DSP applications for concurrent implementation on parallel hardware. Data flow programs for signal processing are directed graphs where each node represents a function and each arc represents a signal path. Synchronous data flow (SDF) is a special case of data flow (either atomic or large grain) in which the number of data samples produced or consumed by each node on each invocation is specified a priori. Nodes can be scheduled statically (at compile time) onto single or parallel programmable processors so the run-time overhead usually associated with data flow evaporates. Multiple sample rates within the same system are easily and naturally handled. Conditions for correctness of SDF graph are explained and scheduling algorithms are described for homogeneous parallel processors sharing memory. A preliminary SDF software system for automatically generating assembly language code for DSP microcomputers is described. Two new efficiency techniques are introduced, static buffering and an extension to SDF to efficiently implement conditionals.},
author = {Lee, Edward A. and Messerschmitt, David G.},
doi = {10.1109/PROC.1987.13876},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Lee, Messerschmitt - 1987 - Synchronous data flow.pdf:pdf},
isbn = {0005044804},
issn = {15582256},
journal = {Proceedings of the IEEE},
number = {9},
pages = {1235--1245},
title = {{Synchronous data flow}},
volume = {75},
year = {1987}
}
@article{Lipovski1977,
abstract = {A hardware description language can be used to describe the logic gates, the sequential machines, and the functional modules, along with their interconnection and their control, in a digital system. In a general sense, Boolean equations, logic diagrams, programrning languages, and Petri nets are hardware description languages: they can be used to describe some aspect of hardware and they have definable syntax and semantics. Specifically, what is more commonly referred to as a hardware description language is a variation of a programming language tuned to the overall needs of describing hardware. This article will discuss the rationale for using such languages in the first place, identify the problems attendant upon their proliferation, and describe the measures being taken to achieve a solution.},
author = {Lipovski, G.J.},
doi = {10.1109/C-M.1977.217740},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Lipovski - 1977 - Hardware Description Languages Voices from the Tower of Babel.pdf:pdf},
issn = {0018-9162},
journal = {Computer},
keywords = {Boolean functions,Control systems,Digital control,Digital systems,Hardware design languages,LAN interconnection,Logic gates,Logic programming,Poles and towers},
number = {6},
pages = {14--17},
title = {{Hardware Description Languages: Voices from the Tower of Babel}},
url = {http://ieeexplore.ieee.org/articleDetails.jsp?arnumber=1646515},
volume = {10},
year = {1977}
}
@article{sarkar2009lessons,
author = {Sarkar, Soujanna and Dabral, Shashank and Tiwari, Praveen K and Mitra, Raj S},
journal = {Design & Test of Computers, IEEE},
number = {4},
pages = {34--45},
publisher = {IEEE},
title = {{Lessons and experiences with high-level synthesis}},
volume = {26},
year = {2009}
}
@book{wadge1985lucid,
	title={LUCID, the dataflow programming language},
	author={Wadge, William W and Ashcroft, Edward A},
	volume={303},
	year={1985},
	publisher={Academic Press London}
}
@article{Ashcroft1985,
author = {Ashcroft, EA and Wadge, WW},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Ashcroft, Wadge - 1985 - Lucid, the dataflow programming language.pdf:pdf},
journal = {APIC studies in data processing},
title = {{Lucid, the dataflow programming language}},
url = {https://scholar.google.co.il/scholar?hl=en&q=Lucid%252C+the+dataflow+programming+language&btnG=&as_sdt=1%252C5&as_sdtp=#0#0},
year = {1985}
}
@article{Dimitrakopoulos2008,
abstract = {In this paper, a new leading-zero counter (or detector) is presented. New boolean relations for the bits of the leading-zero count are derived that allow their computation to be performed using standard carry-lookahead techniques. Using the proposed approach various design choices can be explored and different circuit topologies can be derived for the design of the leading-zero counting unit. The new circuits can be efficiently implemented either in static or in dynamic logic and require significantly less energy per operation compared to the already known architectures. The integration of the proposed leading-zero counter with the leading-zero anticipation logic is analyzed and the most efficient combination is identified. Finally, a simple yet efficient technique for handling the error of the leading-zero anticipation logic is also presented. The energy-delay behavior of the proposed circuits has been investigated using static and dynamic CMOS implementations in a 130-nm CMOS technology.},
author = {Dimitrakopoulos, Giorgos and Galanopoulos, Kostas and Mavrokefalidis, Christos and Nikolos, Dimitris},
doi = {10.1109/TVLSI.2008.2000458},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Dimitrakopoulos et al. - 2008 - Low-power leading-zero counting and anticipation logic for high-speed floating point units.pdf:pdf},
issn = {10638210},
journal = {IEEE Transactions on Very Large Scale Integration (VLSI) Systems},
keywords = {Floating-point unit,Leading-zero anticipation (LZA),Leading-zero counter (LZC),Microprocessor,Normalization},
number = {7},
pages = {837--850},
title = {{Low-power leading-zero counting and anticipation logic for high-speed floating point units}},
volume = {16},
year = {2008}
}
@article{decaluwe2004myhdl,
author = {Decaluwe, Jan},
journal = LJ,
number = {127},
publisher = {Belltown Media},
title = {{MyHDL: a python-based hardware description language}},
year = {2004}
}
@article{Kee2010,
abstract = {When designing DSP applications for implementation on field programmable gate arrays (FPGAs), it is often important to minimize consumption of limited FPGA resources while satisfying real-time performance constraints. In this paper, we develop efficient techniques to determine dataflow graph buffer sizes that guarantee throughput-optimal execution when mapping synchronous dataflow (SDF) representations of DSP applications onto FPGAs. Our techniques are based on a novel two-actor SDF graph Model (TASM), which efficiently captures the behavior and costs associated with SDF graph edges (flow-graph connections). With our proposed techniques, designers can automatically generate upper bounds on SDF graph buffer distributions that realize maximum achievable throughput performance for the corresponding applications. Furthermore, our proposed technique is characterized by low polynomial time complexity, which is useful for rapid prototyping in DSP system design.},
author = {Kee, Hojin and Bhattacharyya, Shuvra S. and Kornerup, Jacob},
doi = {10.1109/ICSAMOS.2010.5642074},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Kee, Bhattacharyya, Kornerup - 2010 - Efficient static buffering to guarantee throughput-optimal FPGA implementation of synchronous data.pdf:pdf},
isbn = {9781424479382},
journal = {Proceedings - 2010 International Conference on Embedded Computer Systems: Architectures, Modeling and Simulation, IC-SAMOS 2010},
keywords = {Buffer memory,FPGA,Signal processing systems,Synchronous dataflow,Throughput},
pages = {136--143},
title = {{Efficient static buffering to guarantee throughput-optimal FPGA implementation of synchronous dataflow graphs}},
year = {2010}
}
@misc{Duan2013,
abstract = {interval temporal logic (itl) and Petri nets are two well developed formalisms for the specification and analysis of concurrent systems. itl allows one to specify both the system design and correctness requirements within the same logic based on intervals (sequences of states). As a result, verification of system properties can be carried out by checking that the formula describing a system implies the formula describing a requirement. Petri nets, on the other hand, have action and local state based semantics which allows for a direct expression of causality aspects in system behaviour. As a result, verification of system properties can be carried out using partial order reductions or invariant based techniques. In this paper, we investigate a basic semantical link between temporal logics and compositionally defined Petri nets. In particular, we aim at providing a support for the verification of behavioural properties of Petri nets using methods and techniques developed for itl. ?? 2012 Elsevier Inc. All rights reserved.},
author = {Duan, Zhenhua and Klaudel, Hanna and Koutny, Maciej},
booktitle = {Journal of Logic and Algebraic Programming},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Duan, Klaudel, Koutny - 2013 - ITL semantics of composite Petri nets.pdf:pdf},
keywords = {Box algebra,Composition,Petri net,Semantics,itl},
title = {{ITL semantics of composite Petri nets}},
year = {2013}
}
@article{Xu2010,
abstract = {While traditional methods of designing FPGA applications have relied on schematics or HDL, much interest has been shown in C-to-FPGA tool flows that allow users to design FPGA hardware in C. We evaluate a C-to-FPGA tool flow (Impulse C) by analyzing the performance of three independent implementations of the Computed tomography (CT) filtered backprojection (FBP) algorithm developed using C, Impulse C, and VHDL respectively. In the process, we compare the design process of Impulse C versus HDL, and discuss the benefits and challenges of using Impulse C. In addition, we explore the benefits of tightly-coupled FPGA acceleration offered by the XtremeData XD1000. The results of this paper demonstrate that Impulse C designs can achieve over 61x improvement over multi-threaded software (8 threads), and close to the same performance as VHDL, while significantly reducing the design effort, and that tightly-coupled FPGA coprocessors like the XD1000 effectively overcomes the traditional communication bottleneck between CPU and FPGA.},
author = {Xu, Jimmy and Subramanian, Nikhil and Alessio, Adam and Hauck, Scott},
doi = {10.1109/FCCM.2010.33},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Xu et al. - 2010 - Impulse C vs. VHDL for accelerating tomographic reconstruction.pdf:pdf},
isbn = {9780769540566},
journal = {Proceedings - IEEE Symposium on Field-Programmable Custom Computing Machines, FCCM 2010},
pages = {171--174},
title = {{Impulse C vs. VHDL for accelerating tomographic reconstruction}},
year = {2010}
}
@article{Llena2014,
author = {Llena, Enric Morancho},
doi = {10.1109/PDP.2014.26},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Llena - 2014 - A hybrid implementation of hamming weight.pdf:pdf},
isbn = {978-1-4799-2729-6},
journal = {Proceedings - 2014 22nd Euromicro International Conference on Parallel, Distributed, and Network-Based Processing, PDP 2014},
keywords = {hamming weight,hybrid parallelism,population count},
pages = {84--92},
title = {{A hybrid implementation of hamming weight}},
year = {2014}
}
@article{Bacon2013,
	title={FPGA programming for the masses},
	author={Bacon, David F and Rabbah, Rodric and Shukla, Sunil},
	journal={Communications of the ACM},
	volume={56},
	number={4},
	pages={56--63},
	year={2013},
	publisher={ACM}
}
@article{Williamson1998,
author = {Williamson, MC},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Williamson - 1998 - Synthesis of parallel hardware implementations from synchronous dataflow graph specifications.pdf:pdf},
title = {{Synthesis of parallel hardware implementations from synchronous dataflow graph specifications}},
url = {http://ftp.task.gda.pl/site/ptolemy/www/papers/98/SDFToParallelVHDL/mwilliamsonThesis.pdf},
year = {1998}
}
@article{Rutten2000,
abstract = {In the semantics of programming, finite data types such as finite lists, have traditionally been modelled by initial algebras. Later final coalgebras were used in order to deal with infinite data types. Coalgebras, which are the dual of algebras, turned out to be suited, moreover, as models for certain types of automata and more generally, for (transition and dynamical) systems. An important property of initial algebras is that they satisfy the familiar principle of induction. Such a principle was missing for coalgebras until the work of Aczel (Non-Well-Founded sets, CSLI Leethre Notes, Vol. 14, center for the study of Languages and information, Stanford, 1988) on a theory of non-wellfounded sets, in which he introduced a proof principle nowadays called coinduction. It was formulated in terms of bisimulation, a notion originally stemming from the world of concurrent programming languages. Using the notion of coalgebra homomorphism, the definition of bisimulation on coalgebras can be shown to be formally dual to that of congruence on algebras. Thus, the three basic notions of universal algebra: algebra, homomorphism of algebras, and congruence, turn out to correspond to coalgebra, homomorphism of coalgebras, and bisimulation, respectively. In this paper, the latter are taken as the basic ingredients of a theory called universal coalgebra. Some standard results from universal algebra are reformulated (using the aforementioned correspondence) and proved for a large class of coalgebras, leading to a series of results on, e.g., the lattices of subcoalgebras and bisimulations, simple coalgebras and coinduction, and a covariety theorem for coalgebras similar to Birkhoff's variety theorem.},
author = {Rutten, Jan J M M},
doi = {10.1016/S0304-3975(00)00056-6},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Rutten - 2000 - Universal coalgebra a theory of systems.pdf:pdf},
isbn = {03043975},
issn = {0304-3975},
journal = {Theoretical Computer Science},
keywords = {Covariety,algebra,bisimulation,co-algebra,coalgebra,coinduction,congruence,dynamical system,homomorphism,induction,lts,transition system,universal algebra,universal coalgebra},
number = {1},
pages = {3--80},
title = {{Universal coalgebra: a theory of systems}},
url = {http://www.sciencedirect.com/science/article/B6V1G-419JJ44-2/2/7e665cfe15dc0b92ff569dcb9e9f6dbd%5Cnhttp://www.sciencedirect.com/science/article/pii/S0304397500000566},
volume = {249},
year = {2000}
}
@inproceedings{gajski2010input,
author = {Gajski, Dan and Austin, Todd and Svoboda, Steve},
booktitle = DAC,
title = {{What input-language is the best choice for high level synthesis (HLS)?}},
year = {2010}
}
@article{Kloos1997,
author = {Kloos, CD and Cerny, E},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Kloos, Cerny - 1997 - Hardware Description Languages and their Applications.pdf:pdf},
journal = {Springer},
title = {{Hardware Description Languages and their Applications}},
url = {http://link.springer.com/content/pdf/10.1007/978-0-387-35064-6.pdf},
year = {1997}
}
@article{Gallagher2012,
abstract = {This standard specifies five hash algorithms that can be used to generate digests of messages. The digests are used to detect whether messages have been changed since the digests were generated.},
author = {Gallagher, P},
doi = {10.6028/NIST.FIPS.180-4},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Gallagher - 2012 - Secure Hash Standard (SHS) FIPS PUB 180-4.pdf:pdf},
journal = {Processing},
number = {October},
title = {{Secure Hash Standard (SHS) FIPS PUB 180-4}},
url = {http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf%5Cnhttp://thor.info.uaic.ro/$\sim$fltiplea/CC/FIPS180-3.pdf},
volume = {FIPS PUB 1},
year = {2012}
}
@article{Addanki2013,
author = {Addanki, Purna Ramesh and Nagaratna, Venkata and Alapati, Tilak},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Addanki, Nagaratna, Alapati - 2013 - An FPGA Based High Speed IEEE - 754 Double Precision Floating Point Adder Subtractor and Multiplie.pdf:pdf},
keywords = {adder,double precision,floating point,fpga,ieee-,multiplier,subtractor},
number = {1},
pages = {61--74},
title = {{An FPGA Based High Speed IEEE - 754 Double Precision Floating Point Adder / Subtractor and Multiplier Using Verilog}},
volume = {52},
year = {2013}
}
@book{Bhattacharyya2010a,
abstract = {The currentmonolithic and lengthy scheme behind the standardization and the design of new video coding standards is becoming inappropriate to satisfy the dynamism and changing needs of the video coding community. Such a scheme and specification formalism do not enable designers to exploit the clear commonalities between the different codecs, neither at the level of the specification nor at the level of the implementation. Such a problem is one of the main reasons for the typical long time interval elapsing between the time a new idea is validated until it is implemented in consumer products as part of a worldwide standard. The analysis of this problem originated a new standard initiative within the ISO/IEC MPEG committee, called Reconfigurable Video Coding (RVC). The main idea is to develop a video coding standard that overcomes many shortcomings of the current standardization and specification process by updating and progressively incrementing a modular library of components. As the name implies, flexibility and reconfigurability are new attractive features of the RVC standard. The RVC framework is based on the usage of a new actor/dataflow oriented language called CAL for the specification of the standard library and the instantiation of the RVC decoder model. CAL dataflow models expose the intrinsic concurrency of the algorithms by employing the notions of actor programming and dataflow. This chapter gives an overview of the concepts and technologies building the standard RVC framework and the non standard tools supporting the RVC model from the instantiation and simulation of the CAL model to the software and/or hardware code synthesis.},
author = {Bhattacharyya, Shuvra S and Deprettere, Ed F and Leupers, Rainer and Takala, Jarmo},
booktitle = {Media},
doi = {10.1007/978-1-4419-6345-1},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Bhattacharyya et al. - 2010 - Handbook of Signal Processing Systems.pdf:pdf},
isbn = {9781441963444},
issn = {0277786X},
pages = {243--265},
pmid = {20152412},
title = {{Handbook of Signal Processing Systems}},
url = {http://www.springerlink.com/index/10.1007/978-1-4419-6345-1},
year = {2010}
}
@article{Caspi1992,
abstract = {This paper addresses the problem of using a dataflow language in "real-time" continuously operating systems. It shows that this raises a problem of bounded memory which can be characterized in terms of multiple input-output sequential machines, and proposes a generalization of the Ginsburg-Rose theorem in this case. Finally, it shows how these concepts have been applied in the clock calculus of the synchronous dataflow language Lustre. ?? 1992.},
author = {Caspi, Paul},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Caspi - 1992 - Clocks in dataflow languages.pdf:pdf},
journal = {Theoretical Computer Science},
number = {1},
pages = {125--140},
title = {{Clocks in dataflow languages}},
volume = {94},
year = {1992}
}
@misc{das2010fully,
author = {Das, Subhasis},
booktitle = {July 9th},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Das - 2010 - Fully Pipelined AES Core.pdf:pdf},
publisher = {OpenCores},
title = {{Fully Pipelined AES Core}},
url = {https://opencores.org/project,aes_pipe},
year = {2010}
}
@article{Dowsing1991,
author = {Dowsing, RD and Elliott, R},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Dowsing, Elliott - 1991 - A higher level of behavioural specification An example in interval temporal logic.pdf:pdf},
journal = {Microprocessing and Microprogramming},
title = {{A higher level of behavioural specification: An example in interval temporal logic}},
url = {http://www.sciencedirect.com/science/article/pii/016560749190395A},
year = {1991}
}
@book{,
abstract = {The topic areas presented within this volume focus on design environments and the applications of hardware description and modelling – including simulation, verification by correctness proofs, synthesis and test. The strong relationship between the topics of CHDL'91 and the work around the use and re-standardization of the VHDL language is also explored. The quality of this proceedings, and its significance to the academic and professional worlds is assured by the excellent technical programme here compiled.},
isbn = {1483298450},
pages = {490},
publisher = {Elsevier Science},
title = {{Computer Hardware Description Languages and their Applications: Proceedings of the IFIP WG 10.2 Tenth International Symposium on Computer Hardware Description Languages and their Applications, Marseille, France, 22-24 April 1991}},
url = {https://books.google.com/books?id=ILejBQAAQBAJ&pgis=1},
year = {2014}
}
@article{Brunette2006,
author = {Brunette, C and Talpin, JP},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Brunette, Talpin - 2006 - Modeling multi-clocked data-flow programs using the Generic Modeling Environment.pdf:pdf},
journal = {Synchronous  {\ldots}},
title = {{Modeling multi-clocked data-flow programs using the Generic Modeling Environment}},
url = {https://hal.archives-ouvertes.fr/hal-00541310/},
year = {2006}
}
@article{Paschalis2012,
author = {Paschalis, Antonis and Voyiatzis, Ioannis and Gizopoulos, Dimitris},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Paschalis, Voyiatzis, Gizopoulos - 2012 - Transactions Briefs.pdf:pdf},
number = {2},
pages = {357--361},
title = {{Transactions Briefs}},
volume = {20},
year = {2012}
}
@article{Meeus2012,
abstract = {High-level synthesis (HLS) is an increasingly popular approach in electronic design automation (EDA) that raises the abstraction level for designing digital circuits. With the increasing complexity of embedded systems, these tools are particularly relevant in embedded systems design. In this paper, we present our evaluation of a broad selection of recent HLS tools in terms of capabilities, usability and quality of results. Even though HLS tools are still lacking some maturity, they are constantly improving and the industry is now starting to adopt them into their design flows. {\textcopyright} 2012 Springer Science+Business Media, LLC.},
author = {Meeus, Wim and {Van Beeck}, Kristof and Goedem{\'{e}}, Toon and Meel, Jan and Stroobandt, Dirk},
doi = {10.1007/s10617-012-9096-8},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Meeus et al. - 2012 - An overview of today's high-level synthesis tools.pdf:pdf},
isbn = {0929-5585},
issn = {09295585},
journal = {Design Automation for Embedded Systems},
keywords = {Electronic system-level,High-level synthesis},
number = {3},
pages = {31--51},
title = {{An overview of today's high-level synthesis tools}},
volume = {16},
year = {2012}
}
@misc{tabula2014spacetime,
author = {Inc., Tabula},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Inc. - 2010 - Spacetimetextsuperscript{TM} Architecture. Time as a third dimension. White Paper.pdf:pdf},
title = {{Spacetime\textsuperscript{TM} Architecture. Time as a third dimension. White Paper}},
url = {http://www.energie-und-technik.de/fileadmin/media/whitepaper/files/164_tabulaspacetime_whitepaper.pdf},
year = {2010}
}
@inproceedings{chen2003low,
author = {Chen, Deming and Cong, Jason and Fan, Yiping},
booktitle = {Proceedings of the 2003 international symposium on Low power electronics and design},
organization = {ACM},
pages = {134--139},
title = {{Low-power high-level synthesis for FPGA architectures}},
year = {2003}
}
@misc{open2009systemc,
author = {Initiative, Open SystemC and Others},
publisher = {October},
title = {{SystemC Synthesizable Subset Draft 1.3}},
year = {2009}
}
@article{sokolov2005clockless,
author = {Sokolov, Danil and Yakovlev, Alex},
journal = {IEE Proceedings-Computers and Digital Techniques},
number = {3},
pages = {298--316},
publisher = {IET},
title = {{Clockless circuits and system synthesis}},
volume = {152},
year = {2005}
}
@article{Elliott1994,
author = {Elliott, R},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Elliott - 1994 - An exercise in formally based circuit synthesis from a behavioural specification in Interval Temporal Logic.pdf:pdf},
journal = {{\ldots} 94. System Architecture and Integration. Proceedings {\ldots}},
title = {{An exercise in formally based circuit synthesis from a behavioural specification in Interval Temporal Logic}},
url = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=390402},
year = {1994}
}
@article{Chafi2011,
abstract = {Exploiting heterogeneous parallel hardware currently requires mapping application code to multiple disparate programming models. Unfortunately, general-purpose programming models available today can yield high performance but are too low-level to be accessible to the average programmer. We propose leveraging domain-specific languages (DSLs) to map high-level application code to heterogeneous devices. To demonstrate the potential of this approach we present OptiML, a DSL for machine learning. OptiML programs are implicitly parallel and can achieve high performance on heterogeneous hardware with no modification required to the source code. For such a DSL-based approach to be tractable at large scales, better tools are required for DSL authors to simplify language creation and parallelization. To address this concern, we introduce Delite, a system designed specifically for DSLs that is both a framework for creating an implicitly parallel DSL as well as a dynamic runtime providing automated targeting to heterogeneous parallel hardware. We show that OptiML running on Delite achieves single-threaded, parallel, and GPU performance superior to explicitly parallelized MATLAB code in nearly all cases.},
author = {Chafi, Hassan and Sujeeth, Arvind K. and Brown, Kevin J. and Lee, HyoukJoong and Atreya, Anand R. and Olukotun, Kunle},
doi = {10.1145/2038037.1941561},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Chafi et al. - 2011 - A domain-specific approach to heterogeneous parallelism.pdf:pdf},
isbn = {9781450301190},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {complicate this chal-,domain-specific languages,dynamic optimizations,each with their own,emerging heterogeneous systems further,gramming models are available,offs,parallel programming,set of trade-},
number = {8},
pages = {35},
title = {{A domain-specific approach to heterogeneous parallelism}},
volume = {46},
year = {2011}
}
@article{Cong2011,
abstract = {Escalating system-on-chip design complexity is pushing the design community to raise the level of abstraction beyond register transfer level. Despite the unsuccessful adoptions of early generations of commercial high-level synthesis (HLS) systems, we believe that the tipping point for transitioning to HLS methodology is happening now, especially for field-programmable gate array (FPGA) designs. The latest generation of HLS tools has made significant progress in providing wide language coverage and robust compilation technology, platform-based modeling, advancement in core HLS algorithms, and a domain-specific approach. In this paper, we use AutoESL's AutoPilot HLS tool coupled with domain-specific system-level implementation platforms developed by Xilinx as an example to demonstrate the effectiveness of state-of-art C-to-FPGA synthesis solutions targeting multiple application domains. Complex industrial designs targeting Xilinx FPGAs are also presented as case studies, including comparison of HLS solutions versus optimized manual designs. In particular, the experiment on a sphere decoder shows that the HLS solution can achieve an 11&#x2013;31% reduction in FPGA resource usage with improved design productivity compared to hand-coded design.},
author = {Cong, Jason and Liu, Bin and Neuendorffer, Stephen and Noguera, Juanjo and Vissers, Kees and Zhang, Zhiru},
doi = {10.1109/TCAD.2011.2110592},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Cong et al. - 2011 - High-level synthesis for FPGAs From prototyping to deployment.pdf:pdf},
isbn = {0278-0070},
issn = {02780070},
journal = {IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems},
keywords = {Domain-specific design,field-programmable gate array (FPGA),high-level synthesis (HLS),quality of results (QoR)},
number = {4},
pages = {473--491},
title = {{High-level synthesis for FPGAs: From prototyping to deployment}},
volume = {30},
year = {2011}
}
@article{Kono1985,
author = {Kono, S and Aoyagi, T and Fujita, M and Tanaka, H},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Kono et al. - 1985 - Implementation of temporal logic programming language Tokio.pdf:pdf},
journal = {Logic Programming'85},
title = {{Implementation of temporal logic programming language Tokio}},
url = {http://link.springer.com/chapter/10.1007/3-540-16479-0_14},
year = {1985}
}
@misc{hofstra2012comparing,
author = {Hofstra, Matthijs},
title = {{Comparing Hardware Description Languages}},
year = {2012}
}
@article{Sutherland1989,
abstract = {The pipeline processor is a common paradigm for very high speed computing machinery. Pipeline processors provide high speed because their separate stages can operate concurrently, much as different people on a manufacturing assembly line work concurrently on material passing down the line. Although the concurrency of pipeline processors makes their design a demanding task, they can be found in graphics processors, in signal processing devices, in integrated circuit components for doing arithmetic, and in the instruction interpretation units and arithmetic operations of general purpose computing machinery. Because I plan to describe a variety of pipeline processors, I will start by suggesting names for their various forms. Pipeline processors, or more simply just pipelines, operate on data as it passes along them. The latency of a pipeline is a measure of how long it takes a single data value to pass through it. The throughput rate of a pipeline is a measure of how many data values can pass through it per unit time. Pipelines both store and process data; the storage elements and processing logic in them alternate along their length. I will describe pipelines in their complete form later, but first I will focus on their storage elements alone, stripping away all processing logic. Stripped of all processing logic, any pipeline acts like a series of storage elements through which data can pass. Pipelines can be clocked or event-driven, depending on whether their parts act in response to some widely-distributed external clock, or act independently whenever local events permit. Some pipelines are inelastic; the amount of data in them is fixed. The input rate and the output rate of an inelastic pipeline must match exactly. Stripped of any processing logic, an inelastic pipeline acts like a shift register. Other pipelines are elastic; the amount of data in them may vary. The input rate and the output rate of an elastic pipeline may differ momentarily because of internal buffering. Stripped of all processing logic, an elastic pipeline becomes a flow-through first-in-first-out memory, or FIFO. FIFOs may be clocked or event-driven; their important property is that they are elastic. I assign the name micropipeline to a particularly simple form of event-driven elastic pipeline with or without internal processing. The micro part of this name seems appropriate to me because micropipelines contain very simple circuitry, because micropipelines are useful in very short lengths, and because micropipelines are suitable for layout in microelectronic form. I have chosen micropipelines as the subject of this lecture for three reasons. First, micropipelines are simple and easy to understand. I believe that simple ideas are best, and I find beauty in the simplicity and symmetry of micropipelines. Second, I see confusion surrounding the design of FIFOs. I offer this description of micropipelines in the hope of reducing some of that confusion. The third reason I have chosen my subject addresses the limitations imposed on us by the clocked-logic conceptual framework now commonly used in the design of digital systems. I believe that this conceptual framework or mind set masks simple and useful structures like micropipelines from our thoughts, structures that are easy to design and apply given a different conceptual framework. Because micropipelines are event-driven, their simplicity is not available within the clocked-logic conceptual framework. I offer this description of micropipelines in the hope of focusing attention on an alternative transition-signalling conceptual framework. We need a new conceptual framework because the complexity of VLSI technology has now reached the point where design time and design cost often exceed fabrication time and fabrication cost. Moreover, most systems designed today are monolithic and resist mid-life improvement. The transition-signalling conceptual framework offers the opportunity to build up complex systems by hierarchical composition from simpler pieces. The resulting systems are easily modified. I believe that the transition-signalling conceptual framework has much to offer in reducing the design time and cost of complex systems and increasing their useful lifetime. I offer this description of micropipelines as an example of the transition-signalling conceptual framework. Until recently only a hardy few used the transition-signalling conceptual framework for design because it was too hard. It was nearly impossible to design the small circuits of 10 to 100 transistors that form the elemental building blocks from which complex systems are composed. Moreover, it was difficult to prove anything about the resulting compositions. In the past five years, however, much progress has been made on both fronts. Charles Molnar and his colleagues at Washington University have developed a simple way to design the small basic building blocks [9]. Martin Rem's "VLSI Club" at the Technical University of Eindhoven has been working effectively on the mathematics of event-driven systems [6, 10, 11, 19]. These emerging conceptual tools now make transition signalling a lively candidate for widespread use.},
author = {Sutherland, I. E.},
doi = {10.1145/63526.63532},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Sutherland - 1989 - Micropipelines.pdf:pdf},
issn = {0001-0782},
journal = {Communications of the ACM},
number = {6},
pages = {720--738},
title = {{Micropipelines}},
url = {http://doi.acm.org/10.1145/63526.63532%5Cnhttp://dl.acm.org/citation.cfm?doid=1283920.1283946%5Cnhttp://dl.acm.org/ft_gateway.cfm?id=63532&type=pdf%5Cnhttp://portal.acm.org/citation.cfm?id=63532%5Cnhttp://portal.acm.org/ft_gateway.cfm?id=63532&type=pdf&co},
volume = {32},
year = {1989}
}

@article{le1986signal,
	title={Signal--A data flow-oriented language for signal processing},
	author={Le Guernic, Paul and Benveniste, Albert and Bournai, Patricia and Gautier, Thierry},
	journal={IEEE Trans.\ on Acoustics, Speech, and Signal Processing},
	volume={34},
	number={2},
	pages={362--374},
	year={1986},
	publisher={IEEE}
}

@article{Widemann2011,
author = {Widemann, BT y and Lepper, M},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Widemann, Lepper - 2011 - tSig Towards Semantics for a Functional Synchronous Signal Language.pdf:pdf},
journal = {Tagungsband 16. Kolloquium {\ldots}},
title = {{tSig: Towards Semantics for a Functional Synchronous Signal Language}},
year = {2011}
}
@inproceedings{frigo2001evaluation,
author = {Frigo, Jan and Gokhale, Maya and Lavenier, Dominique},
booktitle = {Proceedings of the 2001 ACM/SIGDA ninth international symposium on Field programmable gate arrays},
organization = {ACM},
pages = {134--140},
title = {{Evaluation of the streams-C C-to-FPGA compiler: an applications perspective}},
year = {2001}
}
@misc{CxLang2014,
author = {Synflow},
title = {{Cx Language}},
url = {http://cx-lang.org/},
year = {2014}
}
@article{Sparsø2007,
abstract = {Principles of Asynchronous Circuit Design - A Systems Perspective addresses the need for an introductory text on asynchronous circuit design. Part I is an 8-chapter tutorial which addresses the most important issues for the beginner, including how to think about asynchronous systems. Part II is a 4-chapter introduction to Balsa, a freely-available synthesis system for asynchronous circuits which will enable the reader to get hands-on experience of designing high-level asynchronous systems. Part III offers a number of examples of state-of-the-art asynchronous systems to illustrate what can be built using asynchronous techniques. The examples range from a complete commercial smart card chip to complex microprocessors. The objective in writing this book has been to enable industrial designers with a background in conventional (clocked) design to be able to understand asynchronous design sufficiently to assess what it has to offer and whether it might be advantageous in their next design task.},
author = {Spars{\o}, Jens and Furber, Steve},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Spars{\o}, Furber - 2007 - Principles of asynchronous circuit design – A systems perspective.pdf:pdf},
isbn = {978-1-4757-3385-3},
journal = {Kluwer Academic Publishers, {\ldots}},
keywords = {Clocking,Hardware,Smart Card,VHDL,integrated circuit,metal-oxide-semiconductor transistor,microprocessor,single-electron transistor,static-induction transistor,tools},
pages = {337},
title = {{Principles of asynchronous circuit design – A systems perspective}},
url = {http://scholar.google.com/scholar?hl=en&btnG=Search&q=intitle:PRINCIPLES+OF+ASYNCHRONOUS+CIRCUIT+DESIGN+?+A+Systems+Perspective#1%5Cnhttp://scholar.google.com/scholar?hl=en&btnG=Search&q=intitle:Principles+of+asynchronous+circuit+design?a+systems+perspect},
year = {2007}
}
@article{Murthy2002,
author = {Murthy, PK and Lee, EA},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Murthy, Lee - 2002 - Multidimensional synchronous dataflow.pdf:pdf},
journal = {Signal Processing, IEEE Transactions on},
title = {{Multidimensional synchronous dataflow}},
url = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1018801},
year = {2002}
}
@article{McFarland1990,
abstract = {High-level synthesis systems start with an abstract behavioral specification of a digital system and find a register-transfer level structure that realizes the given behavior. In this paper we examine the high-level synthesis task, showing how it can be decomposed into a number of distinct but not independent subtasks. Then we present the techniques that have been developed for solving those subtasks. Finally, we discuss those areas related to high-level syn- thesis that are s t i l l open problems.},
author = {McFarland, M.C. and Parker, A.C. and Camposano, R.},
doi = {10.1109/5.52214},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/McFarland, Parker, Camposano - 1990 - The high-level synthesis of digital systems.pdf:pdf},
issn = {00189219},
journal = {Proceedings of the IEEE},
number = {2},
pages = {301--318},
title = {{The high-level synthesis of digital systems}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=52214},
volume = {78},
year = {1990}
}
@incollection{He2005,
abstract = {This chapter provides an introduction to Petri nets. Petri nets are an excellent formal model for studying concurrent and distributed systems and are widely applied in many different areas of computer science and other disciplines Petri nets are also extended in many different ways to study specific system properties, such as performance, reliability, and schedulability. Well-known examples of extended Petri nets include timed Petri nets and stochastic Petri nets. Petri nets are a model-oriented formal method and are well suited for modeling the dynamic behaviors of concurrent and distributed systems. Petri net specifications reveal system design structures and thus provide guidelines for system implementation. Furthermore, Petri net specifications are executable and support system simulation and testing in addition to formal analysis. This chapter presents several extensions to Petri nets based on the research work and provides analysis techniques for these extended Petri net models. It also discusses the intended applications of these extended Petri nets and their potential benefits. {\textcopyright} 2005 Copyright {\textcopyright} 2005 Elsevier Inc. All rights reserved.},
author = {He, Xudong and Murata, Tadao},
booktitle = {The Electrical Engineering Handbook},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/He, Murata - 2005 - High-Level Petri Nets-Extensions, Analysis, and Applications.pdf:pdf},
pages = {459--475},
publisher = {Elsevier Inc.},
title = {{High-Level Petri Nets-Extensions, Analysis, and Applications}},
year = {2005}
}
@inproceedings{renaudin2012tiempo,
author = {Renaudin, Marc and Fonkoua, Alain},
booktitle = ASYNC,
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Renaudin, Fonkoua - 2012 - Tiempo Asynchronous Circuits System Verilog Modeling Language.pdf:pdf},
title = {{Tiempo Asynchronous Circuits System Verilog Modeling Language}},
year = {2012}
}
@article{Widemann122015,
author = {Widemann12, BT y and Lepper, M},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Widemann12, Lepper - 2015 - Laminar data flow On the role of slicing in functional data-flow programming.pdf:pdf},
title = {{Laminar data flow: On the role of slicing in functional data-flow programming}},
url = {ftp://ftp-sop.inria.fr/indes/TFP15/TFP2015_submission_20.pdf},
year = {2015}
}
@article{martin2009high,
author = {Martin, Grant and Smith, Gary},
journal = {IEEE Design and Test of Computers},
number = {4},
pages = {18--25},
publisher = {IEEE},
title = {{High-level synthesis: Past, present, and future}},
year = {2009}
}
@misc{lundgren2014open,
author = {Lundgren, David},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Lundgren - 2014 - Double Precision Floating Point Core VHDL.pdf:pdf},
publisher = {OpenCores},
title = {{Double Precision Floating Point Core VHDL}},
url = {http://opencores.org/project,fpu_double},
year = {2014}
}
@article{TranconyWidemann2014,
abstract = {The field of declarative stream programming (discrete time, clocked synchronous, modular, data-centric) is divided between the data-flow graph paradigm favored by domain experts, and the functional reactive paradigm favored by academics. In this paper, we describe the foundations of a framework for unifying functional and data-flow styles that differs from FRP proper in significant ways: It is based on set theory to match the expectations of domain experts, and the two paradigms are reduced symmetrically to a low-level middle ground, with strongly compositional semantics. The design of the framework is derived from mathematical first principles, in particular coalgebraic coinduction and a standard relational model of stateful computation. The abstract syntax and semantics introduced here constitute the full core of a novel stream programming language.},
archivePrefix = {arXiv},
arxivId = {1406.2063},
author = {{Tranc{\'{o}}n y Widemann}, Baltasar and Lepper, Markus},
doi = {10.4204/EPTCS.153.10},
eprint = {1406.2063},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Tranc{\'{o}}n y Widemann, Lepper - 2014 - Foundations of Total Functional Data-Flow Programming.pdf:pdf},
issn = {2075-2180},
journal = {Electronic Proceedings in Theoretical Computer Science},
month = {jun},
pages = {143--167},
title = {{Foundations of Total Functional Data-Flow Programming}},
url = {http://arxiv.org/abs/1406.2063},
volume = {153},
year = {2014}
}
@article{odersky2009scala,
author = {Odersky, Martin},
journal = {EPFL Lausanne, Switzerland},
title = {{The Scala language specification, version 2.8}},
year = {2009}
}
@article{Nowick2011,
abstract = {Editor's note:Pipelining is a key element of high-performance design. Distributed synchronization is at the same time one of the key strengths and one of the major difficulties of asynchronous pipelining. It automatically provides elasticity and on-demand power consumption. This tutorial provides an overview of the best-in-class asynchronous pipelining methods that can be used to fully exploit the advantages of this design style, covering both static and dynamic logic implementations.&#x2014;Luciano Lavagno, Politecnico di Torino},
author = {Nowick, Steven M. and Singh, Montek},
doi = {10.1109/MDT.2011.71},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Nowick, Singh - 2011 - High-performance asynchronous pipelines An overview.pdf:pdf},
issn = {07407475},
journal = {IEEE Design and Test of Computers},
keywords = {asynchronous,design and test,dynamic logic,elastic circuits,latch controllers,micropipelines,pipelines},
number = {5},
pages = {8--22},
title = {{High-performance asynchronous pipelines: An overview}},
volume = {28},
year = {2011}
}
@article{Bhattacharyya2010,
author = {Bhattacharyya, SS and Deprettere, EF and Keinert, J},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Bhattacharyya, Deprettere, Keinert - 2010 - Dynamic and multidimensional dataflow graphs.pdf:pdf},
journal = {Handbook of Signal {\ldots}},
title = {{Dynamic and multidimensional dataflow graphs}},
url = {http://link.springer.com/chapter/10.1007/978-1-4419-6345-1_32},
year = {2010}
}
@book{IEEE2008,
abstract = {This standard specifies interchange and arithmetic formats and methods for binary and decimal floating-point arithmetic in computer programming environments. This standard specifies exception conditions and their default handling. An implementation of a floating-point system conforming to this standard may be realized entirely in software, entirely in hardware, or in any combination of software and hardware. For operations specified in the normative part of this standard, numerical results and exceptions are uniquely determined by the values of the input data, sequence of operations, and destination formats, all under user control.},
author = {IEEE},
booktitle = {IEEE Std 754-2008},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/IEEE - 2008 - IEEE Standard for Floating-Point Arithmetic.pdf:pdf},
isbn = {9780738157528},
issn = {01419331},
keywords = {754-2008,IEEE standard,IEEE standards,NaN,arithmetic,arithmetic formats,binary,computer,computer programming,decimal,decimal floating-point arithmetic,exponent,floating point arithmetic,floating-point,format,interchange,number,programming,rounding,significand,subnormal},
month = {Aug.},
title = {{754-2008 - IEEE Standard for Floating-Point Arithmetic}},
year = {2008}
}
@article{Bhattacharyya1996,
abstract = {From the Publisher:Software Synthesis from Dataflow Graphs addresses the problem of generating efficient software implementations\nfrom applications specified as synchronous dataflow graphs for programmable digital signal processors (DSPs) used in embedded\nreal-time systems. Software Synthesis from Dataflow Graphs reviews the state-of-the-art in constructing static, memory-optimal\nschedules for programs expressed as SDF graphs. Code size reduction is obtained by the careful organization of loops in the target\ncode. Data buffering is optimized by constructing the loop hierarchy in provably optimal ways for many classes of SDF graphs. The\ncentral result is a uniprocessor scheduling framework that provably synthesizes the most compact looping structures, called single\nappearance schedules, for a certain class of SDF graphs. In addition, algorithms and heuristics are presented that generate single\nappearance schedules optimized for data buffering usage. Numerous practical examples and extensive experimental data are provided to\nillustrate the efficacy of these techniques.},
author = {Bhattacharyya, Shuvra S and Murthy, Praveen K and Lee, Edward a},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Bhattacharyya, Murthy, Lee - 1996 - Software Synthesis from Dataflow Graphs.pdf:pdf},
pages = {192},
title = {{Software Synthesis from Dataflow Graphs}},
year = {1996}
}
@article{altera2014opencl,
author = {Altera, S D K},
journal = {Altera, Corp},
title = {{for OpenCL}},
year = {2014}
}
@article{Pouzet2010,
author = {Pouzet, Marc and Raymond, Pascal},
doi = {10.1007/s10617-010-9053-3},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Pouzet, Raymond - 2010 - Modular static scheduling of synchronous data-flow networks An efficient symbolic representation.pdf:pdf},
isbn = {9781605586274},
issn = {09295585},
journal = {Design Automation for Embedded Systems},
keywords = {Block-diagrams,Compilation,NP-completeness,Partial orders,Preorders,Real-time systems,Synchronous languages},
number = {3},
pages = {165--192},
title = {{Modular static scheduling of synchronous data-flow networks: An efficient symbolic representation}},
volume = {14},
year = {2010}
}
@article{Shafique2015,
abstract = {High performance approximate adders typically comprise of multiple smaller sub-adders, carry prediction units and error correction units. In this paper, we present a low-latency generic accuracy configurable adder to support variable approximation modes. It provides a higher number of potential configurations compared to state-of-the-art, thus enabling a high degree of design flexibility and trade-off between performance and output quality. An error correction unit is integrated to provide accurate results for cases where high accuracy is required. Furthermore, an associated scheme for error probability estimation allows convenient comparison of different approximate adder configurations without requiring the need to numerically simulate the adder. Our experimental results validate the developed error model and also the lower latency of our generic accuracy configurable adder over state-of-the-art approximate adders. For functional verification and prototyping, we have used a Xilinx Virtex-6 FPGA. Our adder model and synthesizable RTL are made open-source.},
author = {Shafique, Muhammad and Ahmad, Waqas and Hafiz, Rehan and Henkel, J{\"{o}}rg},
doi = {10.1145/2744769.2744778},
isbn = {9781450335201},
issn = {0738100X},
journal = {Proceedings of the 52nd Annual Design Automation Conference on - DAC '15},
title = {{A low latency generic accuracy configurable adder}},
year = {2015}
}
@article{Mueller1994,
author = {Mueller, W and B{\"{o}}rger, E and Gl{\"{a}}sser, U},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Mueller, B{\"{o}}rger, Gl{\"{a}}sser - 1994 - The semantics of behavioral VHDL '93 descriptions.pdf:pdf},
journal = {European Design Automation Conference},
pages = {500--505},
title = {{The semantics of behavioral VHDL '93 descriptions}},
url = {http://dl.acm.org/citation.cfm?id=198312},
year = {1994}
}
@book{kloos2012formal,
author = {{Delgado Kloos}, Carlos and Breuer, Peter T},
booktitle = {Journal of Computer and System Sciences},
file = {:C\:/Users/soronpo/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Delgado Kloos, Breuer - 1995 - Formal Semantics for VHDL.pdf:pdf},
isbn = {0792395522},
pages = {663--685},
publisher = {Springer Science & Business Media},
title = {{Formal Semantics for VHDL}},
volume = {76},
year = {1995}
}
