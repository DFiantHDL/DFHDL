package RISCV
import DFiant._

trait Proc extends DFDesign {
  ////////////////////////////////////////////////////////////////////////
  // Fetch
  ////////////////////////////////////////////////////////////////////////
  final val imem_addrToMem    = DFBits[32] <> OUT
  final val imem_dataFromMem  = DFBits[32] <> IN
  private val pcGen = new PCGen {}
  imem_addrToMem <> pcGen.pcCurrent
  ////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////
  // Decode
  ////////////////////////////////////////////////////////////////////////
  private val decoder = new Decoder {}
  private val decodedInst = decoder.decodeConn(imem_dataFromMem)
  ////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////
  // Register File (Read)
  ////////////////////////////////////////////////////////////////////////
  private val regFile = new RegFile {}
  private val rs1_data = regFile.readConn1(decodedInst.rs1_addr)
  private val rs2_data = regFile.readConn2(decodedInst.rs2_addr)
  pcGen.rs1_data <> rs1_data
  pcGen.rs2_data <> rs2_data
  pcGen.branchSel <> decoder.branchSel
  pcGen.imm <> decoder.imm
  ////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////
  // ALU (Execute)
  ////////////////////////////////////////////////////////////////////////
  private val aluOp1 = DFBits[32].matchdf(decoder.rs1OpSel)
    .casedf(RS1OpSel.RegSource) {regFile.rs1_data}
    .casedf_                    {decoder.imm}
  private val aluOp2 = DFBits[32].matchdf(decoder.rs2OpSel)
    .casedf(RS2OpSel.RegSource) {regFile.rs2_data}
    .casedf(RS2OpSel.PC)        {pcGen.pcCurrent}
    .casedf_                    {decoder.imm}
  private val alu = new ALU {}
  alu.op1 <> aluOp1
  alu.op2 <> aluOp2
  alu.shamt <> decoder.shamt
  alu.aluSel <> decoder.aluSel
  ////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////
  // Memory
  ////////////////////////////////////////////////////////////////////////
  final val dmem_addrToMem    = DFBits[32] <> OUT
  final val dmem_dataToMem    = DFBits[32] <> OUT
  final val dmem_wrenToMem    = DFBool()   <> OUT
  final val dmem_dataFromMem  = DFBits[32] <> IN
  dmem_addrToMem <> alu.out
  dmem_dataToMem <> regFile.rs2_data
  dmem_wrenToMem <> decoder.mem_wren
  ////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////
  // Write Back
  ////////////////////////////////////////////////////////////////////////
  private val wbData = DFBits[32].matchdf(decoder.wbSel)
    .casedf(WriteBackSel.ALU)     {alu.out}
    .casedf(WriteBackSel.PCPlus4) {pcGen.pcPlus4}
    .casedf_                      {dmem_dataFromMem}
  regFile.rd_data <> wbData
  regFile.rd_wren <> decoder.rd_wren
  regFile.rd_addr <> decoder.rd_addr
  ////////////////////////////////////////////////////////////////////////


}
