package DFiant

import scodec.bits._
import singleton.ops._

//trait DFEnum[E <: Enumeration#Value] extends DFAny.Val[WUnsafe, DFEnum[E],DFEnum.Var[E]] {
//  protected val enum : Enumeration
//  val width = wOF(enum.maxId)
//}
//
//object DFEnum {
//  case class Var[E <: Enumeration#Value](protected val enum : Enumeration) extends DFAny.Var[WUnsafe, DFEnum[E],DFEnum.Var[E]] with DFEnum[E] {
//    def newEmptyDFVar = copy()
//  }
//
//  def apply(enum : Enumeration) = Var[enum.Value](enum)
//}
//

trait DFEnum[E] extends DFEnum.Unbounded {
  type Enum = E
  def == (that : E) : DFBool = ???
}

object DFEnum extends DFAny.Companion {
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // Unbounded Val
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
  trait Unbounded extends DFAny.Unbounded[DFEnum.type] {
    type Enum
    type TVal = DFEnum[Enum]
    type TVar = DFEnum.Var[Enum]

  }
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////

  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // Var
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
  trait Var[E] extends DFEnum[E] with DFAny.Var {
    def := (that : E) : Unit = {}
  }
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////

  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // Public Constructors
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
  def apply[E](implicit dsn : DFDesign, width : SafeInt[EnumCount[E]]) = newVar[E]()
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////

  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // Protected Constructors
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
  protected[DFiant] def newVar[E](init : Seq[Token] = Seq())(implicit dsn : DFDesign, w : SafeInt[EnumCount[E]]) : Var[E]{type Width = w.Out} =
    new DFAny.NewVar(w, init) with Var[E] {
      type Width = w.Out
      def codeString(idRef : String) : String = s"DFEnum???"
    }
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////

  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // Token
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
  class Token private[DFiant] (val width : Int, val valueBits : BitVector, val bubbleMask : BitVector) extends DFAny.Token {
  }
  object Token {
    import DFAny.TokenSeq
  }
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////

  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // Init
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
  object Init extends Init {
    trait Able[L <: DFAny] extends DFAny.Init.Able[L]
    object Able {
      implicit class DFBitsBubble[LW](val right : Bubble) extends Able[DFBits[LW]]
      implicit class DFBitsToken[LW](val right : DFBits.Token) extends Able[DFBits[LW]]
      implicit class DFBitsTokenSeq[LW](val right : Seq[DFBits.Token]) extends Able[DFBits[LW]]

      def toTokenSeq[LW](width : Int, right : Seq[Able[DFBits[LW]]]) : Seq[DFBits.Token] =
        right.toSeqAny.map(e => e match {
          case (t : Bubble) => DFBits.Token(width, t)
          case (t : DFBits.Token) => DFBits.Token(width, t)
        })
    }
    trait Builder[L <: DFAny] extends DFAny.Init.Builder[L, Able]
    object Builder {
      implicit def ev[LW](implicit dsn : DFDesign) : Builder[DFBits[LW]] = new Builder[DFBits[LW]] {
        def apply(left : DFBits[LW], right : Seq[Able[DFBits[LW]]]) : DFBits[LW] =
          DFBits.alias(left, left.width, 0, 0, Able.toTokenSeq(left.width, right))
      }
    }
  }
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////


  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // Prev
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
  object Prev extends Prev {
    trait Builder[L <: DFAny] extends DFAny.Prev.Builder[L]
    object Builder {
//      implicit def ev[LW](implicit dsn : DFDesign) : Builder[DFBits[LW]] = new Builder[DFBits[LW]] {
//        def apply[P](left : DFBits[LW], right : Natural.Int.Checked[P]) : DFBits[LW] =
//          DFBits.alias(left, left.width, 0, -right, left.getInit)
//      }
    }
  }
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////

  object Port extends Port {

  }

  object Op extends Op {
    class Able[L](val value : L) extends DFAny.Op.Able[L]
    object Able extends super.Implicits
  }

  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // Assign
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
  object `Op:=` extends `Op:=` {

  }
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////

  object `Op==` extends `Op==` {

  }

  object `Op!=` extends `Op!=` {

  }

}