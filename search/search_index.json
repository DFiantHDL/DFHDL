{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DFiant HDL (DFHDL) Docs","text":"<p>The Official DFiant Hardware Description Language (DFHDL) Documentation</p> <p> </p> <p>Welcome to the DFiant hardware description language (DFHDL) documentation! </p> <p>DFHDL is a dataflow HDL and is embedded as a library in the Scala programming language. DFiant enables timing-agnostic and device-agnostic hardware description by using dataflow firing rules as logical constructs, coupled with modern software language features (e.g., inheritance, polymorphism, pattern matching) and classic HDL features (e.g., bit-accuracy, input/output ports). Additionally, DFHDL integrates two additional levels of hardware description abstractions: register-transfer (RT), which is equivalent to languages like Chisel and Amaranth; and event-driven (ED), which is equivalent to Verilog and VHDL. </p> <p> Get started</p> <p> Read more about the technology</p>"},{"location":"#documentation-status","title":"Documentation Status","text":"<p>We are actively working on a comprehensive user guide. We hope to be releasing it in the coming days.</p> <p>In the meanwhile, checkout our getting-started guide, to setup your system and try out a basic example. Additionally, we placed several examples under the Run In Browser section of the documentation, where you can try them right now.</p>"},{"location":"#required-knowledge","title":"Required Knowledge","text":"<p>You are not required to know Scala, yet you are expected to understand basic object oriented concepts. This documentation attempts to bridge over any syntactic gaps you may arrive at. Nonetheless, as you attempt to create more complex and generic designs, more Scala knowledge will be required of you.</p> <p>You are not required to be an FPGA/ASIC expert, yet you are expected to understand fundamental hardware description concepts found in languages such as Verilog and VHDL.  </p> <p>You are required to keep an open mind. Some of these concepts may seem strange at first, but they were set after careful thought and planning. However, we are not infallible so feel free to file an issue with questions and/or suggestions of different approaches we can take.</p>"},{"location":"about/LICENSE/","title":"License","text":"<p>Copyright (c) 2021 DFiant Inc.</p> <p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.</p> <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.</p> <p>You should have received a copy of the GNU Lesser General Public License along with this program.  If not, see https://www.gnu.org/licenses/.</p> GNU Lesser General Public License version 3 <pre><code>                   GNU LESSER GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. &lt;https://fsf.org/&gt;\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n\n  This version of the GNU Lesser General Public License incorporates\nthe terms and conditions of version 3 of the GNU General Public\nLicense, supplemented by the additional permissions listed below.\n\n  0. Additional Definitions.\n\n  As used herein, \"this License\" refers to version 3 of the GNU Lesser\nGeneral Public License, and the \"GNU GPL\" refers to version 3 of the GNU\nGeneral Public License.\n\n  \"The Library\" refers to a covered work governed by this License,\nother than an Application or a Combined Work as defined below.\n\n  An \"Application\" is any work that makes use of an interface provided\nby the Library, but which is not otherwise based on the Library.\nDefining a subclass of a class defined by the Library is deemed a mode\nof using an interface provided by the Library.\n\n  A \"Combined Work\" is a work produced by combining or linking an\nApplication with the Library.  The particular version of the Library\nwith which the Combined Work was made is also called the \"Linked\nVersion\".\n\n  The \"Minimal Corresponding Source\" for a Combined Work means the\nCorresponding Source for the Combined Work, excluding any source code\nfor portions of the Combined Work that, considered in isolation, are\nbased on the Application, and not on the Linked Version.\n\n  The \"Corresponding Application Code\" for a Combined Work means the\nobject code and/or source code for the Application, including any data\nand utility programs needed for reproducing the Combined Work from the\nApplication, but excluding the System Libraries of the Combined Work.\n\n  1. Exception to Section 3 of the GNU GPL.\n\n  You may convey a covered work under sections 3 and 4 of this License\nwithout being bound by section 3 of the GNU GPL.\n\n  2. Conveying Modified Versions.\n\n  If you modify a copy of the Library, and, in your modifications, a\nfacility refers to a function or data to be supplied by an Application\nthat uses the facility (other than as an argument passed when the\nfacility is invoked), then you may convey a copy of the modified\nversion:\n\n   a) under this License, provided that you make a good faith effort to\n   ensure that, in the event an Application does not supply the\n   function or data, the facility still operates, and performs\n   whatever part of its purpose remains meaningful, or\n\n   b) under the GNU GPL, with none of the additional permissions of\n   this License applicable to that copy.\n\n  3. Object Code Incorporating Material from Library Header Files.\n\n  The object code form of an Application may incorporate material from\na header file that is part of the Library.  You may convey such object\ncode under terms of your choice, provided that, if the incorporated\nmaterial is not limited to numerical parameters, data structure\nlayouts and accessors, or small macros, inline functions and templates\n(ten or fewer lines in length), you do both of the following:\n\n   a) Give prominent notice with each copy of the object code that the\n   Library is used in it and that the Library and its use are\n   covered by this License.\n\n   b) Accompany the object code with a copy of the GNU GPL and this license\n   document.\n\n  4. Combined Works.\n\n  You may convey a Combined Work under terms of your choice that,\ntaken together, effectively do not restrict modification of the\nportions of the Library contained in the Combined Work and reverse\nengineering for debugging such modifications, if you also do each of\nthe following:\n\n   a) Give prominent notice with each copy of the Combined Work that\n   the Library is used in it and that the Library and its use are\n   covered by this License.\n\n   b) Accompany the Combined Work with a copy of the GNU GPL and this license\n   document.\n\n   c) For a Combined Work that displays copyright notices during\n   execution, include the copyright notice for the Library among\n   these notices, as well as a reference directing the user to the\n   copies of the GNU GPL and this license document.\n\n   d) Do one of the following:\n\n       0) Convey the Minimal Corresponding Source under the terms of this\n       License, and the Corresponding Application Code in a form\n       suitable for, and under terms that permit, the user to\n       recombine or relink the Application with a modified version of\n       the Linked Version to produce a modified Combined Work, in the\n       manner specified by section 6 of the GNU GPL for conveying\n       Corresponding Source.\n\n       1) Use a suitable shared library mechanism for linking with the\n       Library.  A suitable mechanism is one that (a) uses at run time\n       a copy of the Library already present on the user's computer\n       system, and (b) will operate properly with a modified version\n       of the Library that is interface-compatible with the Linked\n       Version.\n\n   e) Provide Installation Information, but only if you would otherwise\n   be required to provide such information under section 6 of the\n   GNU GPL, and only to the extent that such information is\n   necessary to install and execute a modified version of the\n   Combined Work produced by recombining or relinking the\n   Application with a modified version of the Linked Version. (If\n   you use option 4d0, the Installation Information must accompany\n   the Minimal Corresponding Source and Corresponding Application\n   Code. If you use option 4d1, you must provide the Installation\n   Information in the manner specified by section 6 of the GNU GPL\n   for conveying Corresponding Source.)\n\n  5. Combined Libraries.\n\n  You may place library facilities that are a work based on the\nLibrary side by side in a single library together with other library\nfacilities that are not Applications and are not covered by this\nLicense, and convey such a combined library under terms of your\nchoice, if you do both of the following:\n\n   a) Accompany the combined library with a copy of the same work based\n   on the Library, uncombined with any other library facilities,\n   conveyed under the terms of this License.\n\n   b) Give prominent notice with the combined library that part of it\n   is a work based on the Library, and explaining where to find the\n   accompanying uncombined form of the same work.\n\n  6. Revised Versions of the GNU Lesser General Public License.\n\n  The Free Software Foundation may publish revised and/or new versions\nof the GNU Lesser General Public License from time to time. Such new\nversions will be similar in spirit to the present version, but may\ndiffer in detail to address new problems or concerns.\n\n  Each version is given a distinguishing version number. If the\nLibrary as you received it specifies that a certain numbered version\nof the GNU Lesser General Public License \"or any later version\"\napplies to it, you have the option of following the terms and\nconditions either of that published version or of any later version\npublished by the Free Software Foundation. If the Library as you\nreceived it does not specify a version number of the GNU Lesser\nGeneral Public License, you may choose any version of the GNU Lesser\nGeneral Public License ever published by the Free Software Foundation.\n\n  If the Library as you received it specifies that a proxy can decide\nwhether future versions of the GNU Lesser General Public License shall\napply, that proxy's public statement of acceptance of any version is\npermanent authorization for you to choose that version for the\nLibrary.\n</code></pre>"},{"location":"about/acknowledgements/","title":"Acknowledgements","text":"<p>We would like to thank the opensource community, namely the Scala community, and great many others for their work and support!</p> Previous version EU support <p>Previous version of this work (simply called \"DFiant\" at the time) has been supported by EU H2020 ICT project LEGaTO, contract #780681.</p> <p></p>"},{"location":"about/contributing/","title":"Contributing","text":"<p>We will most likely adopt the code of conduct of Django. </p> <p>This page will be updated soon.</p> <p>Our Stance on Opensource</p> <p></p> <p>We are standing on the shoulders of giants, so lets at least wipe down our feet first.   Be kind, be respectful, and take no-one and nothing for granted.</p>"},{"location":"about/release-notes/","title":"Release Notes","text":""},{"location":"about/release-notes/#v010","title":"v0.1.0","text":"<p>This is the first official version release of DFiant.</p>"},{"location":"getting-started/hello-world/","title":"Hello Hardware World","text":""},{"location":"getting-started/hello-world/#the-basic-dfhdl-program","title":"The Basic DFHDL Program","text":"<p>Since DFHDL is a Scala library, were are creating a Scala program that takes DFHDL designs and compiles (transpiles) them into lower representations (e.g., VHDL or Verilog). As such, some of DFHDL's compilation process is done statically via the Scala compiler and the rest during the Scala runtime execution. The Scala code below describes a program that runs the DFHDL compiler on an 8-bit overlapping counter design, <code>Counter8</code>. </p> <pre><code>import dfhdl.* //import all the DFHDL goodness\n\n/** Generates an 8-bit overlapping count */\nclass Counter8 extends RTDesign:\n  val cnt = UInt(8) &lt;&gt; OUT.REG init 0\n  cnt.din := cnt + 1\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Enables printing the generated chosen backend code:\ngiven options.CompilerOptions.PrintGenFiles = true\n// Uncomment to select vhdl compilation (default is verilog):\n// given options.CompilerOptions.Backend = backends.vhdl\n// Uncomment to enable printing design code before compilation (after elaboration):\n// given options.CompilerOptions.PrintDesignCodeBefore = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDesignCodeAfter = true\n// Uncomment to set different clock and reset configurations:\n// given options.CompilerOptions.DefaultClkCfg = ClkCfg(ClkCfg.Edge.Rising)\n// given options.CompilerOptions.DefaultRstCfg = RstCfg(RstCfg.Mode.Async, RstCfg.Active.Low)\n////////////////////////////////////////////////////////////////////////////////////////////////\n\n//The entry point to your compilation program starts here\n@main def main = Counter8().compile.commit\n</code></pre> <p>Writing a DFHDL compilation program \u2013 as easy as 01-10-11!</p> <ol> <li><code>import dfhdl.*</code> once per source file, to import all the required namespace objects, types, and functionality.</li> <li><code>class _design_name_ extends RTDesign:</code> to define your register-transfer (RT) domain design. Populate your design with the required interface and functionality. DFHDL supports two additional design domains: dataflow (DF), and event-driven (ED).</li> <li><code>@main def main = _design_name_().compile.commit</code> to create your compilation program entry point, instantiate the design, elaborate it, compile it to Verilog or VHDL (see compiler options), and finally commit the files to disk.</li> </ol>"},{"location":"getting-started/hello-world/#run-it-in-your-browser","title":"Run It In Your Browser","text":"Run it here <pre><code>import dfhdl.* //import all the DFHDL goodness\n\n/** Generates an 8-bit overlapping count */\nclass Counter8 extends RTDesign:\n  val cnt = UInt(8) &lt;&gt; OUT.REG init 0\n  cnt.din := cnt + 1\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Enables printing the generated chosen backend code:\ngiven options.CompilerOptions.PrintGenFiles = true\n// Uncomment to select vhdl compilation (default is verilog):\n// given options.CompilerOptions.Backend = backends.vhdl\n// Uncomment to enable printing design code before compilation (after elaboration):\n// given options.CompilerOptions.PrintDesignCodeBefore = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDesignCodeAfter = true\n// Uncomment to set different clock and reset configurations:\n// given options.CompilerOptions.DefaultClkCfg = ClkCfg(ClkCfg.Edge.Rising)\n// given options.CompilerOptions.DefaultRstCfg = RstCfg(RstCfg.Mode.Async, RstCfg.Active.Low)\n////////////////////////////////////////////////////////////////////////////////////////////////\n\n//The entry point to your compilation program starts here\n@main def main = Counter8().compile.commit</code></pre> <p>For more examples that are available to run in your browser, see the relevant section.</p>"},{"location":"getting-started/hello-world/#run-it-on-your-system","title":"Run It On Your System","text":"<p>To run this example on your system, make sure to first follow the initial setup instructions.</p> <p>You have several options to run Scala programs on your system:</p> <ul> <li>For this simple <code>Counter8</code> example, you can just use the simplest scala-cli-single-file approach. </li> <li>For common DFHDL projects, we recommend using the scala-cli project approach. </li> <li>For more complex, full-production DFHDL projects, we recommended using an sbt project.</li> </ul>"},{"location":"getting-started/hello-world/#scala-cli-single-file","title":"Scala-cli Single File","text":"<p>scala-cli single file example</p> Counter8.scala<pre><code>//&gt; using scala 3.4.0\n//&gt; using lib io.github.dfianthdl::dfhdl::0.4.3\n//&gt; using plugin io.github.dfianthdl:::dfhdl-plugin:0.4.3\n//&gt; using option -deprecation -language:implicitConversions\n\nimport dfhdl.* //import all the DFHDL goodness\n\n/** Generates an 8-bit overlapping count */\nclass Counter8 extends RTDesign:\n  val cnt = UInt(8) &lt;&gt; OUT.REG init 0\n  cnt.din := cnt + 1\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Enables printing the generated chosen backend code:\ngiven options.CompilerOptions.PrintGenFiles = true\n// Uncomment to select vhdl compilation (default is verilog):\n// given options.CompilerOptions.Backend = backends.vhdl\n// Uncomment to enable printing design code before compilation (after elaboration):\n// given options.CompilerOptions.PrintDesignCodeBefore = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDesignCodeAfter = true\n// Uncomment to set different clock and reset configurations:\n// given options.CompilerOptions.DefaultClkCfg = ClkCfg(ClkCfg.Edge.Rising)\n// given options.CompilerOptions.DefaultRstCfg = RstCfg(RstCfg.Mode.Async, RstCfg.Active.Low)\n////////////////////////////////////////////////////////////////////////////////////////////////\n\n//The entry point to your compilation program starts here\n@main def main = Counter8().compile.commit\n</code></pre> Download and run in your terminal<pre><code>curl -o Counter8.scala https://dfianthdl.github.io/getting-started/hello-world/scala-cli-single-file/Counter8.scala\nscala-cli run ./Counter8.scala\n</code></pre> <p>For more information, please consult the scala-cli documentation.</p>"},{"location":"getting-started/hello-world/#scala-cli-project","title":"Scala-cli Project","text":"<p>Scala-cli project example</p> projectFolder/project.scala<pre><code>//&gt; using scala 3.4.0\n//&gt; using lib io.github.dfianthdl::dfhdl::0.4.3\n//&gt; using plugin io.github.dfianthdl:::dfhdl-plugin:0.4.3\n//&gt; using option -deprecation -language:implicitConversions\n</code></pre> projectFolder/Counter8.scala<pre><code>import dfhdl.* //import all the DFHDL goodness\n\n/** Generates an 8-bit overlapping count */\nclass Counter8 extends RTDesign:\n  val cnt = UInt(8) &lt;&gt; OUT.REG init 0\n  cnt.din := cnt + 1\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Enables printing the generated chosen backend code:\ngiven options.CompilerOptions.PrintGenFiles = true\n// Uncomment to select vhdl compilation (default is verilog):\n// given options.CompilerOptions.Backend = backends.vhdl\n// Uncomment to enable printing design code before compilation (after elaboration):\n// given options.CompilerOptions.PrintDesignCodeBefore = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDesignCodeAfter = true\n// Uncomment to set different clock and reset configurations:\n// given options.CompilerOptions.DefaultClkCfg = ClkCfg(ClkCfg.Edge.Rising)\n// given options.CompilerOptions.DefaultRstCfg = RstCfg(RstCfg.Mode.Async, RstCfg.Active.Low)\n////////////////////////////////////////////////////////////////////////////////////////////////\n\n//The entry point to your compilation program starts here\n@main def main = Counter8().compile.commit\n</code></pre> Download and run in your terminal<pre><code>curl -o project.scala https://dfianthdl.github.io/getting-started/hello-world/scala-cli-project/project.scala\ncurl -o Counter8.scala https://dfianthdl.github.io/getting-started/hello-world/scala-cli-project/Counter8.scala\nscala-cli run .\n</code></pre> <p>For more information, please consult the scala-cli documentation.</p>"},{"location":"getting-started/hello-world/#sbt-project","title":"sbt Project","text":"<p>The best way to get started with a DFHDL sbt project, is clone our template from github:</p> Clone and run in your terminal<pre><code>git clone https://github.com/DFiantHDL/dfhdl-template\ncd dfhdl-template\nsbt run\n</code></pre> <p>For more information, please consult the sbt documentation.</p>"},{"location":"getting-started/hello-world/#recommended-scala-formatting-for-dfhdl","title":"Recommended Scala Formatting for DFHDL","text":"<p>We recommend to actively use Scalafmt, a code formatter for Scala that integrates well with your toolchain. The following setting is recommended for DFHDL designs:</p> <p>Scalafmt recommended configuration</p> projectFolder/.scalafmt.conf<pre><code>version = 3.8.1\nrunner.dialect = scala3\n\nmaxColumn = 100\nalign.tokens = [{code = \"&lt;&gt;\"}, {code = \"=\"}, {code = \"=&gt;\"}, {code = \":=\"}, {code = \":==\"}]\nrewrite.scala3.removeOptionalBraces = oldSyntaxToo\nrewrite.scala3.insertEndMarkerMinLines = 15\n\nbinPack.literalArgumentLists = true\nbinPack.literalsMinArgCount = 5\nbinPack.literalsInclude = [\".*\"]\nbinPack.literalsIncludeSimpleExpr = true\nbinPack.literalsSingleLine = false\n\nnewlines.selectChains = keep\n</code></pre> Download it via your terminal<pre><code>curl -o .scalafmt.conf https://dfianthdl.github.io/getting-started/hello-world/scala-cli-project/.scalafmt.conf\n</code></pre> <p>For more information, please consult the Scalafmt documentation.</p>"},{"location":"getting-started/initial-setup/","title":"Initial Setup","text":"<p>DFHDL is a domain specific language (DSL) library written in the Scala programming language (Scala 3.4), and as such it lets you utilize the entire Scala ecosystem, including IDEs, various tools, and other libraries. </p>"},{"location":"getting-started/initial-setup/#installing-scala-and-other-dependencies","title":"Installing Scala and Other Dependencies","text":"<p>We recommend installing Scala via Coursier:</p> <ul> <li> <p> Windows Instructions</p> ManualCMDPowershell <ol> <li> <p>Download the installer zip file.</p> </li> <li> <p>Open the zip.</p> </li> <li> <p>Double click the <code>cs-x86_64-pc-win32.exe</code> executable to extract and run Coursier setup.</p> </li> </ol> <p>Run the following in Windows command:</p> <pre><code>curl -fLo cs-x86_64-pc-win32.zip https://github.com/coursier/launchers/raw/master/cs-x86_64-pc-win32.zip\ntar -xf cs-x86_64-pc-win32.zip\nmove cs-x86_64-pc-win32.exe cs.exe\n.\\cs setup\n</code></pre> <p>Run the following in Windows Powershell:</p> <pre><code>Invoke-WebRequest -Uri \"https://github.com/coursier/launchers/raw/master/cs-x86_64-pc-win32.zip\" -OutFile \"cs-x86_64-pc-win32.zip\"\nExpand-Archive -Path \"cs-x86_64-pc-win32.zip\"\nRename-Item -Path \"cs-x86_64-pc-win32.exe\" -NewName \"cs.exe\"\nRemove-Item -Path \"cs-x86_64-pc-win32.zip\"\n.\\cs setup\n</code></pre> </li> <li> <p> Linux Instructions</p> x86-64 (aka AMD64)ARM64Other linux <p>Run the following in your shell:</p> <pre><code>curl -fL \"https://github.com/coursier/launchers/raw/master/cs-x86_64-pc-linux.gz\" | gzip -d &gt; cs\nchmod +x cs\n./cs setup\n</code></pre> <p>Run the following in your shell:</p> <pre><code>curl -fL \"https://github.com/VirtusLab/coursier-m1/releases/latest/download/cs-aarch64-pc-linux.gz\" | gzip -d &gt; cs\nchmod +x cs\n./cs setup\n</code></pre> <p> Goto Coursier's website</p> </li> <li> <p> macOS Instructions</p> via Brewaarch64 (M1,M2,...)x86-64 <p>Run the following in your shell:</p> <pre><code>brew install coursier/formulas/coursier\ncs setup\n</code></pre> <p>Run the following in your shell:</p> <pre><code>curl -fL https://github.com/VirtusLab/coursier-m1/releases/latest/download/cs-aarch64-apple-darwin.gz | gzip -d &gt; cs\nchmod +x cs\n./cs setup\n</code></pre> <p>Run the following in your shell:</p> <pre><code>curl -fL https://github.com/coursier/launchers/raw/master/cs-x86_64-apple-darwin.gz | gzip -d &gt; cs\nchmod +x cs\n./cs setup\n</code></pre> </li> <li> <p> Other OS/Instructions</p> <p>For other OS or instructions please consult the Coursier website.</p> <p> Goto Coursier's website</p> </li> </ul>"},{"location":"getting-started/initial-setup/#ide-setup","title":"IDE Setup","text":"<p>Many IDEs support Scala development. The most popular are VS Code and IntelliJ IDEA. We recommend VS Code with the Metals plugin.</p> <p>Here is a summary of relevant IDEs:</p> <ul> <li> <p> VS Code (Recommended)</p> <p> Download VS Code</p> <p> Scala Development Guide via Metals</p> </li> <li> <p> IntelliJ IDEA</p> <p> Download IntelliJ via ToolBox</p> <p> Scala Development Guide</p> </li> <li> <p> Vim</p> <p> Download Vim</p> <p> Scala Development Guide via Metals</p> </li> <li> <p> Sublime Text</p> <p> Download Sublime Text</p> <p> Scala Development Guide via Metals</p> </li> <li> <p> Emacs</p> <p> Download Emacs</p> <p> Scala Development Guide via Metals</p> </li> <li> <p> Other IDE/Instructions</p> <p> For other OS or instructions please consult the Metals website.</p> </li> </ul>"},{"location":"in-browser/1-bit-full-adder/","title":"1-Bit Full Adder","text":"<pre><code>import dfhdl.* //import all the DFHDL goodness\n\nclass FullAdder1 extends EDDesign:\n  val a, b, c_in = Bit &lt;&gt; IN\n  val sum, c_out = Bit &lt;&gt; OUT\n\n  sum &lt;&gt; (a ^ b ^ c_in)\n  c_out &lt;&gt; (a &amp;&amp; b || b &amp;&amp; c_in || c_in &amp;&amp; a)\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Enables printing the generated chosen backend code:\ngiven options.CompilerOptions.PrintGenFiles = true\n// Uncomment to select vhdl compilation (default is verilog):\n// given options.CompilerOptions.Backend = backends.vhdl\n// Uncomment to enable printing design code before compilation (after elaboration):\n// given options.CompilerOptions.PrintDesignCodeBefore = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDesignCodeAfter = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n\n//The entry point to your compilation program starts here\n@main def main = FullAdder1().compile </code></pre>"},{"location":"in-browser/alu/","title":"ALU","text":"<pre><code>import dfhdl.* //import all the DFHDL goodness\n\nenum ALUSel extends Encode:\n  case ADD, SUB, SLL, SRL, SRA, AND, OR, XOR, SLT, SLTU, COPY1\n\nclass ALU extends DFDesign:\n  val op1 = Bits(32) &lt;&gt; IN\n  val op2 = Bits(32) &lt;&gt; IN\n  val aluSel = ALUSel &lt;&gt; IN\n  val aluOut = Bits(32) &lt;&gt; OUT\n\n  private val shamt = op2(4, 0)\n\n  import ALUSel.*\n  val outCalc: Bits[32] &lt;&gt; VAL = aluSel match\n    case ADD   =&gt; op1 + op2\n    case SUB   =&gt; op1 - op2\n    case AND   =&gt; op1 &amp; op2\n    case OR    =&gt; op1 | op2\n    case XOR   =&gt; op1 ^ op2\n    case SLT   =&gt; (op1.sint &lt; op2.sint).extend\n    case SLTU  =&gt; (op1 &lt; op2).extend\n    case SLL   =&gt; op1 &lt;&lt; shamt\n    case SRL   =&gt; op1 &gt;&gt; shamt\n    case SRA   =&gt; (op1.sint &gt;&gt; shamt).bits\n    case COPY1 =&gt; op1\n    case _     =&gt; ?\n  aluOut := outCalc\nend ALU\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Enables printing the generated chosen backend code:\ngiven options.CompilerOptions.PrintGenFiles = true\n// Uncomment to select vhdl compilation (default is verilog):\n// given options.CompilerOptions.Backend = backends.vhdl\n// Uncomment to enable printing design code before compilation (after elaboration):\n// given options.CompilerOptions.PrintDesignCodeBefore = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDesignCodeAfter = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n\n//The entry point to your compilation program starts here\n@main def main = ALU().compile</code></pre>"},{"location":"in-browser/counter/","title":"Counter","text":"<pre><code>import dfhdl.* //import all the DFHDL goodness\n\nclass Counter(val width: Int &lt;&gt; CONST) extends RTDesign:\n  val en  = Bit         &lt;&gt; IN\n  val cnt = UInt(width) &lt;&gt; OUT.REG init 0\n  if (en)\n    cnt.din := cnt + 1\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Enables printing the generated chosen backend code:\ngiven options.CompilerOptions.PrintGenFiles = true\n// Uncomment to select vhdl compilation (default is verilog):\n// given options.CompilerOptions.Backend = backends.vhdl\n// Uncomment to enable printing design code before compilation (after elaboration):\n// given options.CompilerOptions.PrintDesignCodeBefore = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDesignCodeAfter = true\n// Uncomment to set different clock and reset configurations:\n// given options.CompilerOptions.DefaultClkCfg = ClkCfg(ClkCfg.Edge.Rising)\n// given options.CompilerOptions.DefaultRstCfg = RstCfg(RstCfg.Mode.Async, RstCfg.Active.Low)\n////////////////////////////////////////////////////////////////////////////////////////////////\n\n//The entry point to your compilation program starts here\n@main def main = Counter(8).compile</code></pre>"},{"location":"in-browser/led-blinker/","title":"LED Blinker","text":"<pre><code>import dfhdl.* //import all the DFHDL goodness\n\n/** This is a led blinker */\nclass Blinker(\n    val CLK_FREQ_KHz: Int &lt;&gt; CONST,\n    val LED_FREQ_Hz:  Int &lt;&gt; CONST\n) extends RTDesign:\n  /** Half-count of the toggle for 50% duty cycle */\n  val HALF_PERIOD = (CLK_FREQ_KHz * 1000) / (LED_FREQ_Hz * 2)\n\n  /** LED output */\n  val led = Bit                     &lt;&gt; OUT.REG init 1\n  val cnt = UInt.until(HALF_PERIOD) &lt;&gt; VAR.REG init 0\n  if (cnt == HALF_PERIOD - 1)\n    cnt.din := 0\n    led.din := !led\n  else cnt.din := cnt + 1\nend Blinker\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Enables printing the generated chosen backend code:\ngiven options.CompilerOptions.PrintGenFiles = true\n// Uncomment to select vhdl compilation (default is verilog):\n// given options.CompilerOptions.Backend = backends.vhdl\n// Uncomment to enable printing design code before compilation (after elaboration):\n// given options.CompilerOptions.PrintDesignCodeBefore = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDesignCodeAfter = true\n// Uncomment to set different clock and reset configurations:\n// given options.CompilerOptions.DefaultClkCfg = ClkCfg(ClkCfg.Edge.Rising)\n// given options.CompilerOptions.DefaultRstCfg = RstCfg(RstCfg.Mode.Async, RstCfg.Active.Low)\n////////////////////////////////////////////////////////////////////////////////////////////////\n\n//The entry point to your compilation program starts here\n@main def main = Blinker(CLK_FREQ_KHz = 50000, LED_FREQ_Hz = 1).compile</code></pre>"},{"location":"in-browser/lfsr/","title":"LFSR","text":"<pre><code>import dfhdl.*\n\nenum Ctrl extends Encode:\n  case Idle, Seed, Run\n\n/** Galois Linear-Feedback Shift Register\n  */\nclass LFSR(val taps: Bits[Int] &lt;&gt; CONST) extends RTDesign:\n  val ctrl = Ctrl &lt;&gt; IN\n  val seed = Bits(taps.width) &lt;&gt; IN\n  val calc = Bits(taps.width) &lt;&gt; OUT init all(1)\n\n  import Ctrl.*\n  ctrl match\n    case Idle =&gt; // do nothing\n    case Seed =&gt;\n      if (seed == all(0)) calc := all(1)\n      else calc := seed\n    case Run =&gt;\n      val tap = if (calc.reg(1)(0)) taps else b\"${taps.width}'0\"\n      calc := (calc.reg &gt;&gt; 1) ^ tap\nend LFSR</code></pre>"},{"location":"in-browser/n-bit-full-adder/","title":"N-Bit Full Adder","text":"<pre><code>import dfhdl.* //import all the DFHDL goodness\n\nclass FullAdder1 extends EDDesign:\n  val a, b, c_in = Bit &lt;&gt; IN\n  val sum, c_out = Bit &lt;&gt; OUT\n\n  sum   &lt;&gt; (a ^ b ^ c_in)\n  c_out &lt;&gt; (a &amp;&amp; b || b &amp;&amp; c_in || c_in &amp;&amp; a)\n\nclass FullAdderN(val n: Int) extends EDDesign:\n  val a, b  = Bits(n) &lt;&gt; IN\n  val c_in  = Bit     &lt;&gt; IN\n  val sum   = Bits(n) &lt;&gt; OUT\n  val c_out = Bit     &lt;&gt; OUT\n\n  val adder = List.fill(n)(FullAdder1())\n  for (i &lt;- 0 until n)\n    adder(i).a   &lt;&gt; a(i)\n    adder(i).b   &lt;&gt; b(i)\n    adder(i).sum &lt;&gt; sum(i)\n    if (i &lt; n - 1)\n      adder(i).c_out &lt;&gt; adder(i + 1).c_in\n  adder.head.c_in  &lt;&gt; c_in\n  adder.last.c_out &lt;&gt; c_out\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n// DFHDL Compiler Options:                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////\n// Enables printing the generated chosen backend code:\ngiven options.CompilerOptions.PrintGenFiles = true\n// Uncomment to select vhdl compilation (default is verilog):\n// given options.CompilerOptions.Backend = backends.vhdl\n// Uncomment to enable printing design code before compilation (after elaboration):\n// given options.CompilerOptions.PrintDesignCodeBefore = true\n// Uncomment to enable printing design code after compilation:\n// given options.CompilerOptions.PrintDesignCodeAfter = true\n////////////////////////////////////////////////////////////////////////////////////////////////\n\n//The entry point to your compilation program starts here\n@main def main = FullAdderN(4).compile</code></pre>"},{"location":"intro/first-look/","title":"DFHDL: First Look","text":"<p>Your first encounter with the DFHDL syntax, semantics and language features</p> <p>In this section we provide simple examples to demonstrate various DFHDL syntax, semantics and languages features. If you wish to understand how to run these examples yourself, please refer to the Getting Started chapter of this documentation. </p>"},{"location":"intro/first-look/#main-feature-overview","title":"Main Feature Overview","text":"<ul> <li>Concise and simple syntax</li> <li>Write portable code: target and timing agnostic dataflow hardware description</li> <li>Strong bit-accurate type-safety</li> <li>Simplified port connections</li> <li>Automatic latency path balancing</li> <li>Automatic/manual pipelining</li> <li>Meta hardware description via rich Scala language constructs</li> </ul>"},{"location":"intro/first-look/#basic-example-an-identity-function","title":"Basic Example: An Identity Function","text":"<p>Let's begin with a basic example. The dataflow design <code>ID</code> has a signed 16-bit input port <code>x</code> and a signed 16-bit output port <code>y</code>. We implemented an identity function between the input and output, meaning that for an input series \\(x_k\\) the output series shall be \\(y_k=x_k\\). Fig. 1a depicts a functional drawing of the design and Fig. 1b contains five tabs: the <code>ID.scala</code> DFHDL dataflow design <code>ID</code> class and its compiled RTL files in VHDL (v2008) and Verilog (v2001).</p> <p> Fig. 1a: Functional drawing of the dataflow design 'ID' with an input port 'x' and an output port 'y' </p> ID.scalaID.svID_defs.svID.vhdlID_pkg.vhdl <pre><code>import dfhdl.*\n\nclass ID extends DFDesign: //This our `ID` dataflow design\n  val x = SInt(16) &lt;&gt; IN  //The input port is a signed 16-bit integer\n  val y = SInt(16) &lt;&gt; OUT //The output port is a signed 16-bit integer\n  y := x //trivial direct input-to-output assignment\n</code></pre> <pre><code>`default_nettype               none\n`timescale 1ns/1ps\n`include \"ID_defs.v\"\n\n\nmodule ID(\n  input  wire signed [15:0] x,\n  output reg  signed [15:0] y\n);\n  always @(*)\n  begin\n    y                       = x;\n  end\nendmodule\n</code></pre> <pre><code>`ifndef ID_DEFS_H\n`define ID_DEFS_H\n`endif\n</code></pre> <pre><code>library ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\nuse work.ID_pkg.all;\n\nentity ID is\nport (\n  x   : in  signed(15 downto 0);\n  y   : out signed(15 downto 0)\n);\nend ID;\n\narchitecture ID_arch of ID is\nbegin\n  async_proc : process (all)\n  begin\n    y &lt;= x;\n  end process;\nend ID_arch;\n</code></pre> <pre><code>library ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\n\npackage ID_pkg is\n  function bit_reverse(s : std_logic_vector) return std_logic_vector;\n  function resize(arg : std_logic_vector; size : integer) return std_logic_vector;\n  function to_sl(b : boolean) return std_logic;\n  function to_sl(arg : std_logic_vector) return std_logic;\n  function to_slv(arg : std_logic) return std_logic_vector;\n  function to_slv(arg : unsigned) return std_logic_vector;\n  function to_slv(arg : signed) return std_logic_vector;\n  function to_slv(arg : boolean) return std_logic_vector;\nend package ID_pkg;\n\npackage body ID_pkg is\n  function bit_reverse(s : std_logic_vector) return std_logic_vector is\n     variable v_s : std_logic_vector(s'high downto s'low);\n  begin\n    for i in s'high downto s'low loop\n      v_s(i) := s(s'high - i);\n    end loop;\n    return v_s;\n  end bit_reverse;\n  function resize(arg : std_logic_vector; size : integer) return std_logic_vector is\n  begin\n    return to_slv(resize(unsigned(arg), size));\n  end resize;\n  function to_sl(b : boolean) return std_logic is\n  begin\n    if (b) then\n      return '1';\n    else\n      return '0';\n    end if;\n  end to_sl;\n  function to_sl(arg : std_logic_vector) return std_logic is\n  begin\n    return arg(arg'low);\n  end to_sl;\n  function to_slv(arg : std_logic) return std_logic_vector is\n  begin\n    if (arg = '1') then\n      return \"1\";\n    else\n      return \"0\";\n    end if;\n  end to_slv;\n  function to_slv(arg : unsigned) return std_logic_vector is\n    variable slv : std_logic_vector(arg'length-1 downto 0);\n  begin\n    slv := std_logic_vector(arg);\n    return slv;\n  end to_slv;\n  function to_slv(arg : signed) return std_logic_vector is\n    variable slv : std_logic_vector(arg'length-1 downto 0);\n  begin\n    slv := std_logic_vector(arg);\n    return slv;\n  end to_slv;\n  function to_slv(arg : boolean) return std_logic_vector is\n  begin\n    if (arg) then\n      return \"1\";\n    else\n      return \"0\";\n    end if;\n  end to_slv;\nend package body ID_pkg;\n</code></pre> <p> Fig. 1b: A DFHDL implementation of the identity function as a toplevel design and the generated VHDL/Verilog files </p> <p>The Scala code in Fig. 1b describes our ID design as a Scala class. To compile this further to RTL or simulate it we need to create a program that instantiates the class and invokes additional commands. See the getting started guide for further details. </p> <p>Defining a new dataflow design</p> <ol> <li><code>import dfhdl.*</code> once per source file.</li> <li><code>class _design_name_ extends DFDesign:</code> to define your dataflow design. Populate your design with the required dataflow functionality.</li> </ol> ID.scala line-by-line breakdown <ul> <li> <p>Line 1: The <code>import dfhdl.*</code> statement summons all the DFHDL classes, types and objects into the current scope. This is a must for every dataflow design source file.</p> </li> <li> <p>Lines 3-7: The <code>ID</code> Scala <code>class</code> is extended from the <code>DFDesign</code> (abstract) class and therefore declares it as a dataflow design. Note: in these example we use braceless syntax of Scala 3. You can use braces instead if you choose to.   </p> <ul> <li> <p>Lines 4-5: Here we construct the input port <code>x</code> and output port <code>y</code>. Both were set as a 16-bit signed integer dataflow variable via the <code>SInt(width)</code> constructor, where <code>width</code> is any positive integer. DFHDL also support various types such as <code>Bits</code>, <code>UInt</code>, and <code>Boolean</code>. All these dataflow variable construction options and more are discussed later in this documentation. The syntax <code>val _name_ = _dftype_ &lt;&gt; _modifier_</code> is used to construct a hardware port/variable and give it a named Scala reference. The Scala reference name will affect the name of this port when compiled to the required backend representation. </p> </li> <li> <p>Line 6: The assignment operator <code>:=</code> sets the dataflow output port to consume all input port tokens as they are.</p> </li> </ul> </li> </ul> ID RTL files observations <ul> <li>The ID.vhdl/ID.sv files are readable and maintain the names set in the DFHDL design. The generated files follow various writing conventions such as lowercase keywords and proper code alignment.</li> <li>The ID_pkg.vhdl is a package file that is shared between all VHDL files generated by DFHDL and contains common conversion functions that may be required. Additionally it may contain other definitions like enumeration types.</li> </ul> ID demo <pre><code>import dfhdl.*\n\nclass ID extends DFDesign: //This our `ID` dataflow design\n  val x = SInt(16) &lt;&gt; IN  //The input port is a signed 16-bit integer\n  val y = SInt(16) &lt;&gt; OUT //The output port is a signed 16-bit integer\n  y := x //trivial direct input-to-output assignment\n\n\n@main def main =\n  ID().compile.printGenFiles</code></pre>"},{"location":"intro/first-look/#hierarchy-and-connection-example","title":"Hierarchy and Connection Example","text":"<p>One of the most qualifying characteristics of hardware design is the composition of modules/entities via hierarchies and IO port connections. DFHDL is no exception and easily enables dataflow design compositions. Fig. 2a demonstrates such a composition that creates yet another identity function, but this time as a chained composition of two identity function designs. The top-level design <code>IDTop</code> introduces two instances of <code>ID</code> we saw in the previous example and connects them accordingly.</p> <p> Fig. 2a: Functional drawing of the dataflow design 'IDTop' with an input port 'x' and an output port 'y' </p> IDTop.scalaIDTop.svIDTop.vhdl <pre><code>import dfhdl.*\n\nclass IDTop extends DFDesign: // This our `IDTop` dataflow design\n  val x = SInt(16) &lt;&gt; IN // The input port is a signed 16-bit integer\n  val y = SInt(16) &lt;&gt; OUT // The output port is a signed 16-bit integer\n  val id1 = ID() // First instance of the `ID` design\n  val id2 = ID() // Second instance of the `ID` design\n  id1.x &lt;&gt; x // Connecting parent input port to child input port\n  id1.y &lt;&gt; id2.x // Connecting sibling instance ports\n  id2.y &lt;&gt; y // Connecting parent output port to child output port\n</code></pre> <pre><code>`default_nettype               none\n`timescale 1ns/1ps\n`include \"IDTop_defs.v\"\n\n\nmodule IDTop(\n  input  wire signed [15:0] x,\n  output reg  signed [15:0] y\n);\n  wire        signed [15:0] id1_y;\n  wire        signed [15:0] id2_y;\n  reg         signed [15:0] id1_x;\n  reg         signed [15:0] id2_x;\n  ID id1(\n    .x                      (id1_x),\n    .y                      (id1_y)\n  );\n  ID id2(\n    .x                      (id2_x),\n    .y                      (id2_y)\n  );\n  always @(*)\n  begin\n    id1_x                   = x;\n    id2_x                   = id1_y;\n    y                       = id2_y;\n  end\nendmodule\n</code></pre> <pre><code>library ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\nuse work.IDTop_pkg.all;\n\nentity IDTop is\nport (\n  x            : in  signed(15 downto 0);\n  y            : out signed(15 downto 0)\n);\nend IDTop;\n\narchitecture IDTop_arch of IDTop is  \n  signal id1_x : signed(15 downto 0);\n  signal id1_y : signed(15 downto 0);\n  signal id2_x : signed(15 downto 0);\n  signal id2_y : signed(15 downto 0);\nbegin\n  id1 : entity work.ID(ID_arch) port map (\n    x          =&gt; id1_x,\n    y          =&gt; id1_y\n  );\n  id2 : entity work.ID(ID_arch) port map (\n    x          =&gt; id2_x,\n    y          =&gt; id2_y\n  );\n  async_proc : process (all)\n  begin\n    id1_x      &lt;= x;\n    id2_x      &lt;= id1_y;\n    y          &lt;= id2_y;\n  end process;\nend IDTop_arch;\n</code></pre> <p> Fig. 2b: A DFHDL implementation of IDTop as a toplevel design and the generated VHDL/Verilog files </p> IDTop.scala observations <ul> <li>Lines 6-7: Instantiating and naming the two internal <code>ID</code> designs (by constructing a Scala class).</li> <li>Lines 8-10: Connecting the design ports as can be seen in the functional diagram. The <code>&lt;&gt;</code> connection operator is different than the <code>:=</code> assignment operator we saw earlier in several ways:<ol> <li>Directionality and Commutativity: The connection operation is commutative and the dataflow direction, from producer to consumer, is set according to the context in which it is used. Assignments always set the dataflow direction from right to left of the operator.</li> <li>Number of Applications: A connection to any bit can be made only once, while assignments are unlimited. Also, a bit cannot receive both a connection and an assignment.</li> <li>Initialization: A connection propagates initialization from the producer to the consumer if the consumer is not explicitly initialized (via <code>init</code>). Assignments have no effect over initialization.</li> </ol> </li> <li>Notice that connections can be made between sibling design ports as well as between parent ports to child ports.</li> <li>For more information access the connectivity section.</li> </ul> IDTop RTL files observations <ul> <li>Unlike DFHDL, RTLs do not support direct sibling module/component port connections and therefore require intermediate wires/signals to connect through. For consistency and brevity the DFHDL backend compiler always creates signals for all ports of all modules and connects them accordingly.</li> </ul> IDTop demo <pre><code>import dfhdl.*\n\nclass IDTop extends DFDesign: // This our `IDTop` dataflow design\n  val x = SInt(16) &lt;&gt; IN // The input port is a signed 16-bit integer\n  val y = SInt(16) &lt;&gt; OUT // The output port is a signed 16-bit integer\n  val id1 = ID() // First instance of the `ID` design\n  val id2 = ID() // Second instance of the `ID` design\n  id1.x &lt;&gt; x // Connecting parent input port to child input port\n  id1.y &lt;&gt; id2.x // Connecting sibling instance ports\n  id2.y &lt;&gt; y // Connecting parent output port to child output port\n\nclass ID extends DFDesign:\n  val x = SInt(16) &lt;&gt; IN  \n  val y = SInt(16) &lt;&gt; OUT \n  y := x \n\n@main def main =\n  IDTop().compile.printGenFiles</code></pre>"},{"location":"intro/first-look/#concurrency-abstraction","title":"Concurrency Abstraction","text":"<p>Concurrency and data scheduling abstractions rely heavily on language semantics. DFHDL code is expressed in a sequential manner yet employs an asynchronous dataflow programming model to enable implicit and intuitive concurrent hardware description. This is achieved by setting the data scheduling order, or token-flow, according to the data dependency: all independent dataflow expressions are scheduled concurrently, while dependent operations are synthesized into a guarded FIFO-styled pipeline. </p> \\[\\begin{aligned}     &amp;f:(i_{k},j_{k})_{k\\in \\mathbb{N}}\\rightarrow (a_k,b_k,c_k,d_k,e_k)_{k\\in \\mathbb{N}}\\\\    &amp;\\triangleq\\left\\{   \\begin{split}   a_k &amp; = i_k + 5 \\\\   b_k &amp; = a_k * 3 \\\\   c_k &amp; = a_k + b_k \\\\   d_k &amp; = i_k - 1 \\\\   e_k &amp; = j_k / 4 \\\\   \\end{split}\\right.~~~~~k\\geq 0 \\\\   \\\\   \\end{aligned}\\] <p> Fig. 4a: Functional drawing of the dataflow design 'Conc' with an input port 'x' and an output port 'y' </p> <p> ConcIN+5OUT*3-1+/4iabdcje </p> Conc.scalaConc.vhdlConc.v <pre><code>import dfhdl._\n\n@df class Conc extends DFDesign {\n  val i, j      = UInt(32) &lt;&gt; IN\n  val a,b,c,d,e = UInt(32) &lt;&gt; OUT\n  a := i + 5\n  b := a * 3\n  c := a + b\n  d := i - 1\n  e := j / 4\n}\n</code></pre> <pre><code>library ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\nuse work.Conc_pkg.all;\n\nentity Conc is\nport (\n  i   : in  unsigned(31 downto 0);\n  j   : in  unsigned(31 downto 0);\n  a   : out unsigned(31 downto 0);\n  b   : out unsigned(31 downto 0);\n  c   : out unsigned(31 downto 0);\n  d   : out unsigned(31 downto 0);\n  e   : out unsigned(31 downto 0)\n);\nend Conc;\n\narchitecture Conc_arch of Conc is\nbegin\n  async_proc : process (all)\n  begin\n    a &lt;= i + 5;\n    b &lt;= resize(a * 3, 32);\n    c &lt;= a + b;\n    d &lt;= i - 1;\n    e &lt;= j / 4;\n  end process;\nend Conc_arch;\n</code></pre> <pre><code>`default_nettype        none\n`timescale 1ns/1ps\n`include \"Conc_defs.v\"\n\n\nmodule Conc(\n  input  wire [31:0] i,\n  input  wire [31:0] j,\n  output reg  [31:0] a,\n  output reg  [31:0] b,\n  output reg  [31:0] c,\n  output reg  [31:0] d,\n  output reg  [31:0] e\n);\n  always @(*)\n  begin\n    a                = i + 5;\n    b                = a * 3;\n    c                = a + b;\n    d                = i - 1;\n    e                = j / 4;\n  end\nendmodule\n</code></pre> <p> Fig. 4b: A DFHDL implementation of Conc as a toplevel design and the generated VHDL/Verilog files </p> Conc.scala observations <ul> <li>Lines 6-7: </li> <li>For more information access the state section.</li> </ul> Conc RTL files observations <ul> <li>Bla Bla</li> </ul> Conc demo <pre><code>import dfhdl._\n\n@df class Conc extends DFDesign {\n  val i, j      = UInt(32) &lt;&gt; IN\n  val a,b,c,d,e = UInt(32) &lt;&gt; OUT\n  a := i + 5\n  b := a * 3\n  c := a + b\n  d := i - 1\n  e := j / 4\n}\n\nobject ConcApp extends App {\n  import dfhdl.compiler.backend.verilog.v2001\n  val conc = new Conc\n  conc.compile.printGenFiles(colored = false)\n}</code></pre>"},{"location":"intro/first-look/#state-abstraction","title":"State Abstraction","text":"<p>So far, all the examples were pure (stateless) functions, whereas frequently in hardware we need to express a state. A state is needed when a design must access (previous) values that are no longer (or never were) available on its input. DFHDL assumes every dataflow variable is a token stream and provides constructs to initialize the token history via the <code>init</code> construct, reuse tokens via the <code>.prev</code> construct, and update the state via the assignment <code>:=</code> construct. </p> <p>Here we provide various implementations of a simple moving average (SMA); all have a 4-tap average window of a 16-bit integer input and output a 16-bit integer average. With regards to overflow avoidance and precision loss, DFHDL is no different than any other HDL, and we took those into account when we selected our operators and declared the variable widths. Via the SMA examples we can differentiate between two kinds of state: a derived state, and a commit state. </p>"},{"location":"intro/first-look/#derived-state-sma","title":"Derived State SMA","text":"<p>Derived State</p> <p>A derived (feedforward) state is a state whose current output value is independent of its previous value. For example, checking if a dataflow stream value has changed requires reusing the previous token and comparing to the current token. </p>"},{"location":"intro/first-look/#trivial-three-adder-sma-implementation","title":"Trivial three-adder SMA implementation","text":"<p>The trivial derived state SMA implementation comes from the basic SMA formula:</p> \\[ y_k=\\left(x_k+x_{k-1}+x_{k-2}+x_{k-3}\\right)/4~~~~x_{i&lt;0}=0 \\] <p>As can be seen from the formula, we need 3 state elements to match the maximum <code>x</code> history access. Fortunately, state creation is implicit in DFHDL. Just by calling <code>x.prev(_step_)</code> to access the history of <code>x</code> we construct  <code>_step_</code> number of states and chain them, as can be seen in Fig. 3 (DFHDL automatically merges the same states constructed from several calls). </p> <p> Fig. 3a: Functional drawing of the dataflow design 'SMA_DS' with an input port 'x' and an output port 'y' </p> SMA_DS.scalaSMA_DS.vhdlSMA_DS.v <pre><code>import dfhdl._\n\n@df class SMA_DS extends DFDesign {\n  val x   = SInt(16) &lt;&gt; IN init 0\n  val y   = SInt(16) &lt;&gt; OUT\n  val s0  = x +^ x.prev\n  val s2  = x.prev(2) +^ x.prev(3)\n  val sum = s0 +^ s2\n  y       := (sum / 4).resize(16)\n}\n</code></pre> <pre><code>library ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\nuse work.SMA_DS_pkg.all;\n\nentity SMA_DS is\nport (\n  clk                : in  std_logic;\n  rst                : in  std_logic;\n  x                  : in  signed(15 downto 0) := 16d\"0\";\n  y                  : out signed(15 downto 0)\n);\nend SMA_DS;\n\narchitecture SMA_DS_arch of SMA_DS is  \n  signal x_prev1     : signed(15 downto 0) := 16d\"0\";\n  signal x_prev2     : signed(15 downto 0) := 16d\"0\";\n  signal x_prev3     : signed(15 downto 0) := 16d\"0\";\n  signal x_prev1_sig : signed(15 downto 0);\n  signal x_prev2_sig : signed(15 downto 0);\nbegin\n  async_proc : process (all)  \n    variable s0      : signed(16 downto 0);\n    variable s2      : signed(16 downto 0);\n    variable sum     : signed(17 downto 0);\n  begin\n    s0               := resize(x, 17) + x_prev1;\n    s2               := resize(x_prev2, 17) + x_prev3;\n    sum              := resize(s0, 18) + s2;\n    x_prev1_sig      &lt;= x_prev1;\n    x_prev2_sig      &lt;= x_prev2;\n    y                &lt;= resize(sum / 4, 16);\n  end process;\n  sync_proc : process (rst, clk)\n  begin\n    if rst = '0' then\n      x_prev1        &lt;= 16d\"0\";\n      x_prev2        &lt;= 16d\"0\";\n      x_prev3        &lt;= 16d\"0\";\n    elsif rising_edge(clk) then\n      x_prev1        &lt;= x;\n      x_prev2        &lt;= x_prev1_sig;\n      x_prev3        &lt;= x_prev2_sig;\n    end if;\n  end process;\nend SMA_DS_arch;\n</code></pre> <pre><code>`default_nettype               none\n`timescale 1ns/1ps\n`include \"SMA_DS_defs.v\"\n\n\nmodule SMA_DS(\n  input  wire               clk,\n  input  wire               rst,\n  input  wire signed [15:0] x,\n  output reg  signed [15:0] y\n);\n  reg         signed [15:0] x_prev1 = 16'sd0;\n  reg         signed [15:0] x_prev2 = 16'sd0;\n  reg         signed [15:0] x_prev3 = 16'sd0;\n  reg         signed [16:0] s0;\n  reg         signed [16:0] s2;\n  reg         signed [17:0] sum;\n  reg         signed [17:0] y_part;\n  reg         signed [15:0] x_prev1_sig;\n  reg         signed [15:0] x_prev2_sig;\n  always @(*)\n  begin\n    s0                      = ({x[15], x[15:0]}) + x_prev1;\n    s2                      = ({x_prev2[15], x_prev2[15:0]}) + x_prev3;\n    sum                     = ({s0[16], s0[16:0]}) + s2;\n    y_part                  = sum / 4;\n    x_prev1_sig             = x_prev1;\n    x_prev2_sig             = x_prev2;\n    y                       = {y_part[17], y_part[14:0]};\n  end\n  always @(negedge rst or posedge clk)\n  begin\n    if (rst == 1'b0) \n    begin\n      x_prev1               &lt;= 16'sd0;\n      x_prev2               &lt;= 16'sd0;\n      x_prev3               &lt;= 16'sd0;\n    end\n    else \n    begin\n      x_prev1               &lt;= x;\n      x_prev2               &lt;= x_prev1_sig;\n      x_prev3               &lt;= x_prev2_sig;\n    end\n  end\nendmodule\n</code></pre> <p> Fig. 3b: A DFHDL implementation of SMA_DS as a toplevel design and the generated VHDL/Verilog files </p> SMA_DS.scala observations <ul> <li>Line 4: The SMA forumla defines the history of <code>x</code> is at the start of the system (all values are considered to be <code>0</code>). We apply this information by initializing the <code>x</code> history via <code>init 0</code>. </li> <li>Lines 6-7: Accessing the history of <code>x</code> is done via <code>.prev(_step_)</code>, where <code>_step_</code> is a constant positive integer that defines the number of steps into history we require to retrieve the proper value.</li> <li>Lines 6-8: To avoid overflow we chose the <code>+^</code> carry-addition operator, meaning that <code>s0</code> and <code>s2</code> are 17-bit wide, and <code>sum</code> is 18-bit wide.</li> <li>Line 9: The <code>sum/4</code> division result keeps the LHS 18-bit width. To assign this value to the output <code>y</code> which is 16-bit wide, we must resize it first, via <code>.resize</code>. DFHDL has strong bit-accurate type-safety, and it does not allow assigning a wider value to a narrower value without explicit resizing. In the following animated figure we show what happens if we did not resize the value.   The Scala presentation compiler is able to interact with the editor and a custom message is presented due to the DFHDL type-safe checks.</li> <li>The various dataflow type inference and operator safety rules are discussed at the type-system section.</li> <li>For more information on state and initialization access the this section.</li> </ul> SMA_DS RTL files observations <ul> <li>This is often where a language like verilog falls short and relies on external linting  </li> </ul> SMA_DS demo <pre><code>import dfhdl._\n\n@df class SMA_DS extends DFDesign {\n  val x   = SInt(16) &lt;&gt; IN init 0\n  val y   = SInt(16) &lt;&gt; OUT\n  val s0  = x +^ x.prev\n  val s2  = x.prev(2) +^ x.prev(3)\n  val sum = s0 +^ s2\n  y       := (sum / 4).resize(16)\n}\n\nobject SMA_DSApp extends App {\n  import dfhdl.compiler.backend.verilog.v2001\n  val sma = new SMA_DS\n  sma.compile.printGenFiles(colored = false)\n}</code></pre>"},{"location":"intro/first-look/#two-adder-sma-implementation","title":"Two-adder SMA implementation","text":"<p>The following algebraic manipulation reveals how we can achieve the same function with just two adders.</p> \\[\\begin{eqnarray}  s_{0,k} &amp;=&amp; x_k+x_{k-1} \\\\ s_{2,k} &amp;=&amp; x_{k-2}+x_{k-3} = \\left.\\left (x_t+x_{t-1}  \\right )\\right|_{t=k-2} = s_{0,k-2} \\\\ y_k &amp;=&amp; \\left(s_{0,k}+s_{2,k}\\right)/4~~~~x_{i&lt;0}=0 \\end{eqnarray}\\] <p>Instead of relying only on the history of <code>x</code>, we can utilize the history of <code>s0</code> to produce <code>s2</code>. DFHDL has time invariant history access through basic operators like addition, so <code>(x +^ x.prev).prev(2)</code> is equivalent to <code>x.prev(2) +^ x.prev(3)</code>. </p> <p> Fig. 4a: Functional drawing of the dataflow design 'SMA_DS2' with an input port 'x' and an output port 'y' </p> SMA_DS2.scalaSMA_DS2.vhdlSMA_DS2.v <pre><code>import dfhdl._\n\n@df class SMA_DS2 extends DFDesign {\n  val x   = SInt(16) &lt;&gt; IN init 0\n  val y   = SInt(16) &lt;&gt; OUT\n  val s0  = x +^ x.prev\n  val s2  = s0.prev(2)\n  val sum = s0 +^ s2\n  y       := (sum / 4).resize(16)\n}\n</code></pre> <pre><code>library ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\nuse work.SMA_DS2_pkg.all;\n\nentity SMA_DS2 is\nport (\n  clk                 : in  std_logic;\n  rst                 : in  std_logic;\n  x                   : in  signed(15 downto 0) := 16d\"0\";\n  y                   : out signed(15 downto 0)\n);\nend SMA_DS2;\n\narchitecture SMA_DS2_arch of SMA_DS2 is  \n  signal x_prev1      : signed(15 downto 0) := 16d\"0\";\n  signal s0_prev1     : signed(16 downto 0) := 17d\"0\";\n  signal s2           : signed(16 downto 0) := 17d\"0\";\n  signal s0_sig       : signed(16 downto 0);\n  signal s0_prev1_sig : signed(16 downto 0);\nbegin\n  async_proc : process (all)  \n    variable s0       : signed(16 downto 0);\n    variable sum      : signed(17 downto 0);\n  begin\n    s0                := resize(x, 17) + x_prev1;\n    sum               := resize(s0, 18) + s2;\n    s0_sig            &lt;= s0;\n    s0_prev1_sig      &lt;= s0_prev1;\n    y                 &lt;= resize(sum / 4, 16);\n  end process;\n  sync_proc : process (rst, clk)\n  begin\n    if rst = '0' then\n      x_prev1         &lt;= 16d\"0\";\n      s0_prev1        &lt;= 17d\"0\";\n      s2              &lt;= 17d\"0\";\n    elsif rising_edge(clk) then\n      x_prev1         &lt;= x;\n      s0_prev1        &lt;= s0_sig;\n      s2              &lt;= s0_prev1_sig;\n    end if;\n  end process;\nend SMA_DS2_arch;\n</code></pre> <pre><code>`default_nettype               none\n`timescale 1ns/1ps\n`include \"SMA_DS2_defs.v\"\n\n\nmodule SMA_DS2(\n  input  wire               clk,\n  input  wire               rst,\n  input  wire signed [15:0] x,\n  output reg  signed [15:0] y\n);\n  reg         signed [15:0] x_prev1 = 16'sd0;\n  reg         signed [16:0] s0;\n  reg         signed [16:0] s0_prev1 = 17'sd0;\n  reg         signed [16:0] s2 = 17'sd0;\n  reg         signed [17:0] sum;\n  reg         signed [17:0] y_part;\n  reg         signed [16:0] s0_sig;\n  reg         signed [16:0] s0_prev1_sig;\n  always @(*)\n  begin\n    s0                      = ({x[15], x[15:0]}) + x_prev1;\n    sum                     = ({s0[16], s0[16:0]}) + s2;\n    y_part                  = sum / 4;\n    s0_sig                  = s0;\n    s0_prev1_sig            = s0_prev1;\n    y                       = {y_part[17], y_part[14:0]};\n  end\n  always @(negedge rst or posedge clk)\n  begin\n    if (rst == 1'b0) \n    begin\n      x_prev1               &lt;= 16'sd0;\n      s0_prev1              &lt;= 17'sd0;\n      s2                    &lt;= 17'sd0;\n    end\n    else \n    begin\n      x_prev1               &lt;= x;\n      s0_prev1              &lt;= s0_sig;\n      s2                    &lt;= s0_prev1_sig;\n    end\n  end\nendmodule\n</code></pre> <p> Fig. 4b: A DFHDL implementation of SMA_DS2 as a toplevel design and the generated VHDL/Verilog files </p> SMA_DS2.scala observations <ul> <li>Lines 6-7: </li> <li>For more information access the state section.</li> </ul> SMA_DS2 RTL files observations <ul> <li>Bla Bla</li> </ul> SMA_DS2 demo <pre><code>import dfhdl._\n\n@df class SMA_DS2 extends DFDesign {\n  val x   = SInt(16) &lt;&gt; IN init 0\n  val y   = SInt(16) &lt;&gt; OUT\n  val s0  = x +^ x.prev\n  val s2  = s0.prev(2)\n  val sum = s0 +^ s2\n  y       := (sum / 4).resize(16)\n}\n\nobject SMA_DS2App extends App {\n  import dfhdl.compiler.backend.verilog.v2001\n  val sma = new SMA_DS2\n  sma.compile.printGenFiles(colored = false)\n}</code></pre>"},{"location":"intro/first-look/#commit-state-sma","title":"Commit State SMA","text":"<p>Commit State</p> <p>A commit (feedback) state is a state whose current output value is dependent on its previous state value. For example, a cumulative sum function output value is dependent on its previous sum output value. </p> \\[\\begin{eqnarray}  a_0 &amp;=&amp; 0 \\\\ a_k &amp;=&amp; a_{k-1} - x_{k-4}+x_k \\\\ y_k &amp;=&amp; a_k/4 \\end{eqnarray}\\] SMA_CS.scalaSMA_CS.vhdlSMA_CS.v <pre><code>import dfhdl._\n\n@df class SMA_CS extends DFDesign {\n  val x   = SInt(16) &lt;&gt; IN init 0\n  val y   = SInt(16) &lt;&gt; OUT\n  val acc = SInt(18) &lt;&gt; VAR init 0\n  acc := acc - x.prev(4) + x\n  y   := (acc / 4).resize(16)\n}\n</code></pre> <pre><code>library ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\nuse work.SMA_CS_pkg.all;\n\nentity SMA_CS is\nport (\n  clk                : in  std_logic;\n  rst                : in  std_logic;\n  x                  : in  signed(15 downto 0) := 16d\"0\";\n  y                  : out signed(15 downto 0)\n);\nend SMA_CS;\n\narchitecture SMA_CS_arch of SMA_CS is  \n  signal x_prev1     : signed(15 downto 0) := 16d\"0\";\n  signal x_prev2     : signed(15 downto 0) := 16d\"0\";\n  signal x_prev3     : signed(15 downto 0) := 16d\"0\";\n  signal x_prev4     : signed(15 downto 0) := 16d\"0\";\n  signal acc_prev1   : signed(17 downto 0) := 18d\"0\";\n  signal x_prev1_sig : signed(15 downto 0);\n  signal x_prev2_sig : signed(15 downto 0);\n  signal x_prev3_sig : signed(15 downto 0);\n  signal acc_sig     : signed(17 downto 0);\nbegin\n  async_proc : process (all)  \n    variable acc     : signed(17 downto 0);\n  begin\n    acc              := acc_prev1;\n    acc              := (acc - x_prev4) + x;\n    x_prev1_sig      &lt;= x_prev1;\n    x_prev2_sig      &lt;= x_prev2;\n    x_prev3_sig      &lt;= x_prev3;\n    acc_sig          &lt;= acc;\n    y                &lt;= resize(acc / 4, 16);\n  end process;\n  sync_proc : process (rst, clk)\n  begin\n    if rst = '0' then\n      x_prev1        &lt;= 16d\"0\";\n      x_prev2        &lt;= 16d\"0\";\n      x_prev3        &lt;= 16d\"0\";\n      x_prev4        &lt;= 16d\"0\";\n      acc_prev1      &lt;= 18d\"0\";\n    elsif rising_edge(clk) then\n      x_prev1        &lt;= x;\n      x_prev2        &lt;= x_prev1_sig;\n      x_prev3        &lt;= x_prev2_sig;\n      x_prev4        &lt;= x_prev3_sig;\n      acc_prev1      &lt;= acc_sig;\n    end if;\n  end process;\nend SMA_CS_arch;\n</code></pre> <pre><code>`default_nettype               none\n`timescale 1ns/1ps\n`include \"SMA_CS_defs.v\"\n\n\nmodule SMA_CS(\n  input  wire               clk,\n  input  wire               rst,\n  input  wire signed [15:0] x,\n  output reg  signed [15:0] y\n);\n  reg         signed [15:0] x_prev1 = 16'sd0;\n  reg         signed [15:0] x_prev2 = 16'sd0;\n  reg         signed [15:0] x_prev3 = 16'sd0;\n  reg         signed [15:0] x_prev4 = 16'sd0;\n  reg         signed [17:0] acc;\n  reg         signed [17:0] acc_prev1 = 18'sd0;\n  reg         signed [17:0] y_part;\n  reg         signed [15:0] x_prev1_sig;\n  reg         signed [15:0] x_prev2_sig;\n  reg         signed [15:0] x_prev3_sig;\n  reg         signed [17:0] acc_sig;\n  always @(*)\n  begin\n    acc                     = acc_prev1;\n    acc                     = (acc - x_prev4) + x;\n    y_part                  = acc / 4;\n    x_prev1_sig             = x_prev1;\n    x_prev2_sig             = x_prev2;\n    x_prev3_sig             = x_prev3;\n    acc_sig                 = acc;\n    y                       = {y_part[17], y_part[14:0]};\n  end\n  always @(negedge rst or posedge clk)\n  begin\n    if (rst == 1'b0) \n    begin\n      x_prev1               &lt;= 16'sd0;\n      x_prev2               &lt;= 16'sd0;\n      x_prev3               &lt;= 16'sd0;\n      x_prev4               &lt;= 16'sd0;\n      acc_prev1             &lt;= 18'sd0;\n    end\n    else \n    begin\n      x_prev1               &lt;= x;\n      x_prev2               &lt;= x_prev1_sig;\n      x_prev3               &lt;= x_prev2_sig;\n      x_prev4               &lt;= x_prev3_sig;\n      acc_prev1             &lt;= acc_sig;\n    end\n  end\nendmodule\n</code></pre>"},{"location":"intro/first-look/#finite-step-state-machine-fsm-example","title":"Finite Step (State) Machine (FSM) Example","text":"SeqDet.scalaSeqDet.vhdlSeqDet.v <pre><code>import dfhdl._\n\n@df class SeqDet extends DFDesign {\n  val seqIn  = Bit &lt;&gt; IN\n  val detOut = Bit &lt;&gt; OUT\n  @df def detStep(\n    out : Int, trueNS : =&gt; FSM, falseNS : =&gt; FSM\n  ) : FSM = FSM {\n    detOut := out\n    ifdf(seqIn){\n      trueNS.goto()\n    }.elsedf {\n      falseNS.goto()\n    }\n  }\n  val S0     : FSM = detStep(0, S1, S0)\n  val S1     : FSM = detStep(0, S1, S10)\n  val S10    : FSM = detStep(0, S1, S100)\n  val S100   : FSM = detStep(0, S1001, S0)\n  val S1001  : FSM = detStep(1, S1, S10)\n}\n</code></pre> <pre><code>library ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\nuse work.SeqDet_pkg.all;\n\nentity SeqDet is\nport (\n  clk                    : in  std_logic;\n  rst                    : in  std_logic;\n  seqIn                  : in  std_logic;\n  detOut                 : out std_logic\n);\nend SeqDet;\n\narchitecture SeqDet_arch of SeqDet is  \n  type E_fsm_states is (\n    E_fsm_states_S0,\n    E_fsm_states_S1,\n    E_fsm_states_S10,\n    E_fsm_states_S100,\n    E_fsm_states_S1001\n  );\n  signal fsm_state_prev1 : E_fsm_states := E_fsm_states_S0;\n  signal fsm_state_sig   : E_fsm_states;\nbegin\n  async_proc : process (all)  \n    variable fsm_state   : E_fsm_states;\n  begin\n    fsm_state            := fsm_state_prev1;\n    case fsm_state is\n      when E_fsm_states_S0 =&gt;\n        detOut           &lt;= '0';\n        if seqIn = '1' then\n          fsm_state      := E_fsm_states_S1;\n        else\n          fsm_state      := E_fsm_states_S0;\n        end if;\n      when E_fsm_states_S1 =&gt;\n        detOut           &lt;= '0';\n        if seqIn = '1' then\n          fsm_state      := E_fsm_states_S1;\n        else\n          fsm_state      := E_fsm_states_S10;\n        end if;\n      when E_fsm_states_S10 =&gt;\n        detOut           &lt;= '0';\n        if seqIn = '1' then\n          fsm_state      := E_fsm_states_S1;\n        else\n          fsm_state      := E_fsm_states_S100;\n        end if;\n      when E_fsm_states_S100 =&gt;\n        detOut           &lt;= '0';\n        if seqIn = '1' then\n          fsm_state      := E_fsm_states_S1001;\n        else\n          fsm_state      := E_fsm_states_S0;\n        end if;\n      when E_fsm_states_S1001 =&gt;\n        detOut           &lt;= '1';\n        if seqIn = '1' then\n          fsm_state      := E_fsm_states_S1;\n        else\n          fsm_state      := E_fsm_states_S10;\n        end if;\n    end case;\n    fsm_state_sig        &lt;= fsm_state;\n  end process;\n  sync_proc : process (rst, clk)\n  begin\n    if rst = '0' then\n      fsm_state_prev1    &lt;= E_fsm_states_S0;\n    elsif rising_edge(clk) then\n      fsm_state_prev1    &lt;= fsm_state_sig;\n    end if;\n  end process;\nend SeqDet_arch;\n</code></pre> <pre><code>`default_nettype                none\n`timescale 1ns/1ps\n`include \"SeqDet_defs.v\"\n\n\nmodule SeqDet(\n  input  wire                clk,\n  input  wire                rst,\n  input  wire                seqIn,\n  output reg                 detOut\n);\n  `define E_fsm_states_S0    0\n  `define E_fsm_states_S1    1\n  `define E_fsm_states_S10   2\n  `define E_fsm_states_S100  3\n  `define E_fsm_states_S1001 4\n  reg         [2:0]          fsm_state;\n  reg         [2:0]          fsm_state_prev1 = `E_fsm_states_S0;\n  reg         [2:0]          fsm_state_sig;\n  always @(*)\n  begin\n    fsm_state                = fsm_state_prev1;\n    case (fsm_state)\n      `E_fsm_states_S0 : begin\n        detOut               = 1'b0;\n        if (seqIn) fsm_state = `E_fsm_states_S1;\n        else fsm_state = `E_fsm_states_S0;\n      end\n      `E_fsm_states_S1 : begin\n        detOut               = 1'b0;\n        if (seqIn) fsm_state = `E_fsm_states_S1;\n        else fsm_state = `E_fsm_states_S10;\n      end\n      `E_fsm_states_S10 : begin\n        detOut               = 1'b0;\n        if (seqIn) fsm_state = `E_fsm_states_S1;\n        else fsm_state = `E_fsm_states_S100;\n      end\n      `E_fsm_states_S100 : begin\n        detOut               = 1'b0;\n        if (seqIn) fsm_state = `E_fsm_states_S1001;\n        else fsm_state = `E_fsm_states_S0;\n      end\n      `E_fsm_states_S1001 : begin\n        detOut               = 1'b1;\n        if (seqIn) fsm_state = `E_fsm_states_S1;\n        else fsm_state = `E_fsm_states_S10;\n      end\n      default : begin\n        fsm_state            = 3'b???;\n        detOut               = 1'b?;\n      end\n    endcase\n    fsm_state_sig            = fsm_state;\n  end\n  always @(negedge rst or posedge clk)\n  begin\n    if (rst == 1'b0) fsm_state_prev1 &lt;= `E_fsm_states_S0;\n    else fsm_state_prev1 &lt;= fsm_state_sig;\n  end\nendmodule\n</code></pre>"},{"location":"intro/first-look/#looks-cool-i-wish-to-know-more","title":"Looks cool! I wish to know more","text":""},{"location":"intro/technology/","title":"The DFiant Technology","text":"<p>DFiant navigates the complexities of hardware design with a nuanced approach that addresses the limitations of traditional methods. Register-transfer level (RTL) abstraction, while precise, often shifts the design focus from the \"what\" of functionality to the \"how\" of implementation. This subtle yet significant distinction restricts design flexibility, making it challenging to optimize for external constraints like performance or power without compromising on tool automation capabilities. The detailed nature of RTL leads to complex, verbose coding, and extended simulation time. Although such granularity of control is sometimes necessary, it often exceeds the requirements of many applications.</p> <p>Conversely, High-Level Synthesis (HLS) tools offer an abstraction that simplifies hardware design, particularly for those without a background in hardware engineering. By utilizing familiar programming languages and incorporating auto-pipelining and optimization, HLS makes hardware acceleration more accessible. However, the inherent sequential semantics of these languages can obstruct the development of parallel hardware architectures, making it especially challenging to describe processors or synchronous interfaces.</p> <p>A newer category, High-Level RTLs (HL-RTLs), such as Chisel and Amaranth, aims to bridge these gaps. Embedded within popular programming languages as domain-specific languages (DSLs), these HL-RTLs introduce innovative constructs for hardware generation. However, despite these significant advancements, they remain anchored to the RTL model, which can restrict implementation flexibility. Furthermore, their level of abstraction does not fully support the verification capabilities found in VHDL and Verilog, which benefit from event-driven semantics.</p> <p>DFiant attempts to introduce an optimal middle ground, which covers key HDL technologies across dimensions of both control and productivity (sort of \"have the cake and it it too\").</p>"},{"location":"intro/technology/#the-dataflow-hardware-description-abstraction","title":"The Dataflow Hardware Description Abstraction","text":"<p>At the heart of DFiant's innovation is the dataflow hardware description abstraction, a paradigm shift from the traditional RTL model. Instead of relying on wires and registers, dataflow abstraction employs streams of data tokens. This fundamental difference explains why RTL is inherently tied to device specifications and timing constraints, whereas dataflow abstraction remains neutral to such parameters.</p> <p> </p> <p>In RTL design, designers are tasked with specifying the exact operations that occur in each clock cycle, closely aligning the design with the physical timing of the hardware. Dataflow abstraction, on the other hand, focuses on the sequence of operations based on data dependencies, without mandating when each operation should start or finish within the clock cycles. This distinction allows operations in the dataflow model to be free from the rigid timing of clock cycles, granting compilers in the toolchain greater flexibility to schedule operations and effectively pipeline the design.</p> <p>Moreover, RTL design often requires the strategic placement of registers for various functions, anchoring the design to specific timing requirements. We categorize register use in RTL into three primary functions: backend synchronization, interface synchronization, and intrinsic design functionality, such as state management. The figure above illustrates the diverse applications of registers within RTL designs. Unlike RTL, where registers are uniformly represented, dataflow abstraction introduces unique language constructs or constraints for each register type. This differentiation enables the DFHDL compiler to distinguish between registers integral to the function and those necessary for implementation, providing subsequent design stages valuable insights for optimization. In contrast, RTL often relies on comments within the code to convey this information, if it is documented at all.</p>"},{"location":"intro/technology/#three-design-domain-abstractions-within-a-single-hdl","title":"Three Design Domain Abstractions within a Single HDL","text":"<p>DFHDL stands out by offering a comprehensive integration of three key domain abstractions\u2014dataflow (DF), register-transfer (RT), and event-driven (ED)\u2014all within a single HDL, as illustrated in Figure 4. This unique capability allows developers to employ a cohesive syntax to seamlessly blend these abstractions: DF, RT, and ED. Each abstraction brings its own set of advantages in terms of control, synthesizability, simulation speed, and functional correctness.</p> <p> </p> <p>The RT abstraction mirrors the capabilities found in languages like Chisel and Amaranth, while the ED abstraction aligns with the functionalities of VHDL and Verilog. Through an carefully constructed compilation process, the DFHDL compiler transitions from the higher-level DF abstraction through RT and ultimately to ED. The choice of compilation dialect\u2014whether VHDL 93/2008 or Verilog/SystemVerilog\u2014determines the final ED code representation.</p> <p>A standout feature of DFHDL is its ability to regenerate the code in DFHDL syntax at any point in the compilation process, including intermediate stages. This transparency offers developers valuable insights into each step of the optimization or compilation, a stark contrast to many HLS tools that produce hard-to-interpret code, leaving developers to decipher the underlying processes in case of issues.</p>"},{"location":"intro/technology/#more-details","title":"More Details","text":"<p>For more details on motivation, you can read this position paper.</p>"},{"location":"transitioning/from-verilog/","title":"Transitioning from Verilog to DFHDL","text":""},{"location":"transitioning/from-verilog/#using-chatgpt","title":"Using ChatGPT","text":"<p>Help me ChatGPT, you're my only hope</p>"},{"location":"transitioning/from-verilog/#summary","title":"Summary","text":"<p>Module Definition</p> Verilog<pre><code>module _module_name_ #(\n  //param declarations\n) (\n  //port declarations\n);\n  //internal declarations\nendmodule\n</code></pre> DFHDL<pre><code>class _design_name_(\n  //param declarations\n) extends EDDesign:\n  //port &amp; internal declarations\n\n\nend _design_name_ //optional\n</code></pre> Verilog<pre><code>module AndGate (\n  input a, b;\n  output o\n);\n  assign o = a &amp; b\nendmodule\n</code></pre> DFHDL<pre><code>class AndGate extends EDDesign:\n  val a, b = Bit &lt;&gt; IN\n  val o    = Bit &lt;&gt; OUT\n\n  o &lt;&gt; a &amp;&amp; b\nend AndGate\n</code></pre> <p>Parameter Declarations</p> Verilog<pre><code>parameter [7:0] p = 8\u2019b1011;\n</code></pre> DFHDL<pre><code>val p: Bits[8] &lt;&gt; CONST = b\"8'1011\"\n</code></pre> Verilog<pre><code>module Concat #(\n  parameter  int len1;\n  parameter  int len2;\n  localparam int outlen = len1 + len2\n) (\n  input  [len1-1:0]   i1;\n  input  [len2-1:0]   i2;\n  output [outlen-1:0] o\n);\n  assign o = {i1, i2};\nendmodule\n</code></pre> DFHDL<pre><code>class Concat(\n    val len1: Int &lt;&gt; CONST\n    val len2: Int &lt;&gt; CONST\n) extends EDDesign:\n  val outlen = len1 + len2\n  val i1 = Bits(len1)   &lt;&gt; IN\n  val i2 = Bits(len2)   &lt;&gt; IN\n  val o  = Bits(outlen) &lt;&gt; OUT\n\n  o &lt;&gt; (i1, i2)\nend Concat\n</code></pre> <p>logic/reg/wire</p> Verilog<pre><code>logic [7:0] v = 8\u2019b1011;\nwire  [7:0] v = 8\u2019b1011;\nreg   [7:0] v = 8\u2019b1011;\n</code></pre> DFHDL<pre><code>val v = Bits(8) &lt;&gt; VAR init b\"8'1011\"\n</code></pre>"},{"location":"user-guide/compilation/","title":"Compilation","text":""},{"location":"user-guide/compilation/#elaboration","title":"Elaboration","text":""},{"location":"user-guide/connectivity/","title":"Index","text":""},{"location":"user-guide/connectivity/#dataflow-ports-connectivity","title":"Dataflow Ports &amp; Connectivity","text":""},{"location":"user-guide/connectivity/#legend","title":"Legend","text":"Shape Meaning or  A dataflow design A dataflow port. Arrow enters a dataflow design shape = INPUT portArrow exists a dataflow design shape = OUTPUT port A dataflow variable (mutable) A constant (immutable literal). In this case, the value is 5. A dataflow join calculation junction (immutable). In this case, the calculation is the addition <code>+</code> arithmetic operation. A dataflow state element, via <code>.prev(rank)</code> (immutable).In this case, the rank is 3. A single-line arrow indicates a dataflow dependencyassignment from a producer (arrow tail) to a consumer (arrow head) A double-line diamond arrow indicates a dataflow dependencyconnection from a producer (arrow tail) to a consumer (arrow head) and an initial conditions dependency A double-line arrow indicates a dataflow dependencyreference from a producer (arrow tail) to a consumer (arrow head) and an initial conditions dependency"},{"location":"user-guide/connectivity/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Dataflow Ports &amp; Connectivity<ul> <li>Legend</li> <li>Table of Contents</li> <li>Key Differences Between &lt;&gt; and :=</li> <li>Connection &lt;&gt; Rules<ul> <li>Dataflow Port Connections</li> <li>Dataflow Value Connections</li> <li>Dataflow Input Port Assignment := Rule</li> <li>Immutable Value Connections</li> <li>Different Type Connections</li> <li>Multiple Connections</li> <li>Mixing Assignments and Connections</li> <li>Connection Statement Order</li> <li>Connection and Initial Conditions</li> <li>Open (Unconnected) Ports</li> <li>Initial Condition Cyclic Loop Errors</li> </ul> </li> <li>Valid Connection and Assignment Examples</li> <li>Via Connections</li> <li>Future Work</li> </ul> </li> </ul>"},{"location":"user-guide/connectivity/#key-differences-between-and","title":"Key Differences Between <code>&lt;&gt;</code> and <code>:=</code>","text":"Criteria <code>&lt;&gt;</code> Connection <code>:=</code> Assignment Code FunctionalDiagram We use a double line arrow to indicate a dataflow dependency with an initial condition dependency. We use a single line arrow to indicate a dataflow dependency without affecting initial conditions of the consumer. Directionality &amp;Commutativity The operator is commutative, meaning <code>a &lt;&gt; b</code> is equivalent to b <code>b &lt;&gt; a</code>.  One argument is the producer, while the other consumer. The dataflow direction is sensitive to the context in which the operator is applied. The operator is non-commutative, meaning <code>a := b</code> determines that <code>b</code> is the producer, transferring data to the consumer <code>a</code>. Initialization Initialization is transferred to the consumer. The consumer initialization is not affected. Mutation A consumer can only be connected once. Consumer assignments are unlimited. Statement Order Connections statements can be placed in any order. Assignment statements"},{"location":"user-guide/connectivity/#connection-rules","title":"Connection <code>&lt;&gt;</code> Rules","text":""},{"location":"user-guide/connectivity/#dataflow-port-connections","title":"Dataflow Port Connections","text":"<p>Connections annotation is generally used to connect parent designs to their child designs (components) and connect between sibling designs (children of the same parent). Opposed to VHDL/Verilog, there is no need to go through 'signals' to connect sibling design ports, e.g.:</p> <pre><code>trait IODesign extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  o &lt;&gt; i\n}\ntrait Container2 extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  val io1 = new IODesign {}\n  val io2 = new IODesign {}\n  i     &lt;&gt; io1.i //Connecting between owner input and child input\n  io1.o &lt;&gt; io2.i //Connecting between siblings (output &lt;&gt; input)\n  io2.o &lt;&gt; o     //Connecting between child output and owner output\n}\n</code></pre> <p></p>"},{"location":"user-guide/connectivity/#dataflow-value-connections","title":"Dataflow Value Connections","text":"<p>At least one of the connected sides must be a dataflow port (cannot connect two dataflow values together), e.g.:</p> <pre><code>trait Conn1 {\n  val port = DFUInt(8) &lt;&gt; OUT\n  val temp1 = DFUInt(8)\n  val temp2 = DFUInt(8)\n  port &lt;&gt; temp1 //OK!\n  temp1 &lt;&gt; temp2 //Bad connection! At least one connection side must be a port\n}\n</code></pre>"},{"location":"user-guide/connectivity/#dataflow-input-port-assignment-rule","title":"Dataflow Input Port Assignment <code>:=</code> Rule","text":"<p>An input port cannot be assigned to. A connection must be used to transfer data to an input port, e.g.:</p> <pre><code>trait IO extends DFDesign {\n  val in  = DFUInt(8) &lt;&gt; IN\n  val out = DFUInt(8) &lt;&gt; OUT\n  out := in //OK! Can assign internally to an output port\n}\ntrait Assign1 extends DFDesign {\n  val io = new IO{}\n  io.in := 1 //Bad assignment! Must use a connection annotation\n  io.in &lt;&gt; 1 //OK!\n  io.out := 1 //Bad assignment! Output ports can only be assigned internally\n}\n</code></pre>"},{"location":"user-guide/connectivity/#immutable-value-connections","title":"Immutable Value Connections","text":"<p>When connecting a port to an immutable value, the port must be a consumer, meaning the connection is done internally to an output port or externally to an input port, e.g.:</p> <pre><code>trait IO extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  //For brevity, we consider every connection/assignment in this example separately.\n  //We ignore multiple connection issues that should arise.\n  o &lt;&gt; 1 //OK!\n  i &lt;&gt; 1 //Bad connection! 1 is immutable (constant)\n  i &lt;&gt; o.prev //Bad connection! o.prev is immutable\n  i.prev &lt;&gt; o //OK!\n}\ntrait IOUser extends DFDesign {\n  val io = new IO {}\n  io.i &lt;&gt; 1 //OK!\n  io.o &lt;&gt; 1 //Bad connection! 1 is immutable\n}\n</code></pre>"},{"location":"user-guide/connectivity/#different-type-connections","title":"Different Type Connections","text":"<p>Connecting between different types is possible, but depends on the specific type: if it enables automatic conversion for the connection to succeed. Different port widths are considered different types and casting is required. An alias/casted/converted dataflow value is considered immutable for the connection (see above). Here are some examples:</p> <pre><code>trait DifferentTypesConn extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  val ob9 = DFBits(9) &lt;&gt; OUT\n\n  val u7 = DFUInt(7)\n  val u9 = DFUInt(9)\n  val b8 = DFBits(8)\n\n  //For brevity, we consider every connection/assignment in this example separately.\n  //We ignore multiple connection issues that should arise.\n  u7 &lt;&gt; o //OK! u7 is automatically extended to connect to \n  u7 &lt;&gt; i //Bad connection! u7 is considered immutable when extended to 8 bits\n  o &lt;&gt; b8 //Bad connection! There is not automatic casting between bits and uint\n  o &lt;&gt; b8.uint //OK!\n  o.bits &lt;&gt; b8 //Bad connection! An alias of output port cannot be connected to\n               //This may change in the future.\n  o.bits := b8 //OK!\n  u9 &lt;&gt; i //OK! In this example u9 is the consumer\n  ob9 &lt;&gt; b8 //Bad connection! Bit vectors are NOT automatically extended.\n  ob9 := b8 //Bad assignment! Bit vectors are NOT automatically extended.\n}\n</code></pre>"},{"location":"user-guide/connectivity/#multiple-connections","title":"Multiple Connections","text":"<p>Two or more dataflow producers cannot be connected to the same consumer (a single producer can be connected to more than one consumer), e.g.:</p> <pre><code>trait Gen extends DFDesign {\n  val out1 = DFUInt(8) &lt;&gt; OUT init 1\n  val out2 = DFUInt(8) &lt;&gt; OUT init 2\n}\ntrait Conn2 extends DFDesign {\n  val in1 = DFUInt(8) &lt;&gt; IN\n  val in2 = DFUInt(8) &lt;&gt; IN\n  val out = DFUInt(8) &lt;&gt; OUT\n  val temp1 = DFUInt(8)\n  temp1 &lt;&gt; in1 //OK!\n  out   &lt;&gt; in1 //Also OK! (Same producer can connect to more than one cosumer)\n  temp1 &lt;&gt; in2 //Bad connection! Second producer connection to temp1\n\n  val gen = new Gen {}\n  val temp2 = DFUInt(8)\n  val temp3 = DFUInt(8)\n  gen.out1 &lt;&gt; temp2 //OK!\n  gen.out1 &lt;&gt; temp3 //Also OK! (Same producer can connect to more than one cosumer)\n  gen.out2 &lt;&gt; temp2 //Bad connection! Second producer connection to temp2\n} \n</code></pre>"},{"location":"user-guide/connectivity/#mixing-assignments-and-connections","title":"Mixing Assignments and Connections","text":"<p>The same consumer cannot be both assigned to and connected to as the consumer, e.g.:</p> <pre><code>trait Conn3 extends DFDesign {\n  val out1 = DFUInt(8) &lt;&gt; OUT\n  val out2 = DFUInt(8) &lt;&gt; OUT\n  val out3 = DFUInt(8) &lt;&gt; OUT\n  out1 &lt;&gt; 1 //OK!\n  out1 := 1 //Bad assignment! Cannot assign to a connected dataflow variable\n\n  out2 := 2 //OK!\n  out2 &lt;&gt; 2 //Bad connection! Cannot connect to an assigned dataflow variable\n\n  out3 := 1 //OK!\n  out3 := 2 //Also OK! (Multiple assignments are accepted)\n}\n</code></pre>"},{"location":"user-guide/connectivity/#connection-statement-order","title":"Connection Statement Order","text":"<p>The connection <code>&lt;&gt;</code> statement ordering does not matter.</p>"},{"location":"user-guide/connectivity/#connection-and-initial-conditions","title":"Connection and Initial Conditions","text":"<p>A connection <code>&lt;&gt;</code> transfers initial conditions to the consumer, but if the consumer is already initialized then the consumer keeps its existing initial conditions. Here is an example:</p> <pre><code>trait IOInit extends DFDesign {\n  val i = DFUInt(8)        //init = (11, 12) Overriden from TopInit connection\n  val o = DFUInt(8) init 5 //init = (5)      Not overridden due to assignment\n  val ip = i.prev          //init = (12)     Prev moves down the init queue\n  o := ip \n}\ntrait TopInit extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN.init(1, 2)  //init = (1, 2)   The top-level initial conditions\n  val o = DFUInt(8) &lt;&gt; OUT init 1     //init = (1)      Keeps its initializaion\n  val iPlus10 = in + 10               //init = (11, 12) Arithmetics affect init\n  val io = new IOInit {}\n  io.i &lt;&gt; inPlus10                                          \n  o &lt;&gt; io.o                                         \n}\n</code></pre> <p></p> <p>We learn from the above that port initial conditions are often overridden due to connections. So why should we apply initial conditions to a port? Answer: If we want to define what happens when a port is open (unconnected). Read the next two sections for more information.</p>"},{"location":"user-guide/connectivity/#open-unconnected-ports","title":"Open (Unconnected) Ports","text":"<p>Ports have two connection sides: a consumer side and a producer side. Typically ports have both sides connected, except for top-level ports. When either port side is unconnected, we refer to it as open, and expect the following behavior:</p> <ul> <li> <p>When the port consumer side is open, the port produces tokens according to its initial condition. Uninitialized open-consumer ports generate bubble tokens.</p> </li> <li> <p>When the port producer side is open (unless it is a top-level output port), the port is considered as not used, and is pruned during compilation. All dataflow streams that are only used by this port will be pruned as well.</p> </li> </ul> <p>Note: the current compiler implementation does not warn of open ports.  </p> <p>Example:</p> <pre><code>trait IOInit2 extends DFDesign {\n  val i1 = DFUInt(8) &lt;&gt; IN init 5\n  val o1 = DFUInt(8) &lt;&gt; OUT\n  val i2 = DFUInt(8) &lt;&gt; IN\n  val o2 = DFUInt(8) &lt;&gt; OUT init 2\n  o1 &lt;&gt; i1 \n}\ntrait TopIO2 extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN  \n  val o = DFUInt(8) &lt;&gt; OUT //Will generate infinite tokens of 2, due to io.o2 init\n  val io = new IO5 {}\n  o &lt;&gt; io.o2\n  i &lt;&gt; io.i1\n  io.i2 &lt;&gt; 5\n}\n</code></pre> <p></p>"},{"location":"user-guide/connectivity/#initial-condition-cyclic-loop-errors","title":"Initial Condition Cyclic Loop Errors","text":"<p>Connections enable dataflow feedbacks and even dataflow dependency loops. There is no problem in dependency loops, other than pipelining limitations (see chapter TBD for more information). However, if we only apply connections and references that transfer initial conditions, we end up with a cyclic dependency for initial condition which is illegal. Therefore to enable dependency loops, at least one link in the loop must be an assignment, which has an implicit state and does not affect initial conditions. Consider the following examples:</p> <pre><code>trait IO1 extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  o &lt;&gt; i //Connection transfers initial conditions from i to o\n}\ntrait BadConnLoop1 extends DFDesign {\n  val o = DFUInt(8) &lt;&gt; OUT\n  val io = new IO1 {}\n  io.i &lt;&gt; io.o //Bad connection! An initial conditions cyclic loop\n  o  &lt;&gt; io.o\n}\ntrait IO2 extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  o &lt;&gt; i.prev //prev transfers initial conditions\n}\ntrait BadConnLoop2 extends DFDesign {\n  val o = DFUInt(8) &lt;&gt; OUT\n  val io = new IO2 {}\n  io.i &lt;&gt; io.o //Bad connection! An initial conditions cyclic loop\n  o  &lt;&gt; io.o\n}\ntrait IO3 extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  o := i //Assignment does not affect initial conditions and therefore breaks the loop\n}\ntrait OKConnLoop extends DFDesign {\n  val o = DFUInt(8) &lt;&gt; OUT\n  val io = new IO3 {}\n  io.i &lt;&gt; io.o //OK!\n  o  &lt;&gt; io.o\n}\n</code></pre> <p></p> <p>Note: when following the drawing convention within this document, we want to avoid a double-lined loop in order to avoid a cyclic initial conditions dependency.</p>"},{"location":"user-guide/connectivity/#valid-connection-and-assignment-examples","title":"Valid Connection and Assignment Examples","text":"<pre><code>trait IODesign extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  o &lt;&gt; i\n}\n</code></pre> <pre><code>trait IODesign1 extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  val tmp = DFUInt(8)\n  tmp &lt;&gt; i\n  o &lt;&gt; tmp\n}\n</code></pre> <pre><code>trait IODesign2 extends DFDesign {\n  val i1 = DFUInt(8) &lt;&gt; IN\n  val o1 = DFUInt(8) &lt;&gt; OUT\n  val i2 = DFUInt(8) &lt;&gt; IN\n  val o2 = DFUInt(8) &lt;&gt; OUT\n  o1 &lt;&gt; i1\n  o2 &lt;&gt; i2\n}\n</code></pre> <pre><code>trait Container extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  val io = new IODesign {}\n  i    &lt;&gt; io.i //Connecting between owner input and child input\n  io.o &lt;&gt; o    //Connecting between child output and owner output\n}\n</code></pre> <pre><code>trait Container2 extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  val io1 = new IODesign {}\n  val io2 = new IODesign {}\n  i     &lt;&gt; io1.i //Connecting between owner input and child input\n  io1.o &lt;&gt; io2.i //Connecting between siblings (output &lt;&gt; input)\n  io2.o &lt;&gt; o     //Connecting between child output and owner output\n}\n</code></pre> <pre><code>trait Container3 extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  val io = new IODesign2 {}\n  i &lt;&gt; io.i1 //Connecting between owner input and child input\n  i &lt;&gt; io.i2 //Connecting between owner input and child input\n  o &lt;&gt; (io.o1 + io.o2)\n}\n</code></pre> <pre><code>trait Container4 extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  val io = new IODesign2 {}\n  i     &lt;&gt; io.i1 //Connecting between owner input and child input\n  io.i2 &lt;&gt; 5     //Connecting between constant value and child input\n  o     &lt;&gt; io.o2\n}\n</code></pre> <pre><code>trait Blank2 extends DFDesign {\n  val i1 = DFUInt(8) &lt;&gt; IN\n  val o1 = DFUInt(8) &lt;&gt; OUT\n  val i2 = DFUInt(8) &lt;&gt; IN\n  val o2 = DFUInt(8) &lt;&gt; OUT    \n}\ntrait Container5 extends DFDesign {\n  val i = DFUInt(8) &lt;&gt; IN\n  val o = DFUInt(8) &lt;&gt; OUT\n  val io = new Blank2 {\n    o1 &lt;&gt; i1 //Assignment\n    o2 &lt;&gt; i2 //Internal connection   \n  }\n  i     &lt;&gt; io.i1 //Connecting between owner input and child input\n  io.i2 &lt;&gt; io.o1 //External connection between child input/output creates a feeback\n  o     &lt;&gt; io.o2\n}\n</code></pre> <p>Note: although there is a feedback in this design, there is no circular initial conditions dependency.</p>"},{"location":"user-guide/connectivity/#via-connections","title":"Via Connections","text":""},{"location":"user-guide/connectivity/#future-work","title":"Future Work","text":"<ul> <li>In the future <code>&lt;&gt;</code> will be used to connect multi-port interfaces.</li> <li>We will add support to treat an alias of a port as a port when connection <code>&lt;&gt;</code> rules are enforced.</li> <li>Connecting between any ancestor which is not a parent and child. Currently not supported fully.</li> </ul>"},{"location":"user-guide/design-domains/","title":"Design Domains","text":"<p>DFHDL offers three key domain abstractions\u2014dataflow (DF), register-transfer (RT), and event-driven (ED)\u2014all within a single HDL, as illustrated in the following figure. This unique capability allows developers to employ a cohesive syntax to seamlessly blend these abstractions: DF, RT, and ED. Each abstraction brings its own set of advantages in terms of control, synthesizability, simulation speed, and functional correctness.</p> <p>The RT abstraction mirrors the capabilities found in languages like Chisel and Amaranth, while the ED abstraction aligns with the functionalities of VHDL and Verilog. Through an intelligent compilation process, the DFHDL compiler transitions from the higher-level DF abstraction through RT and ultimately to ED. The choice of compilation dialect\u2014whether VHDL 93/2008 or Verilog/SystemVerilog\u2014determines the final ED code representation.</p> <p> </p>"},{"location":"user-guide/errors/","title":"Errors &amp; Warnings","text":"<p>DFiant-related compiler errors &amp; warnings and ways to resolve them</p>"},{"location":"user-guide/errors/#missing-context","title":"Missing Context","text":"<p>TBD</p>"},{"location":"user-guide/errors/#dont-use-var-with-dataflow-valuesvariables","title":"Don't use <code>var</code> with dataflow values/variables","text":"<p>TBD</p>"},{"location":"user-guide/interfaces/","title":"Interfaces [WIP]","text":""},{"location":"user-guide/meta/","title":"Meta Hardware Description","text":""},{"location":"user-guide/methods/","title":"Functions / Methods","text":""},{"location":"user-guide/naming/","title":"Naming","text":""},{"location":"user-guide/processes/","title":"Processes","text":""},{"location":"user-guide/simulation/","title":"Simulation","text":""},{"location":"user-guide/state/","title":"Index","text":""},{"location":"user-guide/state/#state-initialization","title":"State &amp; Initialization","text":"<p>Semantically, every DFiant dataflow variable references a token stream (TS). </p> <ul> <li> <p>Unless stated otherwise, all dataflow variables are always consuming and always producing.</p> </li> <li> <p>Previous token initialization:</p> </li> <li> <p>The token history stream can be initialized.</p> </li> <li> <p>Initialization does not mutate the dataflow variable.</p> </li> <li> <p>Initialization has no effect on the TS. Only when using <code>prev</code> the initialization is placed on the TS reference.</p> </li> <li> <p><code>init</code> returns a reference to a new (initialized) dataflow variable, but maintains the mutability trait dataflow variable. </p> </li> <li> <p>Bubble tokens (?) :</p> </li> <li> <p>Produced when a <code>prev</code> is called on a non-initialized dataflow variable. E.g.,</p> Code Init Token Stream <code>in : DFUInt[32]</code> <code>?</code> <code>2, 3, 1, 5, 9</code> <code>in.prev</code> <code>?</code> <code>?, 2, 3, 1, 5, 9</code> <code>in.prev(2)</code> <code>?</code> <code>?, ?, 2, 3, 1, 5, 9</code> <code>in.prev.prev</code> <code>?</code> <code>?, ?, 2, 3, 1, 5, 9</code> <code>val in1 = in.init(1); in1</code> <code>1</code> <code>2, 3, 1, 5, 9</code> <code>in1.prev</code> <code>1</code> <code>1, 2, 3, 1, 5, 9</code> <code>in1.prev(2)</code> <code>1</code> <code>1, 1, 2, 3, 1, 5, 9</code> <code>in1.prev.init(8)</code> <code>8</code> <code>1, 2, 3, 1, 5, 9</code> <code>val innew = DFUInt(32) := in1; innew</code> <code>?</code> <code>2, 3, 1, 5, 9</code> <code>val ins7 = in.init(7, ?); ins7</code> <code>(7, ?)</code> <code>2, 3, 1, 5, 9</code> <code>ins7.prev</code> <code>?</code> <code>7, 2, 3, 1, 5, 9</code> <code>val ins78 = in.init(7, 8, ?); ins78</code> <code>(7, 8, ?)</code> <code>2, 3, 1, 5, 9</code> <code>ins78.prev</code> <code>(8, ?)</code> <code>7, 2, 3, 1, 5, 9</code> <code>ins78.prev(2)</code> <code>?</code> <code>8, 7, 2, 3, 1, 5, 9</code> <code>in.init(7).prev.init(8, ?).prev</code> <code>?</code> <code>8, 7, 2, 3, 1, 5, 9</code> </li> <li> <p>Bubbles are like any regular-value tokens in terms of consumption and production rules.</p> </li> <li> <p>Bubbles are used to set phases between synchronized token streams by acting as a token place-holder within the stream queue.</p> </li> <li> <p>Unless stated otherwise, any operation with a bubble token produces a bubble token (consuming the non-bubble token.). E.g., </p> <pre><code>def foo(a : DFUInt(8)) = a + a.prev\n//'in' is token stream of:    2, 3, 1, 5, 9\n//'foo(in)' returns:          ?, 5, 4, 6, 14\n</code></pre> </li> <li> <p><code>prev</code> maintains Distributivity through basic operations e.g.: </p> <p><code>(a + b).prev</code> \u2257 <code>a.prev + b.prev</code> (timeless TS equality).</p> Code Init Token Stream <code>inL : DFUInt(32)</code> <code>?</code> <code>2, 3, 1, 5, 9</code> <code>inR : DFUInt(32)</code> <code>?</code> <code>4, 0, 2</code> <code>inL + inR</code> <code>?</code> <code>+</code><code>?</code> <code>=</code><code>?</code> <code>2, 3, 1, 5, 9</code> <code>+</code><code>4, 0, 2</code> <code>=</code><code>6, 3, 3</code> <code>inL + inR.prev</code> <code>?</code> <code>+</code><code>?</code> <code>=</code><code>?</code> <code>2, 3, 1, 5, 9</code> <code>+</code><code>?, 4, 0, 2</code> <code>=</code><code>?, 7, 1, 7</code> <code>inL.init(1) + inR.init(3).prev</code> <code>1</code> <code>+</code><code>3</code> <code>=</code><code>4</code> <code>2, 3, 1, 5, 9</code> <code>+</code><code>3, 4, 0, 2</code> <code>=</code><code>5, 7, 1, 7</code> <code>inL.init(1, ?) + inR.init(3).prev</code> <code>(1, ?)</code> <code>+</code><code>3</code> <code>=</code><code>(4, ?)</code> <code>2, 3, 1, 5, 9</code> <code>+</code><code>3, 4, 0, 2</code> <code>=</code><code>5, 7, 1, 7</code> <code>inL.init(1) + inR.init(3, ?).prev</code> <code>1</code> <code>+</code><code>?</code> <code>=</code><code>?</code> <code>2, 3, 1, 5, 9</code> <code>+</code><code>3, 4, 0, 2</code> <code>=</code><code>5, 7, 1, 7</code> <code>inL.init(1).prev + inR.init(3).prev</code> <code>1</code> <code>+</code><code>3</code> <code>=</code><code>4</code> <code>1, 2, 3, 1, 5, 9</code> <code>+</code><code>3, 4, 0, 2</code> <code>=</code><code>4, 6, 3, 3</code> <code>(inL.init(1) + inR.init(3)).prev</code> <code>1</code> <code>+</code><code>3</code> <code>=</code><code>4</code> <code>(2, 3, 1, 5, 9</code> <code>+</code><code>4, 0, 2)</code> <code>.prev =</code><code>4, 6, 3, 3</code> </li> <li> <p>Bubbles are typically treated differently at the edges of the dataflow paths, when bridging to the real-time world. E.g.: not committing bubbles to memory cells, or not raising ready flags.</p> </li> <li> <p>Casting:</p> </li> <li> <p>Parts of a bits vector can be bubbles while others normal values.</p> </li> <li> <p>However, when casting to a number (e.g., DFUInt), the casting must check validity of all bits.</p> </li> </ul>"},{"location":"user-guide/state/#time-invariance","title":"Time Invariance","text":""},{"location":"user-guide/synthesis/","title":"Synthesis","text":""},{"location":"user-guide/type-system/","title":"Index","text":""},{"location":"user-guide/type-system/#type-system","title":"Type System","text":"<p>DFHDL is a Scala library and thus inherently supports type-safe and modern language constructs. This chapter covers the rules and API of this type system. </p> Check out the benefits of the DFHDL type system <ul> <li> <p> Strongly-typed</p> <p>Most type checking is done statically and enforces strict rules that prevent ambiguity.</p> <p><pre><code>//8-bit unsigned input\nval u8 = UInt(8) &lt;&gt; IN \n//2-bit unsigned input\nval u2 = UInt(2) &lt;&gt; IN \nval y1 = u8 - u2 //ok\n// Error prevents ambiguous behavior \n// when a wider num is subtracted from \n// a narrow num.\nval y2 = u2 - u8 //error\n</code></pre> </p> </li> <li> <p> Bit-accurate</p> <p>Each DFHDL value has known bit-width, which is used to enforce various rules to prevent data loss.</p> <p><pre><code>//8-bit unsigned input\nval u8 = UInt(8) &lt;&gt; IN  \n//8-bit signed output\nval s8 = SInt(8) &lt;&gt; OUT \n// Error prevents data loss when u8 is \n// converted to a 9-bit signed to be \n// assigned to s8, which is only 8-bits \n// wide.\ns8 := u8 //error\n</code></pre> </p> </li> <li> <p> Composable</p> <p>Types can be composed through structs or tuples to form new types.</p> <pre><code>//new Pixel type as a structure\n//of two unsigned 8-bit numbers\ncase class Pixel(\n  x: UInt[8] &lt;&gt; VAL,\n  y: UInt[8] &lt;&gt; VAL\n) extends Struct\n\nval pixel = Pixel &lt;&gt; VAR\n//select and assign fields\npixel.x := pixel.y\n</code></pre> </li> <li> <p> Expandable</p> <p>New types can be defined, and methods can be added for new or existing types.</p> <pre><code>//new AESByte type of unsigned 8-bit num\ncase class AESByte() \n  extends Opaque(UInt(8))\n//define addition between two AESByte\n//values as a xor operation\nextension (lhs: AESByte &lt;&gt; VAL)\n  def +(rhs: AESByte &lt;&gt; VAL): AESByte &lt;&gt; DFRET =\n    (lhs.actual ^ rhs.actual).as(AESByte)\nval x, y = AESByte &lt;&gt; VAR\nval z = x + y //actually XOR\n</code></pre> </li> </ul> <p>DFHDL Values</p> <p>Each DFHDL value is simply a Scala object that has two critical fields:</p> <ul> <li> <p> (Shape) Type, aka DFType</p> <p>Determines the bit-width and bit-structure of the value. Currently the supported types are: </p> <ul> <li>DFHDL Bit/Boolean: <code>Bit</code>/<code>Boolean</code> </li> <li>DFHDL Bit Vector: <code>Bits</code></li> <li>DFHDL Integer: <code>UInt</code>/<code>SInt</code>/<code>Int</code></li> <li> <p>DFHDL Fix-Point (future work)</p> </li> <li> <p>DFHDL Flt-Point (future work)</p> </li> <li> <p>DFHDL String (future work)</p> </li> <li>DFHDL Enumeration: <code>... extends Encoding</code></li> <li>DFHDL Vector: <code>[CellType] X [Dim]</code></li> <li>DFHDL Structure: <code>... extends Struct</code></li> <li>DFHDL Tuple: <code>(T1, T2, ..., Tn)</code></li> <li>DFHDL Opaque: <code>... extends Opaque</code></li> <li>DFHDL Unit (Void): <code>Unit</code></li> </ul> </li> <li> <p> (Access) Modifier</p> <p>Determines what kind of access the user has on the value. User explicit modifiers:</p> <ul> <li>Variable: <code>VAR</code></li> <li>Port: <code>IN</code>/<code>OUT</code>/<code>INOUT</code></li> <li>Constant: <code>CONST</code></li> <li>Struct Field: <code>VAL</code></li> <li>Method Param: <code>VAL</code></li> <li>Method Return: <code>DFRET</code>/<code>RTRET</code>/<code>EDRET</code></li> </ul> <p>Although this mechanism can be quite complex under the hood, the explicit modifiers available to the user are straightforward.</p> </li> </ul> Internal Type-System Hierarchy (For Advanced Users) <p>DFHDL brings type-driven development concepts to hardware design, by creating an extensible type class hierarchy. Any DFHDL value is a Scala object instance of the class <code>DFVal[T &lt;: DFTypeAny, M &lt;: ModifierAny]</code>, where <code>T</code> is the type (shape) of value and <code>M</code> is a modifier that sets additional characteristics of the DFHDL value, like if its assignable, connectable, initializable, etc. </p> <p> </p> <p>For example, the Scala value <code>x</code> which references a port declared like <code>val x = Boolean &lt;&gt; IN</code> has the type <code>DFVal[DFBool, Modifier.Dcl]</code>.</p>"},{"location":"user-guide/type-system/#Dcl","title":"Variable and Port Declarations","text":"<p>Ports are DFHDL values that define the inputs and outputs of a design. Variables are DFHDL values that represent internal design wiring, logic, or state.</p>"},{"location":"user-guide/type-system/#dcl-syntax","title":"Syntax","text":"Port &amp; variable declaration syntax<pre><code>val\u00a0_name_\u00a0=\u00a0_dftype_\u00a0&lt;&gt;\u00a0_modifier_\u00a0[init\u00a0_const_]\n</code></pre> <ul> <li><code>_modifier_</code> is set with one of the following: <ul> <li><code>VAR</code> - to construct a variable</li> <li><code>IN</code> - to construct an input port</li> <li><code>OUT</code> - to construct an output port</li> <li><code>INOUT</code> - to construct an input-output port</li> </ul> </li> <li><code>_dftype_</code> is set according to the shape type (DFType) of the DFHDL value. Each of the supported DFTypes have their own constructors. See relevant sections for the DFHDL DFType you wish to construct.</li> <li><code>&lt;&gt;</code> is the operator applied between a <code>_dftype_</code> and a <code>_modifier_</code> to construct the Scala value that represents a DFHDL variable or port accordingly. Note: the same <code>&lt;&gt;</code> operator is used as a language construct for declaring connections. Thanks to Scala method overloading, <code>&lt;&gt;</code> can be shared for both use-cases with no issues (due to the Scala argument type difference). </li> <li><code>init</code> is an optional construct to initialize the DFHDL variable/port declaration history with the applied <code>_const_</code> value.</li> <li><code>_const_</code> is the state history initialization value or sequence of initialization values as a Scala Tuple. This value must be a constant that is supported by the DFType <code>_dftype_</code>.</li> <li><code>_name_</code> is the Scala value name reference for the DFHDL variable/port you constructed. The DFHDL compiler preserves this name and uses it in error messages and the final generated artifacts (e.g., Verilog module or VHDL entity port names). More information is available under the naming section.</li> </ul> Port &amp; variable declaration examples<pre><code>class Foo extends DFDesign:\n  //8-bit unsigned integer input port named 'i', \n  //initialized with the value 27.\n  val i\u00a0=\u00a0UInt(8)\u00a0    &lt;&gt;\u00a0IN\u00a0\u00a0init\u00a027\n\n  //single bit output port named 'o' \n  //with a sequence history (0, 1, 0) init\n  val o =\u00a0Bit\u00a0        &lt;&gt;\u00a0OUT\u00a0init\u00a0(0, 1, 0)\n\n  //5 element vector of 8-bit vector cells \n  //variable named 'v' with no init\n  val v\u00a0=\u00a0Bits(8) X 5 &lt;&gt;\u00a0VAR\n</code></pre>"},{"location":"user-guide/type-system/#dcl-rules","title":"Rules","text":""},{"location":"user-guide/type-system/#scope","title":"Scope","text":"<ul> <li> <p>Variables can be declared in any DFHDL scope, except global scope, meaning within DFHDL designs, domains, interfaces, methods, processes, and conditional blocks. <pre><code>//error: global variables are not \n//allowed\nval x = Bit &lt;&gt; VAR \nclass Foo extends DFDesign:\n  val o = Bit &lt;&gt; OUT\n</code></pre></p> </li> <li> <p>Ports can only be declared at the scopes of DFHDL designs, domains, and interfaces. Other scopes are not allowed. <pre><code>class Foo extends DFDesign:\n  val i = Boolean &lt;&gt; IN\n  if (i)\n    //error: cannot create a port in a \n    //DFHDL condition\n    val o = Bit &lt;&gt; OUT \n    o := 0\n</code></pre></p> </li> </ul>"},{"location":"user-guide/type-system/#naming","title":"Naming","text":"<p>Ports and variables must always be named, and cannot be anonymous. </p> <pre><code>class Foo extends DFDesign:\n  //error: constructed an anonymous \n  //output port\n  Bit &lt;&gt; OUT \n</code></pre> <p>As you'll read later on, constants and other values can be anonymous.</p>"},{"location":"user-guide/type-system/#connectable","title":"Connectable","text":"<p>Ports and variables are connectable, meaning they can be the receiving (drain/consumer) end of a connection <code>&lt;&gt;</code> operation.  For input ports this occurs outside their design scope, while connecting to an external value.  For output ports and variables this occurs only within their design scope, while connecting to an internal value.</p>"},{"location":"user-guide/type-system/#assignable-mutable","title":"Assignable (Mutable)","text":"<p>Output ports, input-output ports, and variables are assignable (mutable), when they can be the receiving (drain/consumer) end of an assignment <code>:=</code>/<code>:==</code> operation, which occurs only within their design scope. Input ports can never be assigned (are immutable). </p>"},{"location":"user-guide/type-system/#not-constant","title":"Not Constant","text":"<p>Ports and variables are never considered to be constant (even when connected/assigned only once and to a constant value) for elaboration. Later compilation stages can apply further constant propagation steps that reduce logic utilization.</p>"},{"location":"user-guide/type-system/#inout-port-limitation","title":"<code>INOUT</code> Port Limitation","text":"<p><code>INOUT</code> (bidirectional) ports are generally used to reduce IO pins from top-level device connectivity (e.g., protocols like I<sup>2</sup>C benefit from such ability). They are not meant for inter-device wiring reduction, and thus should be used scarcely within their designed purpose. Throughout the years they were also used to workaround HDL limitations like reading from output ports in VHDL'93, or lack of interfaces. Since DFHDL has none of these limitation, we encourage you to use <code>INOUT</code> for their intended purpose only, as synthesis tools for FPGAs and even ASICs will not cooperate. Although, theoretically, in DF domain we can enable bidirectional communication that can later be compiled into two separate ports, there is no real value behind this.</p>"},{"location":"user-guide/type-system/#grouping","title":"Grouping","text":"<p>Ports can also be grouped together in a dedicated interface [wip].</p>"},{"location":"user-guide/type-system/#Dcl-transitioning","title":"Transitioning","text":"Differences from Verilog <ul> <li>DFHDL supports more abstraction domains, and not just ED abstraction like Verilog does.</li> <li>The non-blocking assignment operator in DFHDL is <code>:==</code> instead of <code>&lt;=</code> in Verilog.</li> </ul> Differences from VHDL <p>Hi there</p> Differences from Scala parameters/fields <p>Data validity</p> <p>Number of outputs</p>"},{"location":"user-guide/type-system/#DFConst","title":"Constant/Literal Values","text":"<p>In DFHDL there are three methods to construct constant DFHDL values:</p> <ol> <li>Literal value generators: These language constructs directly generate constant DFHDL values. Currently, these are:<ul> <li>Binary <code>Bits</code> string interpolator</li> <li>Hexadecimal <code>Bits</code> string interpolator</li> <li>Decimal string interpolator</li> <li>Signed Decimal string interpolator</li> </ul> </li> <li>Constant candidates: Various Scala values can become DFHDL values, as. Constant declaration syntax<pre><code>val\u00a0_name_: _dftype_ &lt;&gt; CONST\u00a0=\u00a0_value_\n</code></pre></li> <li>Constant value propagation: Cleaners</li> </ol>"},{"location":"user-guide/type-system/#const-syntax","title":"Syntax","text":""},{"location":"user-guide/type-system/#const-rules","title":"Rules","text":""},{"location":"user-guide/type-system/#unconnectable","title":"Unconnectable","text":"<p>Constant values are not connectable, and can never be the receiving (drain/consumer) end of a connection <code>&lt;&gt;</code> operation.</p>"},{"location":"user-guide/type-system/#unassignable-immutable","title":"Unassignable (Immutable)","text":"<p>Constant values are immutable and cannot be assigned, meaning they can never be the receiving (drain/consumer) end of an assignment <code>:=</code>/<code>:==</code> operation.</p>"},{"location":"user-guide/type-system/#dfhdl-value-statement-order-referencing","title":"DFHDL Value Statement Order &amp; Referencing","text":"<p>Any DFHDL value must be declared before it can be referenced in code. Other than this (pretty intuitive) limitation, no other limitations exists and ports, variables, constants, and other values may be freely distributed within their approved scope space. During the compilation process, you can notice that the compiler reorders the port declarations so that they always come second to constant declarations, and variables right after.</p>"},{"location":"user-guide/type-system/#connection","title":"DFHDL Value Connections","text":"<p>After (or during) a design instantiation, its ports need to be connected to other ports or values of the same DFType by applying the <code>&lt;&gt;</code> operator. Variables can also be connected and used as intermediate wiring between ports. Output ports can be directly referenced (read) without being connected to an intermediate variable. For more rules about design and port connectivity, see the relevant section. Successful port/variable connection example<pre><code>class ID extends DFDesign:\n  val x = UInt(8) &lt;&gt; IN\n  val y = UInt(8) &lt;&gt; OUT\n  //internal connection between ports\n  y &lt;&gt; x \n\nclass IDTop extends DFDesign:\n  val x  = UInt(8) &lt;&gt; IN\n  val y  = UInt(8) &lt;&gt; OUT\n  val yv = UInt(8) &lt;&gt; VAR\n  val id = ID()\n  //direct connection between\n  //parent and child design ports\n  id.x &lt;&gt; x \n  //connecting through an intermediate \n  //variable\n  id.y &lt;&gt; yv\n  y &lt;&gt; yv\n</code></pre></p> Failed port/variable connection example<pre><code>class Foo extends DFDesign:\n  val x  = UInt(8) &lt;&gt; IN\n  val y1 = Bit     &lt;&gt; OUT\n  val y2 = UInt(8) &lt;&gt; OUT\n  y1 &lt;&gt; x //DFType mismatch error\n  y2 &lt;&gt; x\n  //connection error (cannot connect \n  //to the same port more than once)\n  y2 &lt;&gt; x \n</code></pre>"},{"location":"user-guide/type-system/#assignment","title":"DFHDL Value Assignment (Mutation)","text":"<p>Both output ports and variables are mutable and can be assigned with values of the same DFType and only within the scope of the design they belong to. Input ports cannot be directly assigned, and require an intermediate variable connected to them to modify their value. Generally assignments to DFHDL values are applied through the <code>:=</code> operator. In processes under ED domains there are two kind of assignments: blocking assignments via <code>:=</code>, and non-blocking assignments via <code>:==</code>. Other domains support only blocking assignments via <code>:=</code>. Read more on domain semantics in the next section. See the connectivity section for more rules about mixing connections and assignments.</p> Successful port/variable connection example<pre><code>class Shift extends DFDesign:\n  val x = Bits(8) &lt;&gt; IN\n  val y = Bits(8) &lt;&gt; OUT\n  //assigning `x` left-shifted by 1 \n  //to `y`\n  y := x &lt;&lt; 1\n\nclass IDTop extends DFDesign:\n  val x  = UInt(8) &lt;&gt; IN\n  val y  = UInt(8) &lt;&gt; OUT\n  val yv = UInt(8) &lt;&gt; VAR\n  val id = ID()\n  //direct connection between\n  //parent and child design ports\n  id.x &lt;&gt; x \n  //connecting through an intermediate \n  //variable\n  id.y &lt;&gt; yv\n  y &lt;&gt; yv\n</code></pre>"},{"location":"user-guide/type-system/#mutability","title":"DFHDL Value Mutation","text":"<p>DFiant supports dataflow variables mutability via the <code>:=</code> operator. Do not confuse with Scala-level mutability which is enabled by using <code>var</code> instead of <code>val</code>. Each dataflow class has two variations: an immutable class, which inherits from <code>DFAny.Val</code> and a mutable class, which inherits from <code>DFAny.Var</code> and accepts <code>:=</code>. The difference between the types enforces an immutable right-hand-side (RHS), where required, and a mutable variable creation. </p> <p>Consider, for instance, the DFiant implementation of <code>g</code> in Table \\ref<code>tbl:StateExDefImpl</code>: <code>a</code> is immutable because it is a RHS addition between the dataflow variable <code>i</code> and a literal value <code>5</code>. Contrarily, <code>c</code> is mutable, since it is a dataflow variable constructor (<code>.init</code> constructs a new initialized variable, while preserving the mutability trait). </p> <p>Fig. 1 demonstrates a dual class definition for every type  (immutable and mutable). The naming convention helps to reason about the mutability. For example, <code>DFBits</code> and <code>DFBits.Var</code> are immutable and mutable classes, respectively. Constructing a new variable via <code>DFBits</code> (e.g, <code>val a = DFBits[5]</code>) returns the mutable <code>DFBits.Var[5]</code>. Usually, we either receive or return an immutable type, hence we do not require annotating a type with its mutable variation. In cases where we want to return a mutable type, we annotate it as an output port (see Section~\\ref<code>sec:io_ports</code>).</p> <p>Don't use <code>var</code> with DFHDL values/variables</p> <p>Because the semantics may get confusing, we enforced a compiler error if a dataflow variable is constructed and fed into a Scala <code>var</code> reference. For example <code>var a = DFUInt(8)</code> will generate a Scala compiler error. </p>"},{"location":"user-guide/type-system/#bit-accurate-operations-type-inference-and-data-structures","title":"Bit-Accurate Operations, Type Inference, and Data Structures","text":"<p>All DFiant's dataflow types are bit-accurate and structurally static, with their bit-width set upon construction (e.g., <code>DFBits[5]</code> is a 5-bit vector). Operations between dataflow variables produce a bit-accurate result with the proper type inference. For example, an addition between an unsigned 5-bit variable (<code>DFUInt[5]</code>) and a signed 10-bit variable (<code>DFSInt[10]</code>) produces an adder that can be implicitly converted to a 10-bit signed variable, if carry is not required, or an 11-bit signed variable by explicitly invoking <code>.wc</code> from the addition.</p> <p>DFiant also allows operations between dataflow types and their corresponding Scala numeric types, by treating the Scala numeric types as constants (e.g., addition between <code>DFSInt</code> and <code>Integer</code> variables). A constant in the dataflow graph is a node that can produce infinite tokens of the same value.   </p>"},{"location":"user-guide/type-system/#bit-aliasing-and-casting","title":"Bit Aliasing and Casting","text":"<p>Aliasing in DFiant enables referencing a part of a dataflow variable, by invoking <code>.bits(hiIdx, loIdx)</code>, which creates a bits vector alias that references the original variable at the given index parameters. Every change of a dataflow variable affects its alias and vice versa (similar to VHDL's signal aliasing). Since this function also casts the variable as <code>DFBits</code>, this feature is used as a raw-data cast between different dataflow types. Aliasing of an alias is also possible, while maintaining relative bits indexing. Aliasing preserves the mutability trait: an alias of an immutable value is immutable, while an alias of a mutable variable is mutable. </p> <p>Fig.~\\ref<code>fig:Aliasing</code> demonstrates aliasing code and its effect on the contents of a dataflow variable (<code>bits128</code>). Each line code does as follows:</p> <ol> <li>Constructs a new 128-bit vector, <code>bits128</code>, and clears it.</li> <li>Creates a new alias, <code>alias64</code>, which references the most significant 64 bits of <code>bits128</code>. Since <code>bits128</code> is a <code>DFBits</code> variable, there is no need to invoke <code>.bits()</code>, and we can apply the required indexes directly.</li> <li>Creates a new alias, <code>alias32</code>, which references the least significant 32 bits of <code>alias64</code>, which reference bits 64 to 95 of <code>bits128</code>.</li> <li>Constructs a new double precision floating point dataflow variable, <code>dbl</code>, and initialize its value as <code>1.0</code> (hexadecimal value of <code>0x3FF00...0</code>).</li> <li>Modifies the least significant byte of <code>dbl</code>.</li> <li>Sets the most significant bit of <code>bits128</code>.</li> <li>Assigns <code>dbl</code> to the least significant 64 bits of <code>bits128</code> through casting. All the bits of <code>dbl</code> are selected because <code>.bits()</code> is invoked without index parameters.</li> <li>Modifies a byte of <code>bits128</code>.</li> </ol>"},{"location":"user-guide/type-system/#bubble","title":"Bubble Values","text":"<ul> <li>RT and ED - Don't Care / Unknown</li> <li>DF - Stall</li> </ul>"},{"location":"user-guide/type-system/#dfhdl-value-candidates","title":"DFHDL Value Candidates","text":"<p>TODO: requires explanation The candidate produces a constant DFHDL value if the candidate argument is a constant.</p> <p>Operation supported values for an argument of DFType <code>T</code></p> `T`Candidate`T`ValueAnyValue`T`OperationCandidate . is! .. is? .. is? .. is! .. is? . Bits assignment and concatenation operation candidates example<pre><code>val b8 = Bits(8) &lt;&gt; VAR //8-bits variable\nval b9 = Bits(9) &lt;&gt; VAR //9-bits variable\n\n//Assignment operations to b8 accept either\n//Bits candidates that are 8-bit wide or\n//a same-element-vector (SEV) of \n//0/1/true/false, via `all(elem)`.\nb8 := h\"FF\"  //ok: 8-bits constant\nb8 := all(0) //ok: SEV of 0\nb8 := 5      //fails `Bits` candidate\nb8 := b9     //fails `:=` candidate\n\n//Bits `++` concatenation operation with b8\n//only accepts Bits candidate, while SEV\n//is not a Bits candidate.\nval x = b8 ++ h\"FF\"  //ok\nval y = b8 ++ all(0) //error\n</code></pre>"},{"location":"user-guide/type-system/#DFBitOrBool","title":"<code>Bit</code>/<code>Boolean</code> DFHDL Values","text":"<p><code>Bit</code> DFHDL values represent binary <code>1</code> or <code>0</code> values, whereas <code>Boolean</code> DFHDL values represent <code>true</code> or <code>false</code> values, respectively. The <code>Bit</code> and <code>Boolean</code> DFHDL values are generally interchangeable, and automatically converted between one and the other. </p> <p>Should I use <code>Bit</code> or <code>Boolean</code> DFTypes?</p> <p>Although they are interchangeable, it's generally recommended to use <code>Boolean</code> DFHDL values with conditional <code>if</code> statements, guards, or expressions, and <code>Bit</code> DFHDL values for everything else. There could be constant parameters that are better defined as a <code>true</code> or <code>false</code> <code>Boolean</code> values rather than <code>0</code> or <code>1</code> <code>Bit</code> values.</p> Why have both <code>Bit</code> and <code>Boolean</code> DFTypes? <p>The main reason to differentiate between <code>Bit</code> and <code>Boolean</code> is that VHDL has both <code>std_logic</code> and <code>boolean</code> types, respectively. Verilog has only a single <code>logic</code> or <code>wire</code> to represent both. Indeed VHDL'2008 has relaxed some of the type constraints, but not enough. And nevertheless, DFHDL aims to support various HDL dialects, and thus enables simple implicit or explicit conversion between these two DFType values.</p>"},{"location":"user-guide/type-system/#dftype-constructors","title":"DFType Constructors","text":"<p>Use the <code>Bit</code> or <code>Boolean</code> objects/types to construct <code>Bit</code> or <code>Boolean</code> DFHDL values, respectively.</p> <pre><code>val bit   = Bit     &lt;&gt; VAR\nval bool  = Boolean &lt;&gt; VAR\nval c_bit:  Bit     &lt;&gt; CONST = 1\nval c_bool: Boolean &lt;&gt; CONST = false\n</code></pre>"},{"location":"user-guide/type-system/#candidates","title":"Candidates","text":"<ul> <li>DFHDL <code>Bit</code> values.</li> <li>DFHDL <code>Boolean</code> values. </li> <li>Scala <code>1</code> or <code>0</code> literal values. A regular Scala <code>Int</code> is not accepted. This candidate always produces a constant DFHDL value.</li> <li>Scala <code>Boolean</code> values. This candidate always produces a constant DFHDL value.</li> </ul> <pre><code>val bit  = Bit     &lt;&gt; VAR\nval bool = Boolean &lt;&gt; VAR\n//`bool` is implicitly converted to a \n//Bit DFHDL value.\nbit := bool \n//`1` is implicitly converted to a DFHDL\n//Bit constant value.\nbit := 1\n//`false` is implicitly converted to a \n//DFHDL Boolean constant, and then\n//converted to a Bit constant value.\nbit := false\nval one: Int = 1\n//error (only 1/0 literals are ok)\nbit := one \n//`bit` is implicitly converted to a\n//DFHDL Boolean\nbool := bit \n//`true` is implicitly converted to a \n//DFHDL Boolean constant value.\nbool := true\n//`0` is implicitly converted to a \n//DFHDL Bit constant, and then\n//converted to a Boolean constant value.\nbool := 0\nval TrueVal: Boolean = 1\n//`TrueVal` is implicitly converted to\n//a DFHDL Boolean value.\nbool := TrueVal \n</code></pre>"},{"location":"user-guide/type-system/#operations","title":"Operations","text":""},{"location":"user-guide/type-system/#explicit-casting-operations","title":"Explicit Casting Operations","text":"<p>These operations propagate constant modifiers, meaning that if the casted argument is a constant, the returned value is also a constant.</p> Operation Description LHS Constraints Returns <code>lhs.bool</code> Cast to a DFHDL <code>Boolean</code> value <code>Bit</code> DFHDL value <code>Boolean</code> DFHDL value <code>lhs.bit</code> Cast to a DFHDL <code>Bit</code> value <code>Boolean</code> DFHDL value <code>Bit</code> DFHDL value <pre><code>val bt1 = Bit &lt;&gt; VAR\nval bl1 = bt1.bool\nval bl2 = Boolean &lt;&gt; VAR\nval bt2 = bl2.bit\nval bt3: Bit     &lt;&gt; CONST = 0\nval bl3: Boolean &lt;&gt; CONST = bt3.bool\nval bl4: Boolean &lt;&gt; CONST = true\nval bt4: Bit     &lt;&gt; CONST = bt4.bit\n// error: bt1 is not a constant\nval err: Bit     &lt;&gt; CONST = bt1\n</code></pre>"},{"location":"user-guide/type-system/#bit-history-operations","title":"Bit History Operations","text":"<p>Currently these operations are only supported under ED domains. However, in upcoming DFHDL updates, support will be added across all domain abstractions.</p> Operation Description LHS Constraints Returns <code>lhs.rising</code> True when a value changes from <code>0</code> to <code>1</code> <code>Bit</code> DFHDL value <code>Boolean</code> DFHDL value <code>lhs.falling</code> True when a value changes from <code>1</code> to <code>0</code> <code>Bit</code> DFHDL value <code>Boolean</code> DFHDL value <pre><code>class Foo extends EDDesign:\n  val clk  = Bit &lt;&gt; IN\n\n  /* VHDL-style */\n  process(clk):\n    if (clk.rising) \n      //some sequential logic\n\n  /* Verilog-style */\n  process(clk.rising):\n    //some sequential logic\n</code></pre> Transitioning from Verilog <p>Under the ED domain, the <code>x.rising</code> and <code>x.falling</code> operations are equivalent to the Verilog <code>posedge x</code> and <code>negedge x</code>, respectively.  In future releases these operations will have an expanded functionality under the other design domains.</p> Transitioning from VHDL <p>Under the ED domain, the <code>x.rising</code> and <code>x.falling</code> operations are equivalent to the VHDL <code>rising_edge(x)</code> and <code>falling_edge(x)</code>, respectively. In future releases these operations will have an expanded functionality under the other design domains.</p> <p>For more information see either the design domains or processes sections.</p>"},{"location":"user-guide/type-system/#logical-operations","title":"Logical Operations","text":"<p>Logical operations' return type always match the LHS argument's type. These operations propagate constant modifiers, meaning that if all arguments are constant, the returned value is also a constant.</p> Operation Description LHS/RHS Constraints Returns <code>lhs &amp;&amp; rhs</code> Logical AND The LHS argument must be a <code>Bit</code>/<code>Boolean</code> DFHDL value. The RHS must be a <code>Bit</code>/<code>Boolean</code> candidate. LHS-Type DFHDL value <code>lhs || rhs</code> Logical OR The LHS argument must be a <code>Bit</code>/<code>Boolean</code> DFHDL value. The RHS must be a <code>Bit</code>/<code>Boolean</code> candidate. LHS-Type DFHDL value <code>lhs ^ rhs</code> Logical XOR The LHS argument must be a <code>Bit</code>/<code>Boolean</code> DFHDL value. The RHS must be a <code>Bit</code>/<code>Boolean</code> candidate. LHS-Type DFHDL value <code>!lhs</code> Logical NOT The argument must be a <code>Bit</code>/<code>Boolean</code> DFHDL value. LHS-Type DFHDL value <pre><code>val bt = Bit     &lt;&gt; VAR\nval bl = Boolean &lt;&gt; VAR\nval t1 = bt &amp;&amp; bl    //result type: Bit\nval t2 = bt ^ 1      //result type: Bit\nval t3 = bl || false //result type: Boolean\nval t4 = bt &amp;&amp; true  //result type: Bit\nval t5 = bl || bt    //result type: Boolean\nval t6 = bl ^ 0 || !bt\n//`t7` after the candidate implicit\n//conversions, looks like so:\n//(bl &amp;&amp; bt.bool) ^ (!(bt || bl.bit)).bool\nval t7 = (bl &amp;&amp; bt) ^ !(bt || bl)\n//error: swap argument positions to have\n//the DFHDL value on the LHS.\nval e1 = 0 ^ bt      \n//error: swap argument positions to have\n//the DFHDL value on the LHS.\nval e2 = false ^ bt\n//not supported since both arguments\n//are just candidates\nval e3 = 0 ^ true\n//This just yields a Scala Boolean, \n//as a basic operation between Scala\n//Boolean values.\nval sc: Boolean = true &amp;&amp; true\n</code></pre> Transitioning from Verilog <p>Under the ED domain, the following operations are equivalent:</p> DFHDL Operation Verilog Operation <code>lhs &amp;&amp; rhs</code> <code>lhs &amp; rhs</code> <code>lhs || rhs</code> <code>lhs | rhs</code> <code>lhs ^ rhs</code> <code>lhs ^ rhs</code> <code>!lhs</code> <code>!lhs</code> Transitioning from VHDL <p>Under the ED domain, the following operations are equivalent:</p> DFHDL Operation VHDL Operation <code>lhs &amp;&amp; rhs</code> <code>lhs and rhs</code> <code>lhs || rhs</code> <code>lhs or rhs</code> <code>lhs ^ rhs</code> <code>lhs xor rhs</code> <code>!lhs</code> <code>not lhs</code>"},{"location":"user-guide/type-system/#constant-meta-operations","title":"Constant Meta Operations","text":"<p>These operations are activated during the elaboration stage of the DFHDL compilation, and are only available for constant <code>Bit</code>/<code>Boolean</code> DFHDL values.  Their use case is for meta-programming purposes, to control the generated code without the knowledge of the DFHDL compiler (could be considered as pre-processing steps).</p> Operation Description LHS Constraints Returns <code>lhs.toScalaBitNum</code> Extracts the known elaboration Scala <code>BitNum</code>(<code>1 | 0</code>) value from a constant DFHDL <code>Bit</code>/<code>Boolean</code> value Constant <code>Bit</code>/<code>Boolean</code> DFHDL value Scala <code>BitNum</code> value <code>lhs.toScalaBoolean</code> Extracts the known elaboration Scala <code>Boolean</code> value from a constant DFHDL <code>Bit</code>/<code>Boolean</code> value Constant <code>Bit</code>/<code>Boolean</code> DFHDL value Scala <code>Boolean</code> value <p>The following runnable example demonstrates how such meta operation affect the elaborated design.  The <code>Boolean</code> argument <code>arg</code> of a design <code>Foo</code> is used twice within the design:  first, in an <code>if</code> condition directly; and second, in an <code>if</code> condition after a Scala value extraction.  When referenced directly, the <code>if</code> is elaborated as-is, but when the <code>if</code> is applied on the extracted Scala value,  the <code>if</code> is completely removed and either the block inside the <code>if</code> is elaborated when the argument is true or completely removed if false.</p> <code>Foo</code><code>Foo(true)</code><code>Foo(false)</code> <pre><code>class Foo(\n    val arg: Boolean &lt;&gt; CONST\n) extends DFDesign:\n  val o = Bit &lt;&gt; OUT\n  if (!arg) o := 1 \n  if (arg.toScalaBoolean) o := 0\n</code></pre> <pre><code>class Foo(\n    val arg: Boolean &lt;&gt; CONST\n) extends DFDesign:\n  val o = Bit &lt;&gt; OUT\n  if (!arg) o := 1 \n  o := 0\n</code></pre> <pre><code>class Foo(\n    val arg: Boolean &lt;&gt; CONST\n) extends DFDesign:\n  val o = Bit &lt;&gt; OUT\n  if (!arg) o := 1 \n</code></pre> Runnable example <pre><code>import dfhdl.*\n\nclass Foo(\n    val arg: Boolean &lt;&gt; CONST\n) extends DFDesign:\n  val o = Bit &lt;&gt; OUT\n  if (!arg) o := 1 \n  if (arg.toScalaBoolean) o := 0\n\n@main def main = \n  println(\"Foo(true) Elaboration:\")\n  Foo(true).printCodeString\n  println(\"Foo(false) Elaboration:\")\n  Foo(false).printCodeString</code></pre>"},{"location":"user-guide/type-system/#DFBits","title":"<code>Bits</code> DFHDL Values","text":"<p><code>Bits</code> DFHDL values represent vectors of DFHDL <code>Bit</code> values as elements.  The vector bits width (length) is a positive constant number (nilable [zero-width] vectors will be supported in the future).</p> <p>Differences between DFHDL <code>Bits</code> and DFHDL Vector of <code>Bit</code></p> <p>In addition to <code>Bits</code>, DFHDL also supports generic vectors of any DFHDL values.  One could therefore construct a generic vector with <code>Bit</code> as the element DFType.  This vector has a different type than <code>Bits</code>, since <code>Bits</code> is a special case, both internally  in their implementations and externally in their API. Where applicable, both <code>Bits</code> and generic vector of <code>Bits</code> have overlapping equivalent APIs. </p>"},{"location":"user-guide/type-system/#dftype-constructors_1","title":"DFType Constructors","text":"Constructor Description Arg Constraints Returns <code>Bits(width)</code> Construct a <code>Bits</code> DFType with the given <code>width</code> as number of bits. <code>width</code> is a positive Scala <code>Int</code> or constant DFHDL <code>Int</code> value. <code>Bits[width.type]</code> DFType <code>Bits.until(sup)</code> Construct a <code>Bits</code> DFType with the given <code>sup</code> supremum number the vector is expected to reach. The number of bits is set as <code>clog2(sup)</code>. <code>sup</code> is a Scala <code>Int</code> or constant DFHDL <code>Int</code> value larger than 1. <code>Bits[CLog2[width.type]]</code> DFType <code>Bits.to(max)</code> Construct a <code>Bits</code> DFType with the given <code>max</code> maximum number the vector is expected to reach. The number of bits is set as <code>clog2(max+1)</code>. <code>max</code> is a positive Scala <code>Int</code> or constant DFHDL <code>Int</code> value. <code>Bits[CLog2[width.type+1]]</code> DFType <code>Bits[W]</code> Construct a <code>Bits</code> DFType with the given <code>W</code> width as Scala type argument (for advanced users). <code>width</code> is a positive Scala <code>Int</code> or constant DFHDL <code>Int</code> Singleton type. <code>Bits[W]</code> DFType <pre><code>val b8 = Bits(8)       &lt;&gt; VAR\nval b3 = Bits.until(8) &lt;&gt; VAR\nval b4 = Bits.to(8)    &lt;&gt; VAR\nval b9 = Bits[9]       &lt;&gt; VAR\nval w: Int &lt;&gt; CONST = 7\nval b7 = Bits(w)       &lt;&gt; VAR\nval b6: Bits[6] &lt;&gt; CONST = all(0)\n</code></pre> Transitioning from Verilog <ul> <li>Specifying a width instead of an index range: In Verilog bit vectors are declared with an index range that enables outliers like non-zero index start, negative indexing or changing bit order. These use-cases are rare and they are better covered using different language constructs. Therefore, DFHDL simplifies things by only requiring a single width/length argument which yields a <code>[width-1:0]</code> sized vector (for generic vectors the element order the opposite).</li> <li>Additional constructors: DFHDL provides additional constructs to simplify some common Verilog bit vector declaration. For example, instead of declaring <code>reg [$clog2(DEPTH)-1:0] addr</code> in Verilog, in DFHDL simply declare <code>val addr = Bits.until(DEPTH) &lt;&gt; VAR</code>.</li> </ul> Transitioning from VHDL <ul> <li>Specifying a width instead of an index range: In VHDL bit vectors are declared with an index range that enables outliers like non-zero index start, negative indexing or changing bit order. These use-cases are rare and they are better covered using different language constructs. Therefore, DFHDL simplifies things by only requiring a single width/length argument which yields a <code>(width-1 downto 0)</code> sized vector (for generic vectors the element order the opposite).</li> <li>Additional constructors: DFHDL provides additional constructs to simplify some common VHDL bit vector declaration. For example, instead of declaring <code>signal addr: std_logic_vector(clog2(DEPTH)-1 downto 0)</code> in VHDL, in DFHDL simply declare <code>val addr = Bits.until(DEPTH) &lt;&gt; VAR</code>.</li> </ul>"},{"location":"user-guide/type-system/#literal-constant-value-generation","title":"Literal (Constant) Value Generation","text":"<p>Literal (constant) DFHDL <code>Bits</code> value generation is carried out through binary and hexadecimal string interpolation, a core Scala feature that was customized for DFHDL's exact use-case. There are also bit-accurate decimal and signed decimal interpolations available that produce <code>UInt</code> and <code>SInt</code> DFHDL values. If needed, those values can be cast to <code>Bits</code>. No octal interpolation is currently available or planned.</p>"},{"location":"user-guide/type-system/#b-interp","title":"Binary Bits String-Interpolator","text":"Binary Bits string-interpolation syntax<pre><code>b\"width'bin\"\n</code></pre> <ul> <li>bin is a sequence of <code>0</code>, <code>1</code>, and <code>?</code> characters, each representing a single bit.  <code>?</code> indicates a bit bubble.    The leftest (first) character is the most-significant bit (MSB), and the rightest (last) character is    the least-significant bit (LSB). </li> <li>Separators <code>' '</code> (space) or <code>_</code> (underscore) within <code>bin</code> are ignored.</li> <li><code>bin</code> can also contain interpolated Scala <code>String</code> arguments through <code>${arg}</code>.</li> <li>width, followed by a <code>'</code> (apostrophe), is optional and specifies the bit vector's width. If   omitted, the minimal width is inferred from the sequence length. If specified, leading zeros   are added at the left of the sequence or the sequence is truncated based on the <code>width</code>.    Truncation only occurs if the MSBits being removed are zeros; otherwise, it triggers a   compilation error.</li> <li><code>width</code> can be an interpolated argument of either Scala <code>Int</code> or a Constant DFHDL <code>Int</code> value.</li> <li>Returns: A constant DFHDL <code>Bits</code> value with the inferred or set width.</li> </ul> Binary Bits string-interpolation examples<pre><code>b\"1\"        // Value = 1\nb\"1000\"     // Value = 1000\nb\"8'1000\"   // Value = 00001000\nb\"3'0100\"   // Value = 100\nb\"3'1100\"   // Compilation error\nb\"1?11\"     // Value = 1?11 (? indicates a bit bubble)\nb\"11_00\"    // Value = 1100\nval value = \"100\"\nval width = 10\nb\"$width'1${value}1\" //Value = 0000011001\nval p: Int &lt;&gt; CONST = 10\nb\"$p'0\" // Value = 0....0 (p-bits wide)\n</code></pre> Transitioning from Verilog <p>This interpolation covers the Verilog binary literal use-cases, but also adds the ability for parametric <code>width</code> to be set. The high impedance (high-Z) use-cases will be supported in the future, likely using a different language construct.</p> Transitioning from VHDL <p>This interpolation covers the VHDL binary literal use-cases, but also adds the ability for parametric <code>width</code> to be set. The high impedance (high-Z) use-cases will be supported in the future, likely using a different language construct.</p>"},{"location":"user-guide/type-system/#h-interp","title":"Hexadecimal Bits String-Interpolator","text":"Hexadecimal Bits string-interpolation syntax<pre><code>h\"width'hex\"\n</code></pre> <ul> <li>hex is a sequence of hexadecimal characters (<code>0</code>-<code>9</code>, <code>A</code>-<code>F</code>, <code>a</code>-<code>f</code>, and <code>?</code>)   where <code>?</code> indicates a 4-bit bubble. Each character represents a 4-bit nibble,    encoded such that the leftest bit is the most-significant bit.    The leftest (first) character is the most-significant nibble, and the rightest (last) character is    the least-significant nibble. </li> <li>Separators <code>' '</code> (space) or <code>_</code> (underscore) within <code>hex</code> are ignored.</li> <li><code>hex</code> can also contain interpolated Scala <code>String</code> arguments through <code>${arg}</code>.</li> <li>Binary sequences can be embedded within <code>{bin}</code> tags, allowing integration of binary   bit sequences of any length, not necessarily divisible by 4, between hex nibbles.</li> <li>width, followed by a <code>'</code>, is optional and specifies the bit vector's width. If   omitted, the minimal width is inferred from the sequence length. If specified, leading zeros   are added or the sequence is truncated based on the <code>width</code>. Truncation only occurs if   the most significant bits being removed are zeros or bubbles; otherwise, it triggers a   compilation error.</li> <li><code>width</code> can be an interpolated argument of either Scala <code>Int</code> or a Constant DFHDL <code>Int</code> value.</li> <li>Returns: A constant DFHDL <code>Bits</code> value with the inferred or set width.</li> </ul> Hexadecimal Bits string-interpolation examples<pre><code>h\"1\"        // Value = 0001\nh\"27\"       // Value = 00100111\nh\"6'27\"     // Value = 100111\nh\"5'27\"     // Compilation error\nh\"2?\"       // Value = 0010????\nh\"F{00}F\"   // Value = 1111001111\nh\"3_3\"      // Value = 00110011\nval value = \"FF\"\nval width = 10\nh\"$width'${value}\" //Value = 0011111111\n</code></pre> Transitioning from Verilog <p>This interpolation covers the Verilog hexadecimal literal use-cases, but also adds the ability for parametric <code>width</code> to be set. The high impedance (high-Z) use-cases will be supported in the future, likely using a different language construct.</p> Transitioning from VHDL <p>This interpolation covers the VHDL hexadecimal literal use-cases, but also adds the ability for parametric <code>width</code> to be set. The high impedance (high-Z) use-cases will be supported in the future, likely using a different language construct.</p>"},{"location":"user-guide/type-system/#candidates_1","title":"Candidates","text":"<ul> <li>DFHDL <code>Bits</code> values</li> <li>DFHDL <code>Bit</code> or <code>Boolean</code> values. This candidate produces a single bit <code>Bits[1]</code> vector. </li> <li>DFHDL <code>UInt</code> values</li> <li>Scala <code>Tuple</code> combination of any DFHDL values and <code>1</code>/<code>0</code> literal values. This candidate performs bit concatenation of all values, according their order in the tuple, encoded from the most-significant value position down to the least-significant value position.</li> <li>Application-only candidate - Same-Element Vector (<code>all(elem)</code>).  </li> </ul> <pre><code>val b8   = Bits(8) &lt;&gt; VAR\nval b1   = Bits(1) &lt;&gt; VAR\n//`bit` is implicitly converted to a \n//Bits[1] DFHDL value.\nval bit  = Bit     &lt;&gt; VAR\nb1 := bit\n//`bool` is implicitly converted to a \n//Bits[1] DFHDL value.\nval bool = Boolean &lt;&gt; VAR\nbool := bit\n//`u8` is implicitly converted to a \n//Bits[8] DFHDL value.\nval u8   = UInt(8) &lt;&gt; VAR\nb8 := u8\nval s4   = SInt(4) &lt;&gt; VAR\n//the tuple is implicitly converted\n//to a Bits[8] DFHDL value.\nb8 := (1, s4, b1, b\"10\")\n</code></pre>"},{"location":"user-guide/type-system/#concatenated-assignment","title":"Concatenated Assignment","text":"<p>DFHDL supports a special-case assignment of concatenated DFHDL Bits variables, using a Scala <code>Tuple</code> syntax on LHS of the assignment operator. Both LHS and RHS bits width must be the same. This assignment is just syntactic sugar for multiple separate assignments and carried out during the design elaboration. The assignment ordering is from the first value at most-significant position down to the last value at least-significant position.</p> <code>Foo Declaration</code><code>Foo Elaboration</code> <pre><code>class Foo extends DFDesign:\n  val i4 = Bits(4) &lt;&gt; IN\n  val b2 = Bits(2) &lt;&gt; OUT\n  val b3 = Bits(3) &lt;&gt; OUT\n  val b5 = Bits(5) &lt;&gt; OUT\n  (b2, b5, b3) := (b\"101\", i4, b\"111\")\n</code></pre> <pre><code>class Foo extends DFDesign:\n  val i4 = Bits(4) &lt;&gt; IN\n  val b2 = Bits(2) &lt;&gt; OUT\n  val b3 = Bits(3) &lt;&gt; OUT\n  val b5 = Bits(5) &lt;&gt; OUT\n  b2 := b\"10\"\n  b5 := (b\"1\", i4).toBits\n  b3 := b\"111\"\n</code></pre> Runnable example <pre><code>import dfhdl.*\n\nclass Foo extends DFDesign:\n  val i4 = Bits(4) &lt;&gt; IN\n  val b2 = Bits(2) &lt;&gt; OUT\n  val b3 = Bits(3) &lt;&gt; OUT\n  val b5 = Bits(5) &lt;&gt; OUT\n  (b2, b5, b3) := (b\"101\", i4, b\"111\")\n\n@main def main = \n  Foo().printCodeString</code></pre>"},{"location":"user-guide/type-system/#DFDecimal","title":"<code>UInt</code>/<code>SInt</code>/<code>Int</code> DFHDL Values","text":""},{"location":"user-guide/type-system/#constant-generation","title":"Constant Generation","text":""},{"location":"user-guide/type-system/#d-interp","title":"Decimal String-Interpolator","text":""},{"location":"user-guide/type-system/#sd-interp","title":"Signed Decimal String-Interpolator","text":""},{"location":"user-guide/type-system/#DFEnum","title":"Enumeration DFHDL Values","text":""},{"location":"user-guide/type-system/#DFVector","title":"Vector DFHDL Values","text":""},{"location":"user-guide/type-system/#DFStruct","title":"Struct DFHDL Values","text":""},{"location":"user-guide/type-system/#DFTuple","title":"Tuple DFHDL Values","text":""},{"location":"user-guide/type-system/#DFOpaque","title":"Opaque DFHDL Values","text":""},{"location":"user-guide/type-system/#DFUnit","title":"Unit (Void) DFHDL Values","text":""}]}